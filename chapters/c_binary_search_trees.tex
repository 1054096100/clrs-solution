\startcomponent c_binary_search_trees

\startchapter[
  title={Binary Search Trees},
]

\startsection[
  title={What is a binary search tree?},
]

%e12.1-1
\startEXERCISE
對於關鍵字集合 \m{\{1,4,5,10,16,17,21\}}，分別畫出高度爲 2、 3、 4、 5 和 6 的二叉搜索樹。
\stopEXERCISE

\startANSWER
\externalfigure[output/e12_1_1-1]
\externalfigure[output/e12_1_1-2]
\externalfigure[output/e12_1_1-3]
\externalfigure[output/e12_1_1-4]
\externalfigure[output/e12_1_1-5]
\stopANSWER

%e12.1-2
\startEXERCISE
二叉搜索樹的性質與最小堆（參見\refsection{heaps}）性質有什麼不同？
能使用最小堆性質在 \m{O(n)} 時間內按序輸出一棵有 n 個節點的二叉搜索樹的所有關鍵字嗎？
可以的話，請說明如何做，否則解釋理由。
\stopEXERCISE

\startANSWER
二叉搜索樹：左子樹所有節點小於自己，右子樹的所有節點大於自己。

最小堆：左子樹和右子樹的所有節點均大於自己。

不能。原因是最小堆中左右子樹的大小關係不固定。
結果就是不能按照樹的前、中、後序遍歷在 \m{O(n)} 時間內按序輸出。
而二叉搜索樹，左右子樹大小關係固定，可以用中序遍歷按序輸出。
\stopANSWER

%e12.1-3
\startEXERCISE
設計一個執行中序遍歷的非遞歸算法。
（\hint 種較爲簡單的方法是使用棧作爲輔助結構；
另一種較複雜但比較簡潔的做法是不用棧，但要假設能測試兩個指針是否相等。）
\stopEXERCISE

\startANSWER
\CLRSH{INORDER-TREE-WALK(root)}
\startCLRS
prev = NIL
node = root
while node ！= NIL
	if prev == node.p
		if node.left != NIL
			prev = node
			node = node.left
		else
			output node.key
			if node.right != NIL
				prev = node
				node = node.right
			else
				prev = node
				node = node.p
	else if prev == node.left
		output node.key
		if node.right != NIL
			prev = node
			node = node.right
		else
			prev = node
			node = node.p
	else if prev == node.right
		prev = node
		node = node.p
\stopCLRS
\stopANSWER

%e12.1-4
\startEXERCISE
對於一棵有 n 個節點的二叉搜索樹，
設計可以在 \m{\Theta(n)} 時間內完成的先序遍歷算法和後序遍歷算法。
\stopEXERCISE

\startANSWER
\CLRSH{PREORDER-TREE-WALK(root)}
\startCLRS
prev = NIL
node = root
while node ！= NIL
	if prev == node.p
		output node.key
		if node.left != NIL
			prev = node
			node = node.left
		else
			if node.right != NIL
				prev = node
				node = node.right
			else
				prev = node
				node = node.p
	else if prev == node.left
		if node.right != NIL
			prev = node
			node = node.right
		else
			prev = node
			node = node.p
	else if prev == node.right
		prev = node
		node = node.p
\stopCLRS

\CLRSH{POSTORDER-TREE-WALK(root)}
\startCLRS
prev = NIL
node = root
while node ！= NIL
	if prev == node.p
		if node.left != NIL
			prev = node
			node = node.left
		else
			if node.right != NIL
				prev = node
				node = node.right
			else
				output node.key
				prev = node
				node = node.p
	else if prev == node.left
		if node.right != NIL
			prev = node
			node = node.right
		else
			output node.key
			prev = node
			node = node.p
	else if prev == node.right
		output node.key
		prev = node
		node = node.p
\stopCLRS
\stopANSWER

%e12.1-5
\startEXERCISE
因爲在基於比較的排序模型中，完成 n 個元素的排序，
其最壞情況下需要 \m{\Omega(n\lg{n})} 的時間。
試證明：任何基於比較的算法從 n 個元素的任意序列中構造一棵二叉搜索樹，
其最壞情況下需要 \m{\Omega(n\lg{n})} 的時間。
\stopEXERCISE

\startANSWER
構造二叉搜索樹的過程本質就是一個排序的過程，
所以最壞情況需要的時間與比較排序相同，都是 \m{\Omega(n\lg{n})}。
\stopANSWER

\stopsection

\startsection[
  title={Querying a binary search tree},
]

%e12.2-1
\startEXERCISE
假設一棵二叉搜索樹中的節點在 1 到 1000 之間，
現在想要查找數值爲 363 的節點。
下面序列中哪個不是查找過的序列？
\startigBase[a]
\item \m{2,252,401,398,330,344,397,363}；
\item \m{924,220,911,244,898,258,362,363}；
\item \m{925,202,911,240,912,245,363}；
\item \m{2,399,387,219,266,382,381,278,363}；
\item \m{935,278,347,621,299,392,358,363}；
\stopigBase
\stopEXERCISE

\startANSWER
c 中 911 和 912 不符合二叉搜索樹的性質。

e 中 347 和 299 不符合二叉搜索樹的性質。
\stopANSWER

%e12.2-2
\startEXERCISE
寫出 \ALGO{TREE-MINIMUM} 和 \ALGO{TREE-MAXIMUM} 的遞歸版本。
\stopEXERCISE

\startANSWER
\CLRSH{TREE-MINIMUM(x)}
\startCLRS
if x.lchild == NIL
	return x;
else
	TREE-MINIMUM(x.lchild)
\stopCLRS

\CLRSH{TREE-MAXIMUM(x)}
\startCLRS
if x.rchild == NIL
	return x;
else
	TREE-MAXIMUM(x.rchild)
\stopCLRS
\stopANSWER

%e12.2-3
\startEXERCISE
寫出過程 \ALGO{TREE-PREDECESSOR} 的僞碼。
\stopEXERCISE

\startANSWER
\CLRSH{TREE_PREDECESSOR(x)}
\startCLRS
if x.lchild != NIL
	return TREE-MAXIMUM(x.lchild)
y = x.p
while y != NIL and y.lchild == x
	x = y
	y = y.p
return y
\stopCLRS
\stopANSWER

%e12.2-4
\startEXERCISE
Bunyan 教授認爲他發現了一個二叉搜索樹的重要性質。
假設在一棵二叉搜索樹中查找一個關鍵字 k，查找結束於一個樹葉。
考慮三個集合： A 爲查找路徑左邊的關鍵字集合；
 B 爲查找路徑上的關鍵字集合； C 爲查找路徑右邊的關鍵字集合。
 Bunyan 教授聲稱：任何 \m{a\in A}， \m{b\in B} 和 \m{c\in C}，一定滿足 \m{a\le b\le c}。
請給出該教授這個論斷的一個可能的最小反例。
\stopEXERCISE

\startANSWER
\externalfigure[output/e12_2_4-1]
查找路徑爲 \m{(1,3,4)\in B}， \m{2\in A}，所以 \m{2>1}。
\stopANSWER

%e12.2-5
\startEXERCISE
證明：如果一棵二叉搜索樹中的一個節點有兩個孩子，
那麼他的後繼沒有左孩子，他的前驅沒有右孩子。
\stopEXERCISE

\startANSWER
令此節點爲 x，後繼爲 y，而後繼 y 有左孩子 z，y 和 z 均在 x 的右子樹上，
則 \m{x < z < y}，這與 y 爲 x 的後繼相矛盾，所以 x 的後繼沒有左孩子。

同理， x 的前驅沒有右孩子。
\stopANSWER

%e12.2-6
\startEXERCISE
考慮一棵二叉搜索樹 T，其關鍵字互不相同。
證明：如果 T 中一個節點 x 的右子樹爲空，且 x 有一個後繼 y，
那麼 y 一定是 x 的最底層祖先。並且 y 的左孩子也是 x 的祖先。
（注意：每個節點都是他自己的祖先。）
\stopEXERCISE

\startANSWER
若 x 是其後繼 y 的左孩子，那麼 \m{x.key\le y.key}，
所以 y 是 x 的最低祖先， y 的左孩子 x 也是 x 的祖先。

若 x 是其後繼 y 的右孩子，那麼 \m{x.key\ge y.key}，這明顯與後繼的定義相矛盾。

若 x 是其後繼 y 的左孩子 z 的右孩子，那麼 \m{z.key\le x.key\le y.key}，
所以 y 的左孩子 z 是 x 的祖先， y 是 x 的最低祖先。
\stopANSWER

%e12.2-7
\startEXERCISE
對於一棵有 n 個節點的二叉搜索樹，有另一種方法來實現中序遍歷，
先調用 \ALGO{TREE-MINIMUM} 找到這棵樹中的最小元素，
然後再調用 \m{n-1} 次的 \ALGO{TREE-SUCCESSOR}。
證明：該算法的運行時間爲 \m{\Theta(n)}。
\stopEXERCISE

\startANSWER
此方法等同於 \ALGO{INORDER-TREE-WALK}。

在 \m{n-1} 條邊上，通過每條邊最多兩次。
\stopANSWER

%e12.2-8
\startEXERCISE[exercise:cont_successor]
證明：在一棵高度爲 h 的二叉搜索樹中，不論從哪個節點開始，
 k 次連續的 \ALGO{TREE-SUCCESSOR} 調用所需時間爲 \m{O(k+h)}。
\stopEXERCISE

\startANSWER
假設從根結點開始運行 n 步，總時間爲 \m{O(n+h)}。
則從 \m{n-k+1} 到 \m{n} 的連續 k 步開銷爲 \m{O(k+h)}。
\stopANSWER

%e12.2-9
\startEXERCISE
設 T 是一棵二叉搜索樹，其關鍵字互不相同；
設 x 是一個葉子節點， y 爲其父節點。
證明： \m{y.key} 是 T 中大於 \m{x.key} 的最小關鍵字，
或者是 T 中小於 \m{x.key} 的最大關鍵字。
\stopEXERCISE

\startANSWER
按中序遍歷， x 和 y 相鄰。
\stopANSWER

\stopsection

\startsection[
  title={Insertion and deletion},
]
\stopsection

%e12.3-1
\startEXERCISE
給出 \ALGO{TREE-INSERT} 過程的遞歸版本。
\stopEXERCISE

\startANSWER
\CLRSH{TREE-INSERT(p, z)}
\startCLRS
if z.key < p.key
	if p.left == NIL
		p.left = z
		z.p = p
	else TREE-INSERT(p.left, z)
else
	if p.right == NIL
		p.right = z
		z.p = p
	else TREE-INSERT(p.right, z)
\stopCLRS
\stopANSWER

%e12.3-2
\startEXERCISE
假設通過反復向一棵樹中插入互不相同的關鍵字來構造一棵二叉搜索樹。
證明：在這棵樹中查找關鍵字所檢查過的節點數目等於先前插入這個關鍵字所檢查的節點數目加 1。
\stopEXERCISE

\startANSWER
插入和搜索的路徑是相同的，除了最後一個節點。
\stopANSWER

%e12.3-3
\startEXERCISE
對於給定的 n 個數的集合，可以通過先構造包含這些數據的一棵二叉搜索樹
（反復使用 \ALGO{TREE-INSERT} 逐個插入這些數），
然後按中序遍歷輸出這些數，這樣就可以對這些數進行排序。
這個排序算法的最壞情況運行時間和最好情況運行時間各爲多少？
\stopEXERCISE

\startANSWER
最壞情況爲 \m{\Theta(n^2)}，數據本來就是有序的，所生成的二叉樹高度爲 n。

最好情況爲 \m{\Theta(n\lg{n})}，如果所生成的二叉樹高度爲 \m{\Theta(\lg{n})}。
\stopANSWER

%e12.3-4
\startEXERCISE
刪除操作可交換嗎？
可交換的含義爲：先刪除 x 再刪除 y 所得結果與先刪除 y 再刪除 x 所得結果相同。
如果是，說明爲什麼？否則給出反例。
\stopEXERCISE

\startANSWER
反例：在如下二叉搜索樹中刪除元素 1 和 2。
\externalfigure[output/e12_3_4-1]
\stopANSWER

%e12.3-5
\startEXERCISE
假設每個節點 x 不是用屬性 \m{x.p} 來指向其父節點，而是用屬性 \m{x.succ} 指向其後繼節點，
給出用這種方法表示的二叉搜索樹 T 上的 \ALGO{SEARCH}、 \ALGO{INSERT} 和 \ALGO{DELETE} 操作的僞碼。
這些過程應在 \m{O(h)} 時間內完成，其中 h 是 T 的高度。
（\hint 你需要實現一個子過程來返回父節點）
\stopEXERCISE

\startANSWER
\goto{CSDN}[url(http://blog.csdn.net/hrzr79011/article/details/41889431)]

\ALGO{SEARCH} 不用變。

\CLRSH{TREE-INSERT(T,z)}
\startCLRS
y = NIL
x = T.root
while x != NIL
	y = x
	if z.key < x.key
		x = x.left
	else
		x = x.right
if y == NIL
	T.root = z	// T was empty
	z.succ = NIL
elseif z.key < y.key
	y.left = z
	z.succ = y
else
	y.right = z
	z.succ = y.succ
	y.succ = z
\stopCLRS

\CLRSH{TREE-PARENT(T, z)}
\startCLRS
x = z
while x.right != NIL
	x = x.right
x = x.succ
if x == NIL
	y = T.root
	while y.right != z
		y = y.right
	return y
else
	if x.left == z
		return x	// x is the left child of its' parent
	else
		y = x.left
		while y.right != z
			y = y.right
		return y
\stopCLRS

\CLRSH{TREE-PREDECESSOR(T, z)}
\startCLRS
if z.left != NIL
	y = z.left
	while y.right != NIL
		y = y.right
	return y
else
	p = TREE-PARENT(T, z)
	if p.left == z
		return NIL
	esle
		return p
\stopCLRS

\CLRSH{TREE-TRANSPLANT(T, u, v)}
\startCLRS
y = TREE-PARENT(T, u)
if y == NIL
	T.root = v
else if u == y.left
	y.left = v
else
	y.right = v
\stopCLRS

\CLRSH{TREE-DELETE(T, z)}
\startCLRS
if z.left == NIL
	TREE-TRANSPLANT(T, z, z.right)
else if z.right == NIL
	TREE-TRANSPLANT(T, z, z.left)
else
	y = TREE-MINIMUM(z.right)
	if y != z.right
		TREE-TRANSPLANT(T, y, y.right)
		y.right = z.right
	TREE-TRANSPLANT(T, z, y)
	y.left = z.left
pd = TREE-PREDECESSOR(T, z)
if pd != NIL
	pd.succ = z.succ
\stopCLRS
\stopANSWER

%e12.3-6
\startEXERCISE
如果節點 z 在 \ALGO{TREE-DELETE} 中有兩個子節點，
我們可以選擇其前驅 y 而不是後繼。
如果這樣做，我們還需要對 \ALGO{TREE-DELETE} 做哪些修改？
有些人提出了一個公平策略，即賦予前驅和後繼相同的優先級，
從而得到了更好的實驗性能。
如何修改 \ALGO{TREE-DELETE} 來實現這樣的策略？
\stopEXERCISE

\startANSWER
\CLRSH{TREE-DELETE(T, z)}
\startCLRS
if z.left == NIL
	TRANSPLANT(T, z, z.right)
else if z.right == NIL
	TRANSPLANT(T, z, z.left)
else
	flag = RANDOM()		// 0 or 1
	if flag == 0
		y = TREE-MAXIMUM(z.left)
		if y ！= z.left
			TRANSPLANT(T, y, y.left)
			y.left = z.left
			y.left.p = y
		TRANSPLANT(T, z, y)
		y.right = z.right
		y.right.p = y
	else
		y = TREE-MINIMUM(z.right)
		if y != z.right
			TRANSPLANT(T, y, y.right)
			y.right = z.right
			y.right.p = y
		TRANSPLANT(T, z, y)
		y.left = z.left
		y.left.p = y
\stopCLRS
\stopANSWER

\startsection[
  title={Randomly built binary search trees},
]

%e12.4-1
\startEXERCISE
證明等式 12.3。附等式 12.3：
\startformula
\sum_{i=0}^{n-1}\binom{i+3}{3} = \binom{n+3}{4}
\stopformula
\stopEXERCISE

\startANSWER
\startformula\startmathalignment
\NC \sum_{i=0}^{n-1}\binom{i+3}{3}
    \NC = \binom{4}{4} + \sum_{i=1}^{n-1}\binom{i+3}{3} \NR
\NC \NC = \binom{4}{4} + \binom{4}{3} + \sum_{i=2}^{n-1}\binom{i+3}{3} \NR
\NC \NC = \binom{5}{4} + \sum_{i=2}^{n-1}\binom{i+3}{3} \NR
\NC \NC = \binom{6}{4} + \sum_{i=3}^{n-1}\binom{i+3}{3} \NR
\NC \NC = \ldots \NR
\NC \NC = \binom{n+3}{4} \NR
\stopmathalignment\stopformula
\stopANSWER

%e12.4-2
\startEXERCISE
請描述這樣一棵有 n 個節點的二叉搜索樹，
其樹中節點的平均深度爲 \m{\Theta(\lg{n})}，
但這棵樹的高度是 \m{\omega(\lg{n})}。
一棵有 n 個節點的二叉搜索樹中節點的平均深度爲 \m{\Theta(\lg{n})}，
給出這棵樹高度的一個漸進上界。
\stopEXERCISE

\startANSWER
假設這樣構建二叉樹：給定 n 個節點，取 \m{f(n)} 個節點放在一邊。
然後構建一個二叉樹，使得根結點的左子樹是一個完全二叉樹，
有 \m{n-f(n)-1} 個節點，而右子樹則是 \m{f(n)} 個節點構成的鏈。
後面再處理那 \m{f(n)} 個節點。

根的左子樹平均深度是多少？由於我們只想得到一個漸進界，
讓我們選取一個 n，使得 \m{n-f(n)-1} 正好比 2 的冪小 1，即 \m{2^k-1}。
這種情況下，這部分的總高度爲 \m{1\times 2+2\times 3+4\times 4+8\times 5+\ldots+2^{k-1}\times k}。
總數約爲 \m{2^k\times k}，即 \m{(n-f(n))\log{(n-f(n))}}，只跟 k 有關。
而對於另外一部分，總高度爲 \m{f(n)^2}。
即整棵樹的平均高度爲 \m{((n-f(n))\log{(n-f(n))} + f(n)^2)/n}。
而樹的高度爲 \m{f(n)}，所以我們要使得 \m{f(n)} 最大化，並保持平均高度 \m{O(\log{n})}。

我們需要找到 \m{f(n)}，使得：
\startigBase[n]
\item \m{n-f(n)=\Theta(n)}，否則分子中的 \m{\log} 項會消失，從而使高度不再是指數級的；
\item \m{f(n)^2/n=O(\log{n})}，否則分子中的第二項就太大了。
\stopigBase

如果選擇 \m{f(n)=\Theta(\sqrt(n\log{n}))}，則這兩項都得到了最大滿足。
即樹的高度爲 \m{\Theta(\sqrt(n\log{n}))}，而平均高度爲 \m{\Theta(\log{n})}。

參見 \goto{stackoverflow}[url(http://stackoverflow.com/questions/9257464/give-an-asymptotic-upper-bound-on-the-height-of-an-n-node-binary-search-tree-in)]。
\stopANSWER

%e12.4-3
\startEXERCISE
說明含有 n 個關鍵字的隨機選擇二叉搜索樹的概念，
這裏每一棵 n 個節點的二叉搜索樹都是等可能的被選擇，
不同於本節中給出的隨機構建二叉搜索樹的概念。
（\hint 當 \m{n=3} 時，列出所有的可能。）
\stopEXERCISE

\startANSWER
排列 \m{213} 和 \m{231} 所構建的二叉樹相同。
\stopANSWER

%e12.4-4
\startEXERCISE
證明：函數 \m{f(x)=2^x} 是凸的。
\stopEXERCISE

\startANSWER
\m{f''(x) > 0}
\stopANSWER

%e12.4-5
\startEXERCISE\DIFFICULT
考慮在 n 個互不相同的輸入數據的序列上執行 \ALGO{RANDOMIZED-QUICKSORT} 操作。
證明：對於任何常數 \m{k>0}， \m{n!} 種輸入排列除了其中的 \m{O(1/n^k)} 種之外，
運行時間都爲 \m{O(n\lg{n})}。
\stopEXERCISE

\startANSWER
\ALGO{QUICKSOR} 生成二叉搜索樹，每層總時間開銷爲 \m{O(n)}。
總時間爲 \m{O(n h_n)}，其中 \m{h_n} 爲樹的高度，是一個隨機變量。
 \m{E(h_n) = c\lg{n}}。
 \m{\omega(n\lg{n})} 時間概率爲：
\startformula
 \Pr\left{\lim_{n\rightarrow\infty}\frac{h_{\pi(n)}}{c\lg{n}} = \infty\right}
\stopformula

要證明：
\startformula
\forall\rho
  \lim_{n\rightarrow\infty}n^\rho
  \Pr\left{\lim_{n\rightarrow\infty}\frac{h_{\pi(n)}}{c\lg{n}} < \infty\right}
\stopformula
只需要證明：
\startformula
 \Pr\left{\lim_{n\rightarrow\infty}\frac{h_{\pi(n)}}{c\lg{n}} = 0\right}
\stopformula

其中 \m{h_{\pi(n)}} 表示 \m{1\ldots n} 的排列 \m{\pi(n)} 生成的二叉搜索樹的高度。
事件可等價表示爲：
\startformula\startmathalignment
\NC  \NC \lim_{n\rightarrow\infty}\frac{h_{\pi(n)}}{c\lg{n}} = \infty \NR
\NC \Leftrightarrow \NC \forall K \exists N(K), n > N(K), \frac{h_{\pi(n)}}{c\lg{n}} > K \NR
\NC \Leftrightarrow \NC \bigcap_{K}\left{\frac{h_{\pi(n)}}{c\lg{n}} > K | n>N(K) \right} \NR
\stopmathalignment\stopformula

由 Markov 不等式可得：
\startformula
\Pr\left{ \frac{h_{\pi(n)}}{c\lg{n}} > K \right} < \frac{1}{K}
\stopformula

\startformula
\Pr\left{ \bigcap_{K}\left{\frac{h_{\pi(n)}}{c\lg{n}} > K | n>N(K) \right} \right} < \frac{1}{K} \forall K=0
\stopformula

\stopANSWER

\stopsection

\startsubject[
  title={Problems},
]

%p12-1
\startPROBLEM
（Binary search trees with equal keys）
相同的關鍵字給二叉搜索樹的實現帶來一個難題。
\startigBase[a]
\startitem
當用 \ALGO{TREE-INSERT} 將 n 個其中帶有相同關鍵字的數據插入到一棵初始爲空的二叉搜索樹中時，
其漸進性能是多少？
\stopitem

\startANSWER
最壞情況下會形成一個只有右子樹的鏈，漸進性能爲 \m{O(n)}。
\stopANSWER

我們建議通過以下方式改進 \ALGO{TREE-INSERT}：
在第 5 行前比較 \m{z.key == x.key}，在第 11 行前比較 \m{z.key == y.key}。
如果比較結果是相等，我們根據以下策略之一來實現。
對於每種策略，找到上一項的答案。
（對於第 5 行，策略是比較 z 和 x，而對於第 11 行，是比較 z 和 y）

\startitem
在節點 x 中維護一個布爾標志，並根據 \m{x.b} 的值將 x 設置成 \m{x.left} 或者 \m{x.right}，
這樣當插入的關鍵字與 x 相同時， \m{x.b} 的值就會在 FALSE 和 TRUE 間來回切換。
\stopitem

\startANSWER
所構造的是平衡二叉樹，時間爲 \m{O(\lg{n})}。
\stopANSWER

\startitem
在 x 中維護一個鏈表，存儲關鍵字與 x 相同的節點，將 z 插入此鏈表。
\stopitem

\startitem
隨機地將 x 設置成 \m{x.left} 或 \m{x.right}。
（給出最壞情況的性能，並導出期望運行時間）
\stopitem
\stopigBase
\stopPROBLEM

%p12-2
\startPROBLEM
（Radix trees）
給定兩個字串 \m{a=a_0 a_1 \ldots a_p} 和 \m{b=b_0 b_1 \ldots b_q}，
這裏每個 \m{a_i} 和 \m{b_j} 是以字符集的某種次序出現的，
如果下面兩種規則之一成立，
就稱字串 \m{a} {\EMP 按字典序小於}（lexicographically less than）字串 \m{b}：
\startigBase[n]
\startitem
存在一個整數 j，其中 \m{0\le j \le \min(p,q)}，
使得對所有的 \m{i=0,1,\ldots,j-1}， \m{a_i=b_i} 都成立，且 \m{a_j < b_j}。
\stopitem

\startitem
\m{p<q}，且對所有的 \m{i=0,1,\ldots,p}，都有 \m{a_i=b_i}。
\stopitem
\stopigBase

例如，如果 a 和 b 是位串，那麼 \m{10 100 < 10 110} （由規則 1，取 \m{j=3}），
 \m{10 100 < 101 000} （由規則 2）。
這種次序類似於英語字典中的排序。

{\EMP 基數樹}（radix tree）數據結構如下圖所示，
這個樹存儲了位串 \m{1011}、 \m{10}、 \m{011}、 \m{100} 和 \m{0}。
當對一個關鍵字 \m{a=a_0 a_1 \ldots a_p} 進行查找時，
在深度爲 i 的一個節點處，如果 \m{a_i=0}，則走左側；
如果 \m{a_i=1}，則走右側。
設 S 是一個不同位串組成的集和，各個串長度值和爲 n。
說明如何使用一顆基數樹在 \m{\Theta(n)} 時間內按字典序對 S 進行排序。
對於下圖所示的例子，排序輸出的應該是序列 \m{0}、 \m{011}、 \m{10}、 \m{100}、 \m{1011}。

\externalfigure[output/p12_2-1]
\stopPROBLEM

%p12-3
\startPROBLEM
（Average node depth in a randomly built binary search tree）
現有一棵隨機構建的二叉搜索樹，証明其節點平均深度為 \m{O(\lg{n})}。
雖然此結果比定理 12.4 要弱，但是我們要使用的方法將會告訴你，構建二叉搜索樹的過程，
與\refsection{rand_quicksort} 中執行 \ALGO{RANDOMIZED-QUICKSORT} 驚人的相似。

給定二叉搜索樹 \m{T}，其中任一節點 \m{x} 的深度為 \m{d(x, T)}，則所有節點深度的和為 \m{P(T)}，
稱為 \m{T} 的 {\EMP 路徑總長度（total path length）}。

\startigBase[a]

\startitem
証明 \m{T} 中節點的平均深度為：
\startformula
\frac{1}{n}\sum_{x\in T} d(x,T) = \frac{1}{n} P(T)
\stopformula
\stopitem

\startANSWER
根據定義 \m{P(T)=\sum_{x\in T}d(x,T)}，兩邊同除以 \m{n} 即可。
\stopANSWER

下面來証明 \m{P(T)} 的期望值為 \m{O(n\lg{n})}。
\startitem
令 \m{T} 的左右子樹分別為 \m{T_L} 和 \m{T_R}。
証明如果 \m{T} 有 \m{n} 個節點，則：
\startformula
P(T) = P(T_L) + P(T_R) + n - 1
\stopformula
\stopitem

\startANSWER
對於 \m{T_L} 中任一節點 \m{x}，有 \m{d(x, T) = d(x, T_L) + 1}。
則：
\startformula\startmathalignment
\NC P(T) \NC = \sum_{x\in T}d(x, T) \NR
\NC      \NC = \sum_{x\in T_L}d(x, T) + \sum_{x\in T_R}d(x, T) \NR
\NC      \NC = \sum_{x\in T_L}(d(x, T_L) + 1) + \sum_{x\in T_R}(d(x, T_R) + 1) \NR
\NC      \NC = \sum_{x\in T_L}d(x, T_L) + \sum_{x\in T_R}d(x, T_R) + (n - 1) \NR
\NC      \NC = P(T_L) + P(T_R) + n - 1 \NR
\stopmathalignment\stopformula
\stopANSWER

\startitem
有一棵隨機構建的二叉搜索樹，其中有 \m{n} 個節點，令其平均路徑長度為 \m{P(n)}。証明：
\startformula
P(n) = \frac{1}{n}\sum_{i=0}^{n-1}(P(i) + P(n-i-1) + n - 1)
\stopformula
\stopitem

\startANSWER
既然是隨機構建，則左右子樹的節點數目也是隨機的，共有 \m{n} 種情況，
即左右子樹的節點數是 \m{(0,n-1)}、 \m{(1,n-2)}、 \m{\cdots}、{(n-1,0)} 中的任一種。
根據上一項的結果即得。
\stopANSWER

\startitem
如何將 \m{P(n)} 改寫為：
\startformula
P(n) = \frac{2}{n}\sum_{k=1}^{n-1}P(k)+\Theta(n)
\stopformula
\stopitem

\startANSWER
展開上一項的結果，並去除 \m{P(0)} 即可。（\m{P(0) = 0}）
\stopANSWER

\startitem
回顧一下\refproblem{alt_quicksort_analysis} 中對隨機快速排序的分析，試證明： \m{P(n)=O(n\lg{n})}。
\stopitem

\startANSWER
請參考\refproblem{alt_quicksort_analysis} 的解答。
\stopANSWER

快速排序中每次遞迴調用，我們都會隨機選擇一個主元來分割要排序的元素。
二叉搜索樹中，每個節點都可以看作是分割其子樹的主元。
\startitem
試說明快速排序時所進行的比較與往二叉搜索樹中插入元素所進行的比較相同。
（比較的次序可能不同，但比較所涉及的元素必須相同）
\stopitem

\startANSWER
將快速排序時所選的主元作爲子樹的跟節點。
主元將子數列分成了兩部分，這兩部分就是主元的左右兩棵子樹。
\stopANSWER

\stopigBase
\stopPROBLEM % 12-3

% p12-4
\startPROBLEM
（Number of different binary trees）
令 \m{b_n} 表示由 \m{n} 個節點所構成的二叉樹的數目。
本題會給出 \m{b_n} 的公式以及漸進估計。
\startigBase[a]
\startitem
證明 \m{b_0=1}，且當 \m{n\ge 1} 時，
\startformula
b_n = \sum_{k=0}^{n-1}b_k b_{n-1-k}
\stopformula
\stopitem

\startANSWER
略。
\stopANSWER

\startitem
參考\refproblem{generating_function} 中生成函數的定義，令 \m{B(x)} 爲生成函數：
\startformula
B(x) = \sum_{n=0}^{\infty}b_n x^n
\stopformula
試證明 \m{B(x) = x B(x)^2 + 1}，及：
\startformula
B(x) = \frac{1}{2x}(1 - \sqrt{1-4x})
\stopformula
\stopitem

\startANSWER
略。
\stopANSWER
\stopigBase

\m{f(x)} 在 \m{x=a} 處{\EMP 泰勒展開式（Taylor expansion）}爲：
\startformula
f(x) = \sum_{k=0}^{\infty}\frac{f^{(k)}(a)}{k!}(x-a)^k
\stopformula
其中 \m{f^{(k)}(x)} 是 \m{f} 對 \m{x} 的 \m{k} 階導數。

\startigBase[continue]
\startitem
用 \m{\sqrt{1-4x}} 在 \m{x=0} 處的泰勒展開式證明：
\startformula
b_n = \frac{1}{n+1}\binom{2n}{n}
\stopformula
（即第 \m{n} 個 {\EMP Catalan number}）如果不想用泰勒展開式，也可以使用二項展開式，
參見\refsection{geometric_binom}，
將其推廣到非整數的指數 \m{n} 上去，也就是對於所有實數 \m{n} 和任一整數 \m{k}，
當 \m{k\ge 0} 時，\m{\binom{n}{k}} 可以表示爲 \m{n(n-1)\cdots(n-k+1)/k!}，否則爲 0。
\stopitem

\startANSWER
令 \m{f(x) = \sqrt{1-4x}}，其泰勒展開式爲：
\startformula
\sqrt{1-4x} = 1 - \frac{2}{1!}x - \frac{4}{2!}x^2 - \frac{24}{3!}x^3 - \frac{240}{4!}x^4 - \cdots
\stopformula
因此：
\startformula\startmathalignment
\NC B(x) \NC = \frac{1}{2x}(1-\sqrt{1-4x}) \NR
\NC      \NC = \frac{2}{1!}x + \frac{4}{2!}x^2 + \frac{24}{3!}x^3 + \frac{240}{4!}x^4 + \cdots \NR
\NC      \NC = \frac{1}{1!} + \frac{2}{2!}x + \frac{12}{3!}x^2 + \frac{120}{4!}x^3 + \cdots \NR
\NC      \NC = \sum_{n=1}^{\infty}\frac{(2n-2)!}{n(n-1)!(n-1)!}x^{n-1} \NR
\NC      \NC = \sum_{n=0}^{\infty}\frac{1}{n+1}\binom{2n}{n}x^n \NR
\NC B(x) \NC = \sum_{n=0}^{\infty}b_n x^n \NR
\stopmathalignment\stopformula
所以：
\startformula
b_n = \frac{1}{n+1}\binom{2n}{n}
\stopformula
\stopANSWER

\startitem
證明： \m{b_n = \frac{4^n}{\sqrt{\pi}n^{3/2}}(1+O(1/n))}。
\stopitem

\startANSWER
由 Stirling‘s approximation：
\startformula
n! = \sqrt{2\pi n}\left(\frac{n}{e}\right)^n\left(1 + \Theta(\frac{1}{n})\right)
\stopformula
可得：
\startformula
b_n = \frac{1}{n+1}\binom{2n}{n} = \frac{4^n}{\sqrt{\pi}n^{3/2}}(1 + O(\frac{1}{n}))
\stopformula
\stopANSWER

\stopigBase
\stopPROBLEM

\stopsubject%Problems

\stopchapter
\stopcomponent

\startcomponent c_augmenting_data_structures

\startchapter[
  title={Augmenting Data Structures},
]

\startsection[
  title={Dynamic order statistics},
]

%e14.1-1
\startEXERCISE
對於圖 14-1 中的紅黑樹 T，說明執行 \ALGO{OS-SELECT(T.root, 10)} 的過程。
\stopEXERCISE
\startANSWER
略。
\stopANSWER

%e14.1-2
\startEXERCISE
對於圖 14-1 中的紅黑樹 T 和關鍵字 \m{x.key} 爲 35 的節點 x，說明執行 \ALGO{OS-RANK(T, x)} 的過程。
\stopEXERCISE
\startANSWER
略。
\stopANSWER

%e14.1-3
\startEXERCISE
寫出 \ALGO{OS-SELECT} 的非遞迴版本。
\stopEXERCISE
\startANSWER
\CLRSH{OS-SELECT(x, i)}
\startCLRS
root = x
idx = i
while root != NIL
	r = root.left.size + 1
	if idx == r
		return x
	elseif idx < r
		root = root.left
	else
		root = root.right
		idx = idx - r
\stopCLRS
\stopANSWER

%14.1-4
\startEXERCISE
寫出一個遞迴過程 \ALGO{OS-KEY-RANK(T, k)}，
以一棵順序統計樹 T 和一個關鍵字 k 作爲輸入，
要求返回 k 在由 T 表示的動態集合中的秩。
假設 T 的所有關鍵字都不相同。
\stopEXERCISE
\startANSWER
\CLRSH{OS-KEY-RANK(T, k)}
\startCLRS
if T == NIL
	return 0
if k == T.key
	if T.left == NIL
		return 1
	else
		return 1 + T.left.size
elseif k < T.key
	return OS-KEY-RANK(T.left, k)
else
	ret = OS-KEY-RANK(T.right, k)
	if T.left == NIL
		return ret + 1
	else
		return ret + T.left.size
\stopCLRS
\stopANSWER

%e14.1-5
\startEXERCISE
給定一個元素 x 和一個自然數 i，
其中 x 屬於一個含有 n 個元素的順序統計樹，
如何在 \m{O(\lg n)} 的時間內確定 x 在該樹線性序中的第 i 個後繼？
\stopEXERCISE
\startANSWER
先計算 x 的秩，記爲 r，然後在此樹中搜索秩爲 \m{r+i} 的節點。
\stopANSWER

%e14.1-6
\startEXERCISE
在 \ALGO{OS-SELECT} 或 \ALGO{OS-RANK} 中，
注意到無論什麼時候引用節點的 size 屬性都是爲了計算秩。
相應地，假設每個節點都存儲他在以自己爲根的子樹中的秩。
試說明在插入和刪除時，如何維護這個信息。
（注意，這兩種操作都可能引起旋轉）
\stopEXERCISE
\startANSWER
略。
\stopANSWER

%e14.1-7
\startEXERCISE
說明如何在 \m{O(n\lg n)} 時間內，
利用順序統計樹對大小爲 n 的數列中的逆序對（參見問題 2-4）進行計數。
\stopEXERCISE
\startANSWER
\TODO{}
\stopANSWER

%e14.1-8
\startEXERCISE
現有一個圓上的 n 條弦，每條弦都由其端點來定義。
請給出一個能在 \m{O(n\lg n)} 時間內確定圓內相交弦對數的算法。
（例如，如果 n 條弦都爲直徑，他們相交於圓心，
則正確的答案爲 \m{\binom{n}{2}}）
假設任意兩條弦都不會共享端點。
\stopEXERCISE
\startANSWER
\hint 逆序對。
\stopANSWER

\stopsection

\startsection[
  title={How to augment a data structure},
]

%14.2-1
\startEXERCISE[exercise:add_pointer_for_node]
通過爲節點增加指針的方式，試說明如何在擴張的順序統計樹上，
動態集合的查詢操作 \ALGO{MINIMUM}、 \ALGO{MAXIMUM}、 \ALGO{SUCCESSOR} 和 \ALGO{PREDECESSOR} 都能在
最壞時間 \m{O(1)} 內完成。
順序統計樹上的其他操作漸進性能不應受影響。
\stopEXERCISE
\startANSWER
在每個節點中加入兩個指針數據項，分別指向左子樹中最小的元素和右子樹中最大的元素。
\startformula\startmathalignment
\NC MINIMUM(x) \NC = x.min\NR
\NC MAXIMUM(x) \NC = x.max\NR
\NC SUCCESSOR(x) \NC = x.right.min\NR
\NC PREDECESSOR(x) \NC = x.left.max\NR
\stopmathalignment\stopformula
\stopANSWER

%e14.2-2
\startEXERCISE
能否在不影響紅黑樹任何操作漸進性能的前提下，
將節點的黑高作爲樹中節點的一個屬性來維護？
說明如何做，如果不能請說明理由。
如何維護節點的深度？
\stopEXERCISE
\startANSWER
可以，在節點中添加屬性來記錄黑高。
每個節點的黑高可以根據自身顏色和兩個子節點的黑高來確定。
根據定理 14.1，插入、刪除仍然是 \m{O(\lg n)}。

深度則不行，因爲節點的深度由其父節點的深度決定。
當一個節點的深度發生變化後，最壞情況下需要的時間可能要比 \m{O(n\lg n)} 多。
\stopANSWER

%e14.2-3
\startEXERCISE
設 \m{\otimes} 爲一個滿足結合律的二元運算符，
 \m{a} 爲紅黑樹中每個節點上的一個要維護的屬性。
假設在每個節點 \m{x} 上增加一個屬性 \m{f}，
使得 \m{x.f=x_1\cdot a \otimes x_2\cdot a \otimes \cdots \otimes x_m\cdot a}，
其中 \m{x_1,x_2,\cdots,x_m} 是以 \m{x} 爲根的子樹中按中序次序排列的所有節點。
說明在一次旋轉後，如何在 \m{O(1)} 時間內更新屬性 \m{f}。
對你的擴張稍作修改，使得他能夠應用到順序統計樹的屬性 \m{size} 中。
\stopEXERCISE
\startANSWER
根據結合律可知： \m{x.f = x.left.f \otimes x \cdot a \otimes x.right.f}。

考慮下面的左旋操作：

\startcombination[2*1]
{\externalfigure[output/e14_2_3-1]}{a}
{\externalfigure[output/e14_2_3-2]}{b}
\stopcombination

可得：
\startformula\startmathalignment
\NC x'.f \NC = \alpha.f \otimes x \cdot a \otimes \beta.f \NR
\NC y'.f \NC = x.f \NR
\stopmathalignment\stopformula
\stopANSWER

%e14.2-4
\startEXERCISE
希望設計一個操作 \ALGO{RB-ENUMERATE(x, a, b)}，來擴張紅黑樹。
該操作輸出所有的關鍵字 \m{k}，
使得在以 \m{x} 爲根的紅黑樹中有 \m{a\le k \le b}。
描述如何在 \m{\Theta(m+\lg n)} 時間內實現 \ALGO{RB-ENUMERATE}，
其中 \m{m} 爲輸出的關鍵字數目，
 \m{n} 爲樹中的內部節點數。
（\hint 不需要給紅黑樹增加新屬性）
\stopEXERCISE
\startANSWER
先調用 \ALGO{TREE-SEARCH(x, a)}，對其稍作修改，使其返回大於等於 a 的最小元素，
如果沒有就返回空。此步需要時間 \m{O(\lg n)}。
然後不停調用 \ALGO{TREE-SUCCESSOR(x)}，直到遇到比 b 大的節點。共需 m 次。
根據\refexercise{cont_successor}，這 m 次調用需要時間爲 \m{O(m+h)}。
因此總時間爲 \m{\Theta(m + \lg n)}。
我們也可以根據\refexercise{add_pointer_for_node} 使用指向前驅、後繼節點的指針，但總的時間還是 \m{O(m+\lg n)}。
\stopANSWER

\stopsection

\startsection[
  title={Interval trees},
]

%e14.3-1
\startEXERCISE
寫出用於左旋區間樹的 \ALGO{LEFT-ROTATE} 的僞碼，使其可以在 \m{O(1)} 時間內更新 \m{\max} 屬性。
\stopEXERCISE
\startANSWER
\TODO{略。}
\stopANSWER

%e14.3-2
\startEXERCISE
改寫 \ALGO{INTERVAL-SEARCH}，使其在所有區間均爲開區間的情況下也能正確工作。
\stopEXERCISE
\startANSWER
\CLRSH{INTERVAL-SEARCH(T, i)}
\startCLRS
x = T.root
while x != T.nil and i does not overlap x.int
	if x.left != T.nil and x.left.max > i.low
		x = x.left
	else x = x.right
return x
\stopCLRS
\stopANSWER

%e14.3-3
\startEXERCISE
請給出一個有效算法，對一個給定區間 i，返回一個與 i 重疊，且具有最小左端點的區間；
如果不存在在這樣的區間，則返回 T.nil。
\stopEXERCISE
\startANSWER
\CLRSH{MIN_INTERVAL_SEARCH(x, i)}
\startCLRS
if x == NIL
	return NIL
if x.left != NIL and x.left.max >= i.low
	ret = MIN_INTERVAL_SEARCH(x.left, i)
	if ret != NIL
		return ret
if x.int overlap i
	return x
return MIN_INTERVAL_SEARCH(x.right, i)
\stopCLRS
\stopANSWER

%e14.3-4
\startEXERCISE
給定一棵區間樹 T 和一個區間 i，
請描述如何在 \m{O(\min(n, k\lg n))} 時間內列出 T 中所有與 i 重疊的區間，
其中 k 爲輸出的區間數。
（\hint 一種簡單的方法是做若干次查詢，並且在這些查詢操作中修改樹，
另一種略爲複雜點的方法是不對樹進行修改。）
\stopEXERCISE
\startANSWER
\CLRSH{INTERVAL-OVERLAP-LIST(T, x, i)}
\startCLRS
if x.int overlap i
	print x
if x.left != T.nil and x.left.max >= i.low
	INTERVAL-OVERLAP-LIST(T, x.left, i)
if x.right != T.nil and x.low <= i.high && x.right.max >= i.low
	INTERVAL-OVERLAP-LIST(T, x.right, i)
\stopCLRS
\stopANSWER

%e14.3-5
\startEXERCISE
對區間樹 T 和一個區間 i，
請修改有關區間樹的過程來支持新的操作 \ALGO{INTERVAL-SEARCH-EXACTLY(T, i)}，
他返回一個指向 T 中節點 x 的指針，使得 \m{x.int.low = i.low} 且 \m{x.int.high = i.high}；
或者，如果 T 不包含這樣的區間時返回 T.nil。
所有的操作（包括 \ALGO{INTERVAL-SEARCH-EXACTLY}）對於包含 n 個節點的區間樹的運行時間都應爲 \m{O(\lg n)}。
\stopEXERCISE
\startANSWER
先調用 \ALGO{TREE-SEARCH} 找到 x，滿足 \m{x.int.low = i.low}，
然後檢查 \m{x.int.hight = i.high} 是否成立，成立則返回 x，否則返回 T.nil。
顯然所需時間爲 \m{O(h)} 即 \m{O(\lg n)}。
\stopANSWER

%e14.3-6
\startEXERCISE
說明如何來維護一個支持操作 \ALGO{MIN-GAP} 的一些數的動態集 Q，
使得該操作能給出 Q 中兩個最接近的數之間的差值。
例如， \m{Q=\{1,5,9,15,18,22\}}，則 \ALGO{MIN-GAP} 返回 \m{18-15=3}，
因爲 15 和 18 是 Q 中兩個最接近的數。
要使得操作 \ALGO{INSERT}、 \ALGO{DELETE}、 \ALGO{SEARCH} 和 \ALGO{MIN-GAP} 儘可能高效，
並分析他們的運行時間。
\stopEXERCISE
\startANSWER
給紅黑樹節點增加屬性： min-gap，min，max。葉子節點的 min-gap 爲 \m{\infty}。
這三個屬性均可由節點自身和其左右孩子節點的信息算出來。
根據定理 4.1，不會影響插入、刪除等操作的運行時間。

\ALGO{MIN-GAP} 的運行時間爲 \m{O(1)}。
\stopANSWER

%e14.3-7
\startEXERCISE\DIFFICULT
VLSI 數據庫通常將一塊集成電路表示成一組矩形，
假設每個矩形的邊都平行於 x 軸或者 y 軸，
這樣可以用矩形的最小、最大 x 軸 y 軸座標來表示一個矩形。
請給出一個時間爲 \m{O(n\lg n)} 的算法，
來確定 n 個這種表示的矩形集合中是否存在兩個重疊的矩形。
你的算法不一定要輸出所有重疊的矩形，
但對於一個矩形完全覆蓋另一個的情況要給出正確的判斷（邊界線不一定相交）。
（\hint 移動一條“掃描”線，穿過所有的矩形。）
\stopEXERCISE
\startANSWER
從上至下移動掃描線。每次遇到一個矩形，假定是其最小的 y 座標，
我們需要檢查其 x 座標區間是否與樹中的任何矩形重疊。
如果沒有找到，則將此矩形插入樹中（以 x 座標區間爲關鍵字）。

對於區間樹的操作（插入、刪除、檢查是否重疊），其運行時間爲 \m{O(\lg n)}。
實際上還需要 \m{O(n\lg n)} 時間將矩形按 y 座標排序（用於掃描）。
\stopANSWER

\stopsection

\startsubject[
  title={Problems},
]

%p14-1
\startPROBLEM
（Point of maximum overlap）
假設我們希望記錄一個區間集合的{\EMP 最大重疊點}，即覆蓋此點的區間數目最多。
\startigBase[a]
\startitem
證明：總有一個最大重疊點是某個區間的端點。
\stopitem
\startANSWER
\TODO{略。}
\stopANSWER

\startitem
設計一個數據結構，使其能有效地支持 \ALGO{INTERVAL-INSERT}、 \ALGO{INTERVAL-DELETE}，
以及返回最大重疊點的 \ALGO{FIND-POM} 操作。（\hint 使紅黑樹記錄所有的端點。
左端點關聯 +1，右端點關聯 -1，並且給樹中的每個節點擴張一個額外信息來維護最大重疊點。）
\stopitem
\startANSWER
令 \m{e_1,e_2,\cdots,e_n} 爲已排序的所有端點，滿足 \m{e_1\le e_2 \le \cdots \le e_n}。
從左至右掃描，若爲左端點，則 p 的值爲 +1，若爲右端點，則 p 的值爲 -1。
令 \m{s(i,j)=p_i + p_{i+1} + \cdots + p_j}，其中 \m{1\le i\le j\le n}。
目標是要找到使 \m{s(1,j)} 最大的 j。

每個節點記錄三個值： v，子樹所有節點的 p 之和； m，子樹上 \m{s(i,j)} 的最大值；
 j，即 m 所對應的 j。
定義 NIl 的 m 和 v 均爲 0。
用自底向上的方式計算這些值。
\startformula
x.m = \startcases
\NC x.left.m	\NC (x.j = x.left.j) \NR
\NC x.left.m + x.v \NC (x.j = x) \NR
\NC x.left.m + x.v + x.right.m \NC (x.j = x.right.j) \NR
\stopcases
\stopformula

\ALGO{FIND-POM} 直接返回 T.root.j 即可。
\stopANSWER
\stopigBase
\stopPROBLEM

%p14-2
\startPROBLEM
（Josephus permutation）
此問題定義如下：假設有 n 個人，編號分別爲 \m{1,2,3,\ldots,n}，按順序圍成一圈。
給定一個正整數 m 滿足 \m{m\le n}。
從某個指定的人開始報數，數到 m 的那個人出列；下一個人又從 1 開始報數，
以此類推，直到所有人全部出列。
按出列的次序將所有人的編號進行排列，稱其爲 (n,m)-Josephus 排列，
例如， (7,3)-Josephus 排列爲 \m{\langle 3,6,2,7,5,1,4\rangle}。
\startigBase[a]
%a
\startitem
假設 m 是常數，描述一個 \m{O(n)} 時間的算法，
使得對於給定的 n，能夠輸出 (n,m)-Josephus 排列。
\stopitem

\startANSWER
用循環鏈表即可，總時間爲 \m{O(mn)}，由於 m 是常數，有 \m{O(mn)=O(n)}。
\stopANSWER

%b
\startitem
假設 m 不是常數，描述一個 \m{O(n\lg n)} 時間的算法，
使得對於給定的 n，能夠輸出 (n,m)-Josephus 排列。
\stopitem

\startANSWER
使用順序統計樹。順序統計樹相關操作的時間爲 \m{O(\lg n)}，總時間爲 \m{O(n\lg n)}。

\CLRSH{JOSEPHUS(n,m)}
\startCLRS
T = NIL
for j = 1 to n
	create a node x with key[x] = j
	OS-INSERT(T, x)
j = 1
for k = n downto 1
	j = (j + m - 2) mod k + 1
	x = OS-SELECT(root[T], j)
	print key[x]
	OS-DELETE(T, x)
\stopCLRS
\stopANSWER
\stopigBase
\stopPROBLEM

\stopsubject%Problems

\stopchapter
\stopcomponent

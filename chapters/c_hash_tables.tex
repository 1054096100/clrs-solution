\startcomponent c_hash_tables

\startchapter[
  title={Hash Tables},
  reference=chapter:hash_tables,
]

\startsection[
  title={Direct-address tables},
]

%e11.1-1
\startEXERCISE
假設一動態集合 S 用一個長度爲 m 的直接尋址表 T 來表示。
請給出一個查找 S 中最大元素的過程。
你所給出的過程在最壞情況下的運行時間如何？
\stopEXERCISE

\startANSWER
我們從表的底部（最大元素）查起，並向後掃描整張表，直到找到非空的槽。
最壞情況下運行時間爲 \m{\Theta(m)}，此時最大元素在表的起始位置，或者動態集合爲空。
\stopANSWER

%e11.1-2
\startEXERCISE
{\EMP 位向量}（{\EMP bit vector}）是一個僅包含 0 和 1 的數列。
長度爲 m 的位向量所佔空間比 m 個指針要少的多。
試說明如何用位向量表示動態集合，此集合中的元素互不相同，且沒有衛星數據。
字典操作的運行時間應爲 \m{O(1)}。
\stopEXERCISE

\startANSWER
動態集合的元素必須是整數。

對於位向量中的每一位，如果是 1 則表示集合中有此元素，如果是 0 則表示集合中沒有此元素。
在沒有衛星數據的情況下這足夠了。
修改或查找操作需要用到位操作，如 \&、 \|。

字典操作都是直接獲得結果。只有向量大小稍微有點復雜。
如果動態集合中有 1000 個元素，則位向量中至少要有 1000 位才行。
\stopANSWER

%e11.1-3
\startEXERCISE
如何實現直接尋址表，才能使得元素的關鍵字可以重復且可以有衛星數據？
三個字典操作（\ALGO{INSERT}、 \ALGO{DELETE} 和 \ALGO{SEARCH}）的運行時間均爲 \m{O(1)}。
（不要忘記 \ALGO{DELETE} 的參數是要刪除對象的指針而不是關鍵字）
\stopEXERCISE

\startANSWER
用雙向鏈表。

\startigBase[a]
\item \ALGO{INSERT} 插入鏈表需要常數時間；
\item \ALGO{DELETE} 由鏈表移除元素也需常數時間；
\item \ALGO{SEARCH} 返回鏈表中的第一個元素，也是常數時間。
\stopigBase
\stopANSWER

%e11.1-4
\startEXERCISE\DIFFICULT
我們想在一個{\EMP 非常大}的數列上用直接尋址來實現一個字典。
一開始，數列中可能包含一些無用信息，並且由於他非常大，初始化整個數列也不切實際。
請給出你的方案。
所存儲的每個對象所佔空間爲 \m{O(1)}；
且 \ALGO{SEARCH}、 \ALGO{INSERT} 和 \ALGO{DELETE} 所需時間也是 \m{O(1)}。
（\hint 用一個附加數列，將其視爲棧，其大小就是字典中實際存儲的關鍵字的數目，
用他來確定數列中的某一項是否有效。）
\stopEXERCISE

\startANSWER
只需將大數列中的元素和棧中的元素建立關聯，如：
棧中元素存儲數列元素的地址，而數列元素存儲棧上元素的索引。
 \ALGO{SEARCH} 時需要檢查上述關聯是否成立，若成立則有效，否則無效。
 \ALGO{INSERT} 對棧執行 \ALGO{PUSH}；
 \ALGO{DELETE} 時則將棧當成普通數列，如果要刪除的不是棧頂元素，則將棧頂元素轉移到所刪除的元素處，
並同步更新大數列中的相應元素。
\stopANSWER

\stopsection

\startsection[
  title={Hash tables},
]
%e11.2-1
\startEXERCISE
假設用一個散列函數 h 將 n 個不同的關鍵字散列到一個長度爲 m 的數列 T 中。
假設採用的是簡單均勻散列，那麼期望的衝突數是多少？
更準確地，集合 \m{\{\{k,l\}: k\ne l, \text{且 }h(k)=h(l)\}} 基的期望值是多少？
\stopEXERCISE

\startANSWER
對於每對關鍵字 k 和 l，其中 \m{k\ne l}，
定義指示器隨機變量 \m{X_{kl}=I\{h(k)=h(l)\}}。
由於我們假設簡單均勻散列，
因此 \m{\Pr\{X_{kl}=1\} = \Pr\{h(k)=h(l)\} = 1/m}，
從而 \m{E[X_{kl}] = 1/m}。

現在定義指示器隨機變量 Y，用來表示衝突的總數，
因此 \m{Y=\sum_{k\ne l}X_{kl}}。衝突數的期望值爲：
\startformula\startmathalignment
\NC E[Y]
    \NC = E\left[ \sum_{k\ne l} X_{kl} \right] \NR
\NC \NC = \sum_{k\ne l} E\left[ X_{kl} \right] \NR
\NC \NC = \binom{n}{2}\frac{1}{m} \NR
\NC \NC = \frac{n(n-1)}{2}\times \frac{1}{m} \NR
\NC \NC = \frac{n(n-1)}{2m} \NR
\stopmathalignment\stopformula
\stopANSWER

%e11.2-2
\startEXERCISE
對於一個用鏈接法解決衝突的散列表，
說明將關鍵字 5、 28、 19、 15、 20、 33、 12、 17、 10 插入到該表中的過程。
設該表中有 9 個槽位，並設其散列函數爲 \m{h(k)=k \mod 9}。
\stopEXERCISE

\startANSWER
\externalfigure[output/e11_2_2-1]
\externalfigure[output/e11_2_2-2]
\externalfigure[output/e11_2_2-3]
\externalfigure[output/e11_2_2-4]
\externalfigure[output/e11_2_2-5]
\externalfigure[output/e11_2_2-6]
\externalfigure[output/e11_2_2-7]
\externalfigure[output/e11_2_2-8]
\externalfigure[output/e11_2_2-9]
\stopANSWER

%e11.2-3
\startEXERCISE
Marley 教授做了這樣一個假設，即如果將鏈模式改動一下，
使得每個鏈表都能保持已排好序的順序，
散列的性能就可以有較大的提高。
 Marley 教授的改動對成功查找、不成功查找、插入和刪除操作的運行時間有何影響？
\stopEXERCISE

\startANSWER
對於成功查找，平均情況下的運行時間沒什麼變化，還是 \m{\Theta(1+\alpha)}。
要檢查的元素數目比鏈表中小於目標的元素數目多一個。

不成功查找的平均時間也是 \m{\Theta(1+\alpha)}，但是比成功查找要少一半。
因爲鏈表是排好序的，目標元素按數序所在位置是隨機的，平均情況下要搜索鏈表元素的一半。

插入元素的平均時間爲 \m{\Theta(1+\alpha)}，相對於原來的 \m{\Theta(1)} 有所下降。
因爲鏈表需要保持有序。於不成功查找的過程類似。

刪除元素於成功查找類似，也是 \m{\Theta(1+\alpha)}。
\startformula
E[n_j] = \alpha = \frac{n}{2m}
\stopformula
\stopANSWER

%e11.2-4
\startEXERCISE
通過將所有空閒槽位組成一個空閒鏈表，如何爲散列表中的元素分配、釋放存儲空間？
假設一個槽位中可以存儲一個標記，外加一個元素和一個指針，或者兩個指針。
所有字典、空閒鏈表操作的期望時間應爲 \m{O(1)}。
空閒鏈表是否需要是雙向鏈表，或者說單向空閒鏈表是否足夠？
\stopEXERCISE

\startANSWER
用這個標記來指示槽位是否空閒。

空閒槽位處於空閒鏈表中，通過雙線鏈接將所有空閒槽位組成空閒鏈表。
空閒槽位中含有兩個指針。

而非空閒槽位中除了標記以外，還含有一個元素值和一個指針（可能是 NIL），這個指針只想散列到此槽位的下一個元素。
（當然，這個指針指向的其實是另一個槽位）

{\EMP 插入：}

如果新元素散列到空閒槽位上，則將此槽位從空閒鏈表中移除，將此元素的值填如，並將指針賦值爲 NIL。
爲了使其時間滿足 \m{O(1)}，鏈表需爲雙向。

而如果新元素散列到了一個已用的槽位 j 上，則檢查此槽位原有元素 x 是否應當散列到此槽位上。

如果是，則將新元素加入原由鏈表中即可。需要先分配一個空閒槽位（即取出空閒鏈表的頭部節點），填充數據，
並將此槽位加入槽位 j 中的鏈表。

否則，新分配一個槽位，用來在 j 所屬鏈表中替換 j。並將 j 作爲新鏈表的頭節點，填入新元素的值，並將指針賦值爲 NIL。
其中替換 j 時，需要從 j 所屬鏈表的頭部順序查找，才能找到 j 的前驅節點。

{\EMP 刪除：}

令要刪除的元素爲 x，其散列到槽位 j 上。

如果 x 是 j 中的元素，且 j 沒有後繼節點，則釋放 j 即可。

如果 x 是 j 中的元素，但 j 有後繼節點，則交換 j 與其後繼節點的所有內容，並釋放其後繼節點。

否則需要從 j 開始，在鏈表中搜索 x，找到後直接將其從鏈表中剔除，釋放即可。

{\EMP 查找：}

檢查關鍵字所散列到的槽位，如果此槽位的原有元素也是散列到此位置上，則在其鏈表中搜索（包括此槽位自身）；
否則查找直接失敗。

所有操作期望時間均爲 \m{O(1)}。
在鏈表中查找的期望時間爲 \m{O(1+\alpha)}，於鏈表的存儲位置無關，
所有元素都在表中則意味着 \m{\alpha\le 1}。
而如果空閒鏈表是單向的，就無法在 \m{O(1)} 時間內刪除任意槽位了。
\stopANSWER

%11.2-5
\startEXERCISE
將 n 個關鍵字存儲在大小爲 m 的散列表中。證明：
如果這些關鍵字源於全域 U，且 \m{|U| > nm}，
且 U 中有大小爲 n 的子集，其中關鍵字會散列到散列表中的同一槽位上，
那麼用鏈表解決衝突的情況下，最壞情況的查找時間爲 \m{\Theta(n)}。
\stopEXERCISE

\startANSWER
必有一個槽位的元素數量大於 n （鴿籠原理）。
\stopANSWER

%e11.2-6
\startEXERCISE
將 n 個關鍵字存儲在大小爲 m 的散列表中，以鏈表解決衝突，
我們直到每個鏈表的長度，並且知道最長鏈表的長度 L。
如何從所有關鍵字中均勻隨機選取其一，
並在期望時間 \m{O(L\cdot (1+1/\alpha))} 內完成。
\stopEXERCISE

\startANSWER
首先，隨機選擇一個槽位，令其所含元素數目爲 k。

然後，在 \m{1,2,\ldots,L} 中均勻隨機選擇一個，令其爲 p。

如果 \m{p\le k} 則返回 k 個元素中的第 p 個，否則重復執行以上步驟。

上述過程所返回每個元素的概率是相同的。
每個槽位所含元素數目的期望值爲 \m{n/m}。
採樣嘗試成功的概率爲 \m{(n/m)/L}。
採樣成功所要進行的嘗試次數期望值爲 \m{L \times m / n}。
加上在具體槽位上獲取最終元素的開銷 \m{O(L)}，
總的期望時間爲 \m{O(L\times (1+m/n))}。

請參考 \goto{stackexchange}[url(http://stackoverflow.com/questions/8629447/efficiently-picking-a-random-element-from-a-chained-hash-table)]。
\stopANSWER

\stopsection

\startsection[
  title={Hash functions},
]

%e11.3-1
\startEXERCISE
假設我們希望查找一個長度爲 n 的鏈表，
其中每一個元素都包含一個關鍵字 k 並具有散列值 \m{h(k)}。
每一個關鍵字都是長字串。
那麼在表中查找具有給定關鍵字的元素時，如何利用各元素的散列值？
\stopEXERCISE

\startANSWER
比較關鍵字散列值而不是比較關鍵字。
\stopANSWER

%e11.3-2
\startEXERCISE
假設將一個長度爲 r 的字串散列到 m 個槽位中，
並將其視爲一個以 128 爲基數的數，要求應用除法散列法。
我們可以很容易地把數 m 表示爲一個 32 位的機器字，
但是對於長度爲 r 的字串，由於他被當作以 128 爲基數的數來處理，
就要佔用若幹個機器字。
假設應用除法散列法來計算一個字串的散列值，
那麼如何才能在除了該字串本身所佔空間外，只利用常數個機器字？
\stopEXERCISE

\startANSWER
程序如下，其中 p、 b、 c 均小於 m， c 爲最終結果：
\startCLRS
p = 1
b = 128 mod m
c = 0
for i = 0 upto r - 1
	c = (c + a[i] * p mod m) mod m
	p = p * b mod m
return c
\stopCLRS
\stopANSWER

%e11.3-3
\startEXERCISE
考慮除法散列法的另一個版本，
其中 \m{h(k) = k \mod m}， \m{m=2^p-1}， \m{k} 爲按基數 \m{2^p} 表示的字串。
試證明：如果串 x 可由串 y 通過其自身的字符置換排列導出，
則 x 和 y 具有相同的散列值。
給出一個應用的例子，其中這一特性在散列函數中是不希望出現的。
\stopEXERCISE

\startANSWER
若 \m{m=2^p-1}，則 \m{k = \sum_{i=0}^{n}a_i(m+1)^i}。
因此 \m{k \mod m = \left(\sum_{i=0}^{n}a_i\right)\mod m}。

因此只要字串 x 和 y 可相互置換，則散列值必定相同。
\stopANSWER

%e11.3-4
\startEXERCISE
考慮一個大小爲 \m{m=1000} 的散列表和一個對應的散列函數 \m{h(k)=\left\lfloor m(kA\mod 1)\right\rfloor}，
其中 \m{A=(\sqrt{5}-1)/2}，
試計算關鍵字 61、 62、 63、 64 和 65 被映射到的位置。
\stopEXERCISE

\startANSWER
用 maxima 執行下列命令：
\startcodebox
for a:61 step 1 thru 65 do display(floor(mod((sqrt(5)-1)/2 * a, 1) * 1000));
\stopcodebox
結果爲：
\startcodebox
                               61 (sqrt(5) - 1)
                   floor(1000 (---------------- - 37)) = 700
                                      2

                   floor(1000 (31 (sqrt(5) - 1) - 38)) = 318

                               63 (sqrt(5) - 1)
                   floor(1000 (---------------- - 38)) = 936
                                      2

                   floor(1000 (32 (sqrt(5) - 1) - 39)) = 554

                               65 (sqrt(5) - 1)
                   floor(1000 (---------------- - 40)) = 172
                                      2
\stopcodebox
\stopANSWER

%e11.3-5
\startEXERCISE
定義一個從有限集合 U 到有限集合 B 上的散列函數族 \m{\cal{H}} 爲 {\EMP \m{\epsilon} 全域}的，
則必須滿足：
如果對 U 中任意兩個不同元素 k 和 l，都有：
\startformula
\Pr\{h(k)=h(l)\}\le\epsilon
\stopformula
其中概率是相對從函數族 \m{\cal{H}} 中隨機抽取的散列函數 \m{h} 而言的。
證明：一個 \m{\epsilon} 全域的散列函數族必定滿足：
\startformula
\epsilon \ge \frac{1}{|B|} - \frac{1}{|U|}
\stopformula
\stopEXERCISE

\startANSWER
令 \m{n=|U|}、 \m{m=|B|}。
對於 B 中的第 i 個槽位，其元素個數爲 \m{x_i}，
則 \m{C(x_i, 2) = x_i * (x_i - 1) / 2} 種衝突。
則衝突總數爲：
\startformula\startmathalignment
\NC \sum_{i=1}^{m}x_i (x_i - 1)/2
     =\NC \frac{1}{2}\sum_{i=1}^{m}x_i^2 - \frac{1}{2}\sum_{i=1}^{m}x_i \NR
\NC\ge\NC \frac{n^2}{2m} - \frac{n}{2}
\stopmathalignment\stopformula

因此：
\startformula\startmathalignment
\NC \Pr\{h(k)=h(l)\}
    \ge \NC \frac{\frac{n(n-m)}{2m}}{C(n,2)} \NR
\NC =   \NC \frac{n-m}{m(n-1)} \NR
\NC \ge \NC \frac{n-m}{mn} \NR
\NC =   \NC \frac{1}{m} - \frac{1}{n} \NR
\NC =   \NC \frac{1}{|B|} - \frac{1}{|U|} \NR
\stopmathalignment\stopformula
\stopANSWER

%e11.3-6
\startEXERCISE\DIFFICULT
設 U 爲 n 元組集合，其中所有元素均取自 \m{\integers_p}，且 \m{B=\integers_p}，
其中 p 爲素數。
對於一個取自 U 的輸入 n 元組 \m{\langle a_0,a_1,\ldots,a_{n-1}\rangle}，
定義其上的散列函數 \m{h_b: U\rightarrow B(b\in \integers_p)} 爲：
\startformula
h_b(\langle a_0, a_1, \ldots, a_{n-1} \rangle) =
   \left(\sum_{j=0}^{n-1} a_j b^j \right) \mod p
\stopformula
令 \m{\cal{H} = \{h_b : b \in \integers_p\}}。
根據上一個練習種 \m{\epsilon} 全域的定義，
證明 \m{\cal{H}} 是 \m{((n-1)/p)} 全域的。
（\hint 參考\refexercise{model_zero}）
\stopEXERCISE

\startANSWER
令 \m{k=\langle k_0,k_1,\ldots,k_{n-1}\rangle \in U}，
 \m{l=\langle l_0,l_1,\ldots,l_{n-1}\rangle \in U}，
且 \m{k_i \ne l_i}， \m{b\in \mathbb{Z}_p}。
則：
\startformula\startmathalignment
\NC \Pr\{h_b(k)=h_b(l)\}
   = \NC \Pr\{h_b(k)-h_b(l)=0\} \NR
\NC= \NC \Pr\{\sum_{j=0}^{n-1}(k_j-l_j)b^j = 0\} \NR
\stopmathalignment\stopformula
其中 \m{\sum_{j=0}^{n-1}(k_j-l_j)b^j = 0} 爲 \m{n-1} 次多項式，最多有 \m{n-1} 個解。
因此：
\startformula
\Pr\{h_b(k)=h_b(l)\} \le \frac{n-1}{p} \qquad b \in \integers_p
\stopformula
所以 \m{\cal{H}} 是 \m{((n-1)/p)} 全域的。
\stopANSWER

\stopsection

\startsection[
  title={Open addressing},
]

%e11.4-1
\startEXERCISE
用開放尋址法將關鍵字 10、 22、 31、 4、 15、 28、 17、 88、 59 插入到一個長度 \m{m=11} 的散列表中，
輔助散列函數 \m{h'(k)=k}。
試說明分別用線性探查、二次探查（\m{c_1=1}， \m{c_2=3}）和雙重散列
（\m{h_1(k)=k}， \m{h_2(k)=1+(k\mod (m-1))}）
將這些關鍵字插入散列表的過程。
\stopEXERCISE

\startANSWER
\startcolumns[n=3]
\externalfigure[output/e11_4_1-1]
\column
\externalfigure[output/e11_4_1-2]
\column
\externalfigure[output/e11_4_1-3]
\stopcolumns
\stopANSWER

%e11.4-2
\startEXERCISE
試寫出 \ALGO{HASH-DELETE} 的僞碼；
修改 \ALGO{HASH-INSERT}，使之能處理特殊值 \ALGO{DELETED}。
\stopEXERCISE

\startANSWER
\CLRSH{HASH-DELETE(T, k)}
\startCLRS
i = 0
repeat
	j = h(k, i)
	if T[j] == k
		T[j] = DELETED
		return
	else
		i = i + 1
until i == m
error "hash table underflow"
\stopCLRS

\CLRSH{HASH-INSERT(T, k)}
\startCLRS
i = 0
repeat
	j = h(k, i)
	if T[j] == NIL or T[j] == DELETED
		T[j] = k
		return j
	else
		i = i + 1
until i == m
error "hash table overflow"
\stopCLRS
\stopANSWER

%e11.4-3
\startEXERCISE
考慮一個採用均勻散列的開放尋址散列表。
當裝載因子爲 3/4 和 7/8 時，
試分別給出一次不成功查找和一次成功查找的探查期望數上界。
\stopEXERCISE

\startANSWER
\startformula\startmathalignment[%
  m=1, n=3,
  align={middle,middle,middle},
  distance=10em]
\NC \NC \frac{3}{4} \NC \frac{7}{8} \NR
\NC \frac{1}{1-\alpha}
    \NC 4
    \NC 8
    \NR
\NC \frac{1}{\alpha}\ln\frac{1}{1-\alpha}
    \NC \frac{8}{3}\ln{2}
    \NC \frac{24}{7}\ln{2}
    \NR
\stopmathalignment\stopformula
\stopANSWER

%e11.4-4
\startEXERCISE\DIFFICULT
假設採用雙重散列來解決衝突，
即所用的散列函數爲 \m{h(k, i)=(h_1(k)+i h_2(k)) \mod m}。
試證明：
如果對某個關鍵字 k， m 和 \m{h_2(k)} 有最大公約數 \m{d\ge 1}，
則在對關鍵字 k 的一次不成功查找中，在返回槽 \m{h_1(k)} 之前，
要檢查散列表中所有元素的 \m{1/d}。
於是，當 \m{d=1} 時， \m{m} 與 \m{h_2(k)} 互素，
查找操作可能要檢查整個散列表。
（\hint 見\refchapter{number_theoretic}）
\stopEXERCISE

\startANSWER
在循環過程中，每 d 次循環，模 m 的結果會重複一遍。
\stopANSWER

%e11.4-5
\startEXERCISE\DIFFICULT
假設開放尋址散列表的裝載因子爲 \m{\alpha}。
找到非零值 \m{\alpha}，使得查找不成功時探測次數的期望值是查找成功時探測次數期望值的兩倍。
對於探測次數期望值，使用定理 11.6 和 11.8 所給出的上界。
\stopEXERCISE

\startANSWER
查找不成功時探測次數的期望值爲 \m{1/(1-\alpha)}。

查找成功時探測次數的期望值爲 \m{\frac{1}{\alpha}\ln\frac{1}{1-\alpha}}。

\startformula
\frac{1}{1-\alpha} = 2 \frac{1}{\alpha}\ln\frac{1}{1-\alpha}
\stopformula
\stopANSWER

\stopsection

\startsection[
  title={Perfect hashing},
  reference=section:perfect_hashing,
]

%e11.5-1
\startEXERCISE
假設用開放尋址法和均勻散列技術將 n 個關鍵字插入到一個大小爲 m 的散列表中。
設 \m{p(n,m)} 爲沒有衝突發生的概率。
試證明： \m{p(n,m)\le e^{-n(n-1)/2m}}。
（\hint 式（3.12））
論證當 n 超過 \m{\sqrt{m}} 時，不發生衝突的概率快速趨於 0。

附式 3.12： \m{e^x \ge 1 + x}。
\stopEXERCISE

\startANSWER
發生衝突的概率期望值爲 \m{\binom{n}{2}\frac{1}{m}}。
所以沒有衝突發生的概率爲：
\startformula
p(n,m)
  = 1 - \binom{n}{2}\frac{1}{m}
  = 1 - \frac{n(n-1)}{2m}
  = 1 + (- \frac{n(n-1)}{2m})
  \le e^{-n(n-1)/2m}
\stopformula

\TODO{如何證明？}
\stopANSWER

\stopsection

\startsubject[
  title={Problems},
]

%p11-1
\startPROBLEM
（Longest-probe bound for hashing）
採用開放尋址法，用一個大小爲 m 的散列表存儲 n （\m{n\le m/2}）個數據項。
\startigBase[a]
\startitem
假設採用均勻散列，證明：
對於 \m{i=1,2,\ldots,n}，第 i 次插入需要嚴格多於 k 次探查概率至多爲 \m{2^{-k}}。
\stopitem

\startANSWER
\startformula\startmathalignment
\NC \Pr\{x>k\}
    \NC = \Pr\{x\ge k+1\} \NR
\NC \NC = \frac{n}{m} \cdot \frac{n-1}{m-1} \cdot \ldots \cdot \frac{n-k+1}{m-k+1} \qquad \text{參見定理 11.6} \NR
\NC \NC < (\frac{n}{m})^k \NR
\NC \NC \le (\frac{1}{2})^k \NR
\NC \NC = 2^{-k} \NR
\stopmathalignment\stopformula
\stopANSWER

\startitem
證明：對於 \m{i=1,2,\ldots,n}，第 i 次插入需要多於 \m{2\lg{n}} 次探查的概率爲 \m{O(1/n^2)}。
\stopitem

\startANSWER
根據上一項的結果：
\startformula
\Pr\{x>k\} \le 2^{-k} = 2^{-2\lg{n}} = \frac{1}{n^2}
\stopformula
\stopANSWER

設隨機變量 \m{X_i} 表示第 i 次插入所需的探查次數。
在上面 (b) 中已證明 \m{\Pr\{X_i>2\lg{n} = O(1/n^2)\}}。
設隨機變量 \m{X=\max_{1\le i\le n}X_i} 表示 n 次插入過程中所需探查數的最大值。

\startitem
證明： \m{\Pr\{X>2\lg{n}\} = O(1/n)}。
\stopitem

\startANSWER
\startformula
\Pr\{X>2\lg{n}\}
  = \sum_{i=1}^{n}\Pr\{X_i>2\lg{n}\}
  \le \sum_{i=1}^{n}\frac{1}{n^2}
  = n \cdot \frac{1}{n^2}
  = \frac{1}{n}
\stopformula
\stopANSWER

\startitem
證明：最長探查序列的期望長度爲 \m{E[x]=O(\lg{n})}。
\stopitem

\startANSWER
參見 \goto{csdn blog}[url(http://blog.csdn.net/z84616995z/article/details/21329071)]。
\startformula\startmathalignment
\NC E[x]
    \NC = \sum_{k=1}^{n}k\Pr\{X=k\} \NR
\NC \NC = \sum_{k=1}^{2\lg{n}}k\Pr\{X=k\} + \sum_{k=2\lg{n}+1}^{n}k\Pr\{X=k\} \NR
\NC \NC < 2\lg{n}\sum_{k=1}^{2\lg{n}}\Pr\{X=k\} + n\sum_{k=2\lg{n}+1}^{n}\Pr\{X=k\} \NR
\NC \NC = 2\lg{n}\Pr\{X\le 2\lg{n}\} + n\Pr\{X>2\lg{n}\} \qquad \text{其中 }
	  \Pr\{X\le 2\lg{n}\}\le 1 \qquad
	  \Pr\{X>2\lg{n}\} \le \frac{1}{n^2} \NR
\NC \NC \le 2\lg{n} + n \cdot \frac{1}{n^2} \NR
\NC \NC < 2\lg{n} + 1 \NR
\NC \NC = O(\lg{n}) \NR
\stopmathalignment\stopformula
\stopANSWER

\stopigBase
\stopPROBLEM

%p11-2
\startPROBLEM
（Slot-size bound for chaining）
假設有一個含 n 個槽的散列表，向表中插入 n 個關鍵字，並用鏈接法解決衝突問題。
每個關鍵字被等可能地散列到每個槽中。
插入所有關鍵字後，設 M 是各槽中所含關鍵字數目的最大值。
讀者的任務是證明 M 的期望值 \m{E[M]} 的一個上界爲 \m{O(\lg{n}/\lg\lg{n})}。
\startigBase[a]
\startitem
證明：正好有 k 個關鍵字被散列到某一特定槽中的概率 \m{Q_k} 爲：
\startformula
Q_k = (\frac{1}{n})^k (1-\frac{1}{n})^{n-k} \binom{n}{k}
\stopformula
\stopitem

\startANSWER
先在 n 個關鍵字中選出 k 個，
這 k 個關鍵字都會散列到特定槽中（每次散列的概率爲 \m{1/n}），
其他關鍵字都散列到其他槽中（每次散列的概率爲 \m{1- 1/n}）。
\stopANSWER

\startitem
設 \m{P_k} 爲 \m{M=k} 的概率，
即包含最多關鍵字的槽中有 \m{k} 個關鍵字的概率。
證明： \m{P_k\le n Q_k}。
\stopitem

\startANSWER
所選特定槽可能是 n 個槽中的任何一個，且概率相等。
\stopANSWER

\startitem
應用 Stirling 近似公式 3.18 證明： \m{Q_k < e^k / k^k}。
附 Stirling 近似公式：
\startformula
n! = \sqrt{2\pi n} (\frac{n}{e})^n (1 + \Theta(\frac{1}{n}))
\stopformula
\stopitem

\startANSWER
\startformula\startmathalignment
\NC Q_k
    \NC = (\frac{1}{n})^k (1-\frac{1}{n})^{n-k} \binom{n}{k} \NR
\NC \NC < \frac{1}{n^k} \frac{n!}{k!(n-k)!} \NR
\NC \NC < \frac{1}{k!} \NR
\NC \NC < \frac{1}{(\frac{k}{e})^k} \NR
\NC \NC = \frac{e^k}{k^k} \NR
\stopmathalignment\stopformula
\stopANSWER

\startitem
證明：存在常數 \m{c>1}，使得 \m{Q_{k_0} < 1/n^3} 對 \m{k_0 = c \lg{n}/\lg\lg{n}} 成立。
並有結論：對 \m{k\ge k_0 = c\lg{n}/\lg\lg{n}}， \m{P_k < 1/n^2} 成立。
\stopitem

\startANSWER
\startformula\startmathalignment[n=1]
\NC \frac{e^k}{k^k} < \frac{1}{n^3} \NR
\NC (\frac{k_0}{e})^{k_0} > n^3 \qquad \text{兩邊同取對數} \NR
\NC k_0 (\lg{k_0} - 1) > 3 \lg{n} \NR
\NC c \frac{\lg{n}}{\lg\lg{n}} (\lg(\frac{c\lg{n}}{\lg\lg{n}}) - 1) > 3 \lg{n} \NR
\NC c \frac{\lg{n}}{\lg\lg{n}} (\lg{c} + \lg\lg{n} - \lg\lg\lg{n} - 1) > 3 \lg{n} \NR
\NC c (\lg{c} + \lg\lg{n} - \lg\lg\lg{n} - 1) > 3 \lg\lg{n} \NR
\NC c (\lg{c} - \lg\lg\lg{n} - 1) + c \lg\lg{n} > 3 \lg\lg{n} \NR
\NC c (\lg{c} - \lg\lg\lg{n} - 1) > 0 \qquad c > 3 \NR
\NC \lg{c} - \lg\lg\lg{n} > 1 \qquad c > 3 \NR
\NC c / \lg\lg{n} > e \qquad c > 3 \NR
\NC c > e \lg\lg{n} \qquad c > 3 \NR
\stopmathalignment\stopformula
\stopANSWER

\startitem
證明：
\startformula
E[M] \le \Pr\{ M>\frac{c\lg{n}}{\lg\lg{n}} \} \cdot n
         + \Pr\{ M\le \frac{c\lg{n}}{\lg\lg{n}} \} \cdot \frac{c\lg{n}}{\lg\lg{n}}
\stopformula
並有結論： \m{E[M] = O(\lg{n}/\lg\lg{n})}。
\stopitem

\startANSWER
令 \m{k_0 = \frac{c\lg{n}}{\lg\lg{n}}}，則：
\startformula\startmathalignment
\NC E[M]
    \NC = \sum_{k=1}^{n}k\Pr\{M=k\} \NR
\NC \NC = \sum_{k=1}^{k_0}k\Pr\{M=k\}
          + \sum_{k=k_0+1}^{n}k\Pr\{M=k\} \NR
\NC \NC < k_0 \sum_{k=1}^{k_0}\Pr\{M=k\}
          + n\sum_{k=k_0+1}^{n}\Pr\{M=k\} \NR
\NC \NC = k_0 \Pr\{M\le k_0\}
          + n\Pr\{M>k_0\} \qquad \text{其中 }
	  \Pr\{M\le k_0\}\le 1 \qquad
	  \Pr\{M>k_0\} = P_k < \frac{1}{n^2} \NR
\NC \NC < k_0 + n \cdot \frac{1}{n^2} \NR
\NC \NC < k_0 + 1 \NR
\NC \NC = O(k_0) \NR
\stopmathalignment\stopformula
\stopANSWER

\stopigBase
\stopPROBLEM

%p11-3
\startPROBLEM
（Quadratic probing）
假設要在一個散列表中查詢關鍵字 k，散列表中各個位置爲 \m{0,1,\ldots,m-1}。
假設散列函數 h 可以將關鍵字空間映射到集合 \m{0,1,\ldots,m-1} 上，按如下方法進行查找：
\startigBase[n]
\item 計算值 \m{j=h(k)}，並置 \m{i=0}。
\item 在位置 j 上搜索關鍵字 k，無論是找到了 k 還是該位置爲 空，都結束查找。
\item 置 \m{i=i+1}。如果 \m{i=m}，則表示找不到 k，終止查找；否則，令 \m{j=(i+j)\mod m}，跳轉到步驟 2。
\stopigBase

假設 m 是 2 的冪。
\startigBase[a]
\startitem
利用等式 11.5，給出合適的 \m{c_1} 和 \m{c_2}，證明該方案是一般的“二次探查”法的一個實例。
附等式 11.5：
\startformula
h(k,i) = (h'(k) + c_1 i + c_2 i^2) \mod m
\stopformula
\stopitem

\startANSWER
\startformula
j_i
  = (j_{i-1} + i) \mod m
  = (j_1 + 1 + 2 + \ldots + i) \mod m
  = (h(k) + \frac{1}{2}i^2 + \frac{1}{2}i) \mod m
\stopformula
因此 \m{c_1 = 1/2, c_2 = 1/2}。
\stopANSWER

\startitem
證明：在最壞情況下，這個算法要檢查表中的每一個位置。
\stopitem

\startANSWER
假設兩次的值分別爲 \m{h(k,i)} 和 \m{h(k,j)} （\m{0<i<j<m}）。
\startformula\startmathalignment[n=1]
\NC h(k,i) = (h(k) + i^2/2 + i/2) \mod m \NR
\NC h(k,j) = (h(k) + j^2/2 + j/2) \mod m \NR
\stopmathalignment\stopformula
如果二者相等，則：
\startformula\startmathalignment[n=1]
\NC (h(k) + i^2/2 + i/2) \equiv (h(k) + j^2/2 + j/2) (\mod m) \NR
\NC (i^2/2 + i/2) \equiv (j^2/2 + j/2) (\mod m) \NR
\NC (j^2/2 + j/2 - i^2/2 - i/2) \equiv 0 (\mod m) \NR
\NC (j-i)(j+i+1)/2 = km \qquad \text{令 }m=2^t\NR
\NC (j-i)(j+i+1) = k 2^{t+1} \NR
\stopmathalignment\stopformula

另外 \m{j-i} 和 \m{j+i+1} 定是一個奇數、另一個偶數。
其中奇數不含因子 2，所以所有的因子 2 都在偶數中。即 \m{2^{t+1} = 2m} 能整除其中的偶數。

即設 \m{j-i} 是偶數，則 \m{j-i < m}，而 \m{2m | (j-i)} 不成立。
而如果 \m{j+i+1} 是偶數，則 \m{j+i+1 < 2m}，而 \m{2m | (j-i+1)} 不成立。
因此 \m{h(k,i)\ne h(k,j)}。
即 m 次循環所得散列值各部相等，又因爲都小於 m，所以覆蓋了整個散列表。
\stopANSWER

\stopigBase
\stopPROBLEM

%p11-4
\startPROBLEM
（Hashing and authentication）
令 \m{\cal{H}} 爲一組散列函數，
其中每個函數 \m{h\in\cal{H}} 都可以將關鍵字的全域 U 映射到 \m{\{0,1,\ldots,m-1\}} 上。
如果對於任一 k 個互不相同的關鍵字構成的的固定序列 \m{\langle x^{(1)},x^{(2)},\ldots,x^{(k)} \rangle}，
以及從 \m{\cal{H}} 中隨機選出的 \m{h}，
序列 \m{\langle h(x^{(1)}),h(x^{(2)}),\ldots,h(x^{(k)}） \rangle} 是 \m{m^k} 個長度爲 \m{k} 的序列
（其元素取自 \m{\{0,1,\ldots,m-1\}}）中任意一個，其可能性相同,
我們稱 \m{\cal{H}} 是 {\EMP k 全域}（k-universal）的。
\startigBase[a]
\startitem%a
證明：如果散列函數族 \m{\cal{H}} 是 2 全域的，則他是全域的。
\stopitem

\startANSWER
如果 \m{\cal{H}} 是 2 全域的，則對於兩個特定關鍵字 \m{x\ne y}，
序列 \m{\langle x, y\rangle} 是 \m{m^2} 種序列中的任一個，概率相同。
因此，由於 \m{h} 是 \m{\cal{H}} 中的任意一個，
產生衝突 \m{h(x) = h(y)} 的概率爲 \m{(1/m)|\cal{H}|}，
所以 \m{\cal{H}} 是全域的。

參見 \goto{blog}[url(http://ripcrixalis.blog.com/2011/02/08/clrs-chapter-11/)]。
\stopANSWER

\startitem%b
設全域 U 爲取自 \m{\integers_p = \{0,1,\ldots,p-1\}} 中數值的 n 元組集合，
其中 p 是素數。
考慮元素 \m{x=\langle x_0,x_1,\ldots,x_{n-1} \rangle \in U}。
對於任意 n 元組 \m{a=\langle a_0,a_1,\ldots,a_{n-1} \rangle \in U}，
定義散列函數 \m{h_a} 爲：
\startformula
h_a(x) = \left( \sum_{j=0}^{n-1}a_j x_j \right) \mod p
\stopformula
並設 \m{\cal{H}=\{h_a\}}。
證明： \m{\cal{H}} 是全域的，但不是 2 全域的。
（\hint 找一個關鍵字，使得 \m{\cal{H}} 中所有散列函數對其都得到相同的值。）
\stopitem

\startANSWER
假設在 \m{\cal{H}} 中選擇函數 \m{h}，
如果 \m{a=\langle 0,0,\ldots,0\rangle}，則對於序列 \m{\langle x,y\rangle}，
有 \m{h_a(x)=h_a(y) = 0 \mod p = 0}，即這種情況下無論關鍵字是什麼，映射對結果永遠是 \m{\langle 0,0\rangle}，所以不是 2 全域的。

參見 \goto{blog}[url(http://ripcrixalis.blog.com/2011/02/08/clrs-chapter-11/)]。
\stopANSWER

\startitem%c
即設將 (b) 中的 \m{\cal{H}} 略作修改：對任意 \m{a\in U} 和任意 \m{b\in\integers_p}，定義：
\startformula
h'_{ab}(x) = \left( \sum_{j=0}^{n-1}a_j x_j + b \right) \mod p
\stopformula
且 \m{\cal{H}'=\{h'_{ab}\}}。論證 \m{\cal{H}'} 是 2 全域的。
（\hint 慮固定的 n 元組 \m{x\in U} 和 \m{y\in U}，
對某個 i 有 \m{x_i\ne y_i}。當 \m{a_i} 和 b 包括 \m{\integers_p} 時，
 \m{h'_{ab}(x)} 和 \m{h'_{ab}(y)} 會如何？）
\stopitem

\startANSWER
對於每一對關鍵字 \m{\langle x,y\rangle}，其中 \m{x\ne y}，
我們要證明所有值對 \m{(h_{ab}(x),h_{ab}(y))} 的概率相同，
其中 \m{h_{ab}} 是從 \m{\cal{H}} 中隨機選出，
即 \m{\langle a_0,a_1,\ldots,a_{n-1}} 和 b 是隨機選出的。

既然 \m{x\ne y}，那麼肯定存在 i 使得 \m{x_i\ne y_i}，
假設 \m{i=0}，令：
\startformula
\alpha = h_{ab}(x)
\qquad \beta = h_{ab}(y)
\stopformula
且：
\startformula
X=\sum_{j=1}^{n-1}a_j x_j
\qquad Y=\sum_{j=1}^{n-1}a_j y_j
\stopformula
則：
\startformula
\alpha = (a_0 x_0 + b + X) \mod p
\qquad \beta = (a_0 y_0 + b + Y) \mod p
\stopformula
由於 \m{x_0 \ne y_0} 且 p 是素數，那麼對於 \m{\alpha} 和 \m{\beta} 而言，
上式有唯一解 \m{a_0} 和 \m{b}。

更明顯一點，考慮我們要生成所有可能的值對 \m{\alpha,\beta}，
他與值對 \m{\alpha,\alpha-\beta} 是雙射的。而：
\startformula
\alpha-\beta=a_0(x_0-y_0) + X - Y (\mod p)
\stopformula
所以：
\startformula
a_0 = (\alpha - \beta -X + Y) (x_0 - y_0)^{(-1)} (\mod p)
\stopformula

由於 \m{x_0 \ne y_0} 且 p 是素數，則 \m{(x_0 - y_0)^{(-1)}} 肯定存在且唯一。
對於特定 \m{a_0} 而言，我們可以隨意選擇 \m{\alpha-\beta} 的值。
對於特定 \m{b} 而言，我們可以隨意選擇 \m{\alpha} 的值。
即對於特定的 \m{a_0} 和 \m{b}，我們可以隨意選擇 \m{\alpha} 和 \m{\beta}，
只要保證 \m{(\alpha-\beta)\mod p} 的值相同即可。

因此，對於任意給定的 \m{\langle a_0,a_1,\ldots,a_{n-1}\rangle}，
我們可以找到散列函數 \m{h_{ab}}，通過選擇合適的 \m{a_0} 和 \m{b}，
使其可以生成任何可能的 \m{\langle\alpha,\beta\rangle}。

由於 \m{a_0} 和 \m{b} 的選擇共有 \m{p^2} 種，
並且 \m{\langle\alpha,\beta\rangle} 也有 \m{p^2} 種，
每個 \m{\langle\alpha,\beta\rangle} 都對應唯一的 \m{\langle a_0,b\rangle}。
這對 \m{a_1,\ldots,a_{n-1}} 的 \m{p^{n-1}} 種選擇均成立。

因此，有 \m{p^{n-1}} 種函數 \m{h_{ab}} 可以生成每個值對 \m{\langle\alpha,\beta\rangle}。
如果 \m{h_{ab}} 是隨機選擇的，則每個值對的概率相同，因此 \m{\cal{H}} 是 2 全域的。

參見 \goto{blog}[url(http://ripcrixalis.blog.com/2011/02/08/clrs-chapter-11/)]。
\stopANSWER

\startitem%d
假設 Alice 和 Bob 悄悄地約定了一個取自 2 全域散列函數族 \m{\cal{H}} 中的散列函數 h。
每個 \m{h\in \cal{H}} 將關鍵字全域 U 映射到 \m{\integers_p} 上，此處 p 爲素數。
後來， Alice 通過互聯網向 Bob 發送了一個消息 m，其中 \m{m\in U}。
她同時還通過發送一個認證標記 \m{t=h(m)} 來向 Bob 認證這一消息，
而 Bob 則要檢查他所收到的 \m{(m,t)} 對是否確實滿足 \m{t=h(m)}。
假設某一對手半路截獲了 \m{(m,t)}，並試圖將該值對替換爲令一值對 \m{(m',t')} 來欺騙 Bob。
論證無論該對手的計算機性能多好，他成功欺騙 Bob 接受 \m{(m',t')} 的概率至多爲 \m{1/p}，
即使他知道所用的散列函數族 \m{\cal{H}}。
\stopitem

\startANSWER
對於關鍵字對 \m{\langle m,m'\rangle}，如果 h 是隨機選取的，
則所有散列值對 \m{\langle h(m),h(m')\rangle} 的概率相同。
這就是 \m{\cal{H}} 爲 2 全域的意思。

即 p 種值對 \m{\langle t,t'\rangle} 的概率相同，
所以即使他知道 \m{\cal{H}}，根據 m 和 t 也無法得出 \m{h(m')}。
由於 p 種情況的概率相同，且總和爲 1，
任一種可能的 \m{h(m')} 概率均爲 \m{1/p}，
所以他只能靠猜，沒有更好的辦法。

參見 \goto{blog}[url(http://ripcrixalis.blog.com/2011/02/08/clrs-chapter-11/)]。
\stopANSWER
\stopigBase
\stopPROBLEM

\stopsubject%Problems

\stopchapter
\stopcomponent

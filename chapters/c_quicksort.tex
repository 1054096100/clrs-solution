\startcomponent c_quicksort

\startchapter[
%reference=,	%The reference key for cross-referencing (with \at, \in etc.)
title={Quicksort},	%The title of the section
%list=,	%The title to show in the table of contents, if different
%bookmark=,	%The title to show in the PDF bookmarks, if different
%marking=,	%The title to use in the section marking, if different
%label=	 ?,
]

\startsection[
  reference=section:desc_quicksort,
  title={Description of quicksort},
]

\startEXERCISE
參照圖 7-1 的方法，說明 \ALGO{PARTITION} 在數列 \m{A = \langle 13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11 \rangle} 上的操作過程。
\stopEXERCISE

\startANSWER
{\externalfigure[output/e7_1_1-1]}
{\externalfigure[output/e7_1_1-2]}
{\externalfigure[output/e7_1_1-3]}
{\externalfigure[output/e7_1_1-4]}
{\externalfigure[output/e7_1_1-5]}
{\externalfigure[output/e7_1_1-6]}
{\externalfigure[output/e7_1_1-7]}
{\externalfigure[output/e7_1_1-8]}
{\externalfigure[output/e7_1_1-9]}
{\externalfigure[output/e7_1_1-10]}
{\externalfigure[output/e7_1_1-11]}
{\externalfigure[output/e7_1_1-12]}
{\externalfigure[output/e7_1_1-13]}
\stopANSWER

\startEXERCISE[exercise:same_partition]
當數列 \m{A[p..r]} 中的元素都相同時， \ALGO{PARTITION} 返回的 \m{q} 值是多少？
修改 \ALGO{PARTITION}，使得當數列 \m{A[p..r]} 中所有元素的值都相同時， \m{q=\lfloor (p+r)/2\rfloor}。
\stopEXERCISE

\startANSWER
元素都相同時返回的值爲 \m{r}。

\CLRSH{PARTITION'(A, p, r)}
\startCLRS
x = A[r]
i = p - 1
for j = p to r - 1
	if A[j] <= x
		i = i + 1
		exchange A[i] with A[j]
i = i + 1
exchange A[i] with A[r]

if i = r
	return ⌊(p + r) / 2⌋
return i
\stopCLRS
\stopANSWER

\startEXERCISE
證明：在規模爲 \m{n} 的子數列上， \ALGO{PARTITION} 的時間復雜度爲 \m{\Theta(n)}。
\stopEXERCISE

\startANSWER
{\EMP for} 循環的次數爲 \m{r - 1 - p = \Theta(n)}。
最壞情況下，每次循環都會執行 {\EMP if} 塊，需要常數時間；循環外的語句也需要常數隨時間。
因此時間復雜度爲 \m{\Theta(n)}。
\stopANSWER

\startEXERCISE
修改 \ALGO{QUICKSORT}，使其能以非遞增方式配需。
\stopEXERCISE

\startANSWER
只需修改 \ALGO{PARTITION} 中第 4 行的比較條件。
\stopANSWER

\stopsection

\section{Performance of quicksort}

\startEXERCISE
用代入法證明：正如本節開頭所提到的那樣，遞迴式 \m{T(n)=T(n-1)+\Theta(n)} 的解爲：
\startformula
T(n)=\Theta(n^2)
\stopformula
\stopEXERCISE

\startANSWER
令 \m{\Theta(n)} 爲 \m{c_2 n}，猜測 \m{T(n)\le c_1 n^2}：
\startformula\startmathalignment
\NC T(n) \NC=   T(n-1) + c_2n \NR
\NC      \NC\le c_1(n-1)^2 + c_2n \NR
\NC      \NC=   c_1n^2 - 2c_1n + c_1 + c_2n \qquad (2c_1 > c_2, n \ge c_1/(2c_1 - c_2))\NR
\NC      \NC\le c_1n^2 \NR
\stopmathalignment\stopformula
\stopANSWER

\startEXERCISE
當數列 \m{A} 包含的元素都具有相同值時， \ALGO{QUICKSORT} 的時間復雜度時什麼？
\stopEXERCISE

\startANSWER
時間復雜度爲 \m{\Theta(n^2)}，因爲 \ALGO{PARTITION} 時總有一邊爲空（參見\refexercise{same_partition}）。
\stopANSWER

\startEXERCISE
證明：當數列 \m{A} 包含的元素不同，且按降序排列時， \ALGO{QUICKSORT} 的時間復雜度爲 \m{\Theta(n^2)}。
\stopEXERCISE

\startANSWER
\ALGO{PARTITION} 總是返回 \m{p}，即總有一邊是空。
遞迴式仍爲 \m{T(n)=T(n-1)+\Theta(n)}。
（即使 {\EMP if} 塊內執行不到， {\EMP for} 循環的執行次數不變，仍是 \m{\Theta(n)}。）
\stopANSWER

\startEXERCISE
銀行一般會按照交易時間記錄某一賬戶的交易情況。
但是，很多人卻希望收到的銀行張但是按照支票號碼的順序排列。
這是因爲，人們通常都是按照支票號碼的順序來開出支票的，
而商人也通常都是根據支票號碼的順序兌付支票。
這一問題是將按交易時間排序的序列轉換成按支票號排序的序列，
他實質上是一個對幾乎有序的輸入序列進行排序的問題。
請證明：在這個問題上， \ALGO{INSERTION-SORT} 的性能往往要優於 \ALGO{QUICKSORT}。
\stopEXERCISE

\startANSWER
\ALGO{INSERTION-SORT} 的時間復雜度爲 \m{\Theta(n+d)}，其中 \m{d} 爲逆序對的數目。
在本例中， \m{d} 的值幾乎爲 0，因此插入排序的時間幾乎是線性的。

而在基本有序的情況下，大部分 \m{PARTITION} 都會出現一邊爲空的情況。
從而使得 \ALGO{QUICKSORT} 所用時間復雜度接近 \m{\Theta(n^2)}。
\stopANSWER

\startEXERCISE
假設快速排序的每一層所做的劃分比例都是 \m{1-\alpha : \alpha}，
其中 \m{0<\alpha\le 1/2} 且爲常數。
證明：在相應的遞迴樹中，葉子節點的最小深度大約是 \m{-\lg{n}/\lg{\alpha}}，
最大深度大約是 \m{-\lg{n}/\lg(1-\alpha)}（無需考慮整數舍入問題）。
\stopEXERCISE

\startANSWER
樹的最小深度是 \m{n\alpha^x\le 1} 的解：
\startformula\startmathalignment[n=1]
\NC n\alpha^x \le 1 \NR
\NC \Downarrow \NR
\NC \alpha^x \le \frac 1 n \NR
\NC \Downarrow \NR
\NC x \ge \log_{\alpha}\frac{1}{n} \NR
\NC \Downarrow \NR
\NC \log_{\alpha}\frac{1}{n} = \log_{1/\alpha}
                             = \frac{\lg{n}}{\lg(1/\alpha)}
                             = - \frac{\lg{n}}{\lg{\alpha}} \NR
\stopmathalignment\stopformula

類似，最大深度爲 \m{\log_{1/(1-\alpha)}n = - \frac{\lg{n}}{\lg(1-\alpha)}}。
\stopANSWER

\startEXERCISE[exercise:const_part_probability]\DIFFICULT
證明：在一個隨機輸入數列上，對於任何常數 \m{0<\alpha\le 1/2}，
 \ALGO{PARTITION} 產生比 \m{1-\alpha : \alpha} 更平衡的劃分的概率約爲 \m{1-2\alpha}。
\stopEXERCISE

\startANSWER
將元素劃分成三部分，最小的 \m{\alpha n} 個元素、最大的 \m{\alpha n} 個元素，
還有 \m{(1-2\alpha)n} 個中間值元素。
只有當 \ALGO{PARTITION} 所選的主元處於最後一個集合中時，所的劃分才比 \m{1-\alpha : \alpha} 更平衡。
其概率爲 \m{(1-2\alpha)n / n = (1-2\alpha)}。
\stopANSWER

\startsection[
  reference=section:rand_quicksort,
  title={A randomized version of quicksort},
]

\startEXERCISE
爲什麼我們分析隨機化算法的期望運行時間，而不是其最壞運行時間？
\stopEXERCISE

\startANSWER
因爲最壞情況不會由特定輸入觸發，而時隨機的。
即無法以可信的方式觸發最壞情況，但是他以一定概率包含在期望運行時間內。
\stopANSWER

\startEXERCISE
在 \ALGO{RANDOMIZED-QUICKSORT} 的運行過程中，
在最壞情況下，隨機數生成器 \ALGO{RANDOM} 被調用了多少次？
在最好情況下呢？
以 \m{\Theta} 符號的形式給出答案。
\stopEXERCISE

\startANSWER
最壞情況下，調用 \ALGO{RANDOM} 的次數爲：
\startformula
T(n)=T(n-1)+1=n=\Theta(n)
\stopformula
而最好情況則爲：
\startformula
T(n)=2T(n/2)+1=\Theta(n)
\stopformula
不用驚訝，因爲至少由三分之一的元素都會用作主元。
\stopANSWER

\stopsection

\section{Analysisof quicksort}

\startEXERCISE
證明遞迴式：
\startformula
T(n) = \max_{0 \le q \le n-1} (T(q) + T(n-q-1)) + \Theta(n)
\stopformula
的解爲 \m{T(n)=\Omega(n^2)}。
\stopEXERCISE

\startANSWER
猜測 \m{T(n)\ge cn^2-2n}：
\startformula\startmathalignment
\NC T(n) \NC=   \max_{0 \le q \le n-1} (T(q) + T(n-q-1)) + \Theta(n) \NR
\NC      \NC\ge \max_{0 \le q \le n-1} (cq^2 - 2q + c(n-q-1)^2 - 2n - 2q -1) + \Theta(n) \NR
\NC      \NC\ge c\max_{0 \le q \le n-1} (q^2 + (n-q-1)^2 - (2n + 4q + 1)/c) + \Theta(n) \NR
\NC      \NC\ge cn^2 - c(2n-1) + \Theta(n) \NR
\NC      \NC\ge cn^2 - 2cn + 2c \qquad (c \le 1) \NR
\NC      \NC\ge cn^2 - 2n \NR
\stopmathalignment\stopformula
\stopANSWER

\startEXERCISE
證明：在最好情況下，快速排序的運行時間爲 \m{\Omega(n\lg{n})}。
\stopEXERCISE

\startANSWER
最好情況下運行時間爲：
\startformula
T(n)=2T(n/2)+\Theta(n)
\stopformula
由主定理解得 \m{T(n)=\Theta(n\lg{n})}。
\stopANSWER

\startEXERCISE
證明：在 \m{q=0, 1, \ldots, n-1} 區間內，當 \m{q=0} 或 \m{q=n-1} 時，
 \m{q^2+(n-q-1)^2} 取得最大值。
\stopEXERCISE

\startANSWER
\startformula\startmathalignment
\NC f(q)  \NC= q^2 + (n - q - 1)^2 \NR
\NC f'(q) \NC= 2q - 2(n - q - 1) = 4q - 2n + 2 \NR
\NC f''(q)\NC= 4 \NR
\stopmathalignment\stopformula
當 \m{q=\frac{1}{2}n-\frac{1}{4}} 時， \m{f'(q)=0}。
\m{f'(q)} 是連續的。
由於 \m{\forall q : f''(q) > 0}，所以在 \m{f'(q) =0} 的左邊 \m{f'(q)<0}，
在 \m{f'(q) =0} 的右邊 \m{f'(q)>0}。
即 \m{f(q)} 在 \m{f'(q)=0} 時取得最小值，左邊遞減，右邊遞增。
所以 \m{q} 取兩端的值時， \m{f(q)} 取得最大值。
\stopANSWER

\startEXERCISE
證明： \ALGO{RANDOMIZED-QUICKSORT} 期望運行時間時 \m{\Omega(n\lg{n})}。
\stopEXERCISE

\startANSWER
與比較次數期望值的推理類似，只是方向不同：
\startformula\startmathalignment
\NC E[X] \NC=   \sum_{i=1}^{n-1} \sum_{j=i+1}^n \frac{2}{j-i+1} \NR
\NC      \NC=   \sum_{i=1}^{n-1} \sum_{k=1}^{n-i} \frac{2}{k + 1} \qquad (k \ge 1) \NR
\NC      \NC\ge \sum_{i=1}^{n-1} \sum_{k=1}^{n-i} \frac{2}{2k} \NR
\NC      \NC\ge \sum_{i=1}^{n-1} \Omega(\lg{n}) \NR
\NC      \NC=   \Omega(n\lg{n}) \NR
\stopmathalignment\stopformula
\stopANSWER

\startEXERCISE
當輸入數據已經“幾乎有序”時，插入排序速度很快。
在實際應用中，我們可以利用這一特點來提高快速排序的速度。
當堆一個長度小於 \m{k} 的子數列調用快速排序時，讓他直接返回。
當上層的快速排序調用返回後，對整個數組運行插入排序來完成排序過程。
證明：這一排序算法的期望時間復雜度爲 \m{O(nk+n\lg(n/k))}。
分別從理論和實踐的角度說明我們應該如何選擇 \m{k}。
\stopEXERCISE

\startANSWER
在所推薦的算法中，遞迴在 \m{\lg(n/k)} 層處終止，
期望運行時間爲 \m{O(n\lg(n/k))}。
但是還有 \m{n/k} 個，（最大）長度爲 \m{k}，沒有排序的子數列。
由插入排序的性質可知，他會將一個個子數列按順序排序。
即所有子數列的時間復雜度是相同的： \m{\frac{n}{k}O(k^2)=O(nk)}。

理論上，求解 \m{k} 時我們可以忽略常數因子：
\startformula\startmathalignment[n=1]
\NC n\lg{n} \ge nk + n\lg{n/k} \NR
\NC \Downarrow \NR
\NC \lg{n} \ge k + \lg{n} - \lg{k} \NR
\NC \Downarrow \NR
\NC \lg{k} \ge k \NR
\stopmathalignment\stopformula
但這是不可能的。

而如果加上常數因子，則：
\startformula\startmathalignment[n=1]
\NC c_qn\lg{n} \ge c_ink + c_qn\lg(n/k) \NR
\NC \Downarrow \NR
\NC c_q\lg{n} \ge c_ik + c_q\lg{n} - c_q\lg{k} \NR
\NC \Downarrow \NR
\NC \lg{k} \ge \frac{c_i}{c_q}k \NR
\stopmathalignment\stopformula
這意味着有解。進一步，可能還要考慮低階項。

在實踐中，應當通過實驗來確定 \m{k}。
\stopANSWER

\startEXERCISE[exercise:random_three_median]
考慮對 \ALGO{PARTITION} 過程做這樣的修改：
從數列 \m{A} 中隨機選出三個元素，
並用這三個元素的中位數（即這三個元素按大小排在中間的值）對數組進行劃分。
求以 \m{\alpha} 的函數形式表示的、最壞劃分比例爲 \m{\alpha:(1-\alpha)} 的近似概率，
其中 \m{0<\alpha<1}。
\stopEXERCISE

\startANSWER
簡單起見，假定可以重復選擇同一元素。同樣假定 \m{0<\alpha\le 1/2}。

將元素按大小分成三部分，最小的 \m{\alpha n} 個元素，最大的 \m{\alpha n} 個元素，
還有大小處於中間的 \m{1-2\alpha n} 個元素。
任選一元素位於最小那部分中的概率爲 \m{\alpha n/n = \alpha}。
如果恰好有兩個元素在最小的那部分中，其概率爲 \m{\alpha^2(1-\alpha)}。
如果三個元素均在最小的那部分中，其概率爲 \m{\alpha^3}。
前者共有三種可能（三個元素中任一元素不在最小那部分中），後者只有一種可能，
總的概率爲 \m{3\alpha^2(1-\alpha)+\alpha^3 = 3\alpha^2-2\alpha^3}。
最小那部分與最大那部分類似，將前面所列情況中最大、最小互換，其概率不變。
這樣這些情況總的概率爲 \m{(3\alpha^2-2\alpha^3) \times 2 = 6\alpha^2-4\alpha^3}。
這些情況所得劃分均比 \m{\alpha:(1-\alpha)} 要糟糕，所以更好劃分的概率爲：
\startformula
1 - 6\alpha^2 + 4\alpha^3
\stopformula
\stopANSWER

%p7-1
\startPROBLEM
（Hoare partition correctness）
本章中的 \ALGO{PARTITION} 算法並不是其最初版本。
下面給出的時最早由 C.R.Hoare 所設計的劃分算法：

\CLRSH{HOARE-PARTITION(A, p, r)}
\startCLRS
x = A[p]
i = p - 1
j = r + 1
while TRUE
	repeat
		j = j - 1
	until A[j] <= x
	repeat
		i = i + 1
	until A[j] >= x
	if i < j
		exchange A[i] with A[j]
	else
		return j
\stopCLRS
\startigBase[a]
\startitem 試說明 \ALGO{HOARE-PARTITION} 在數列 \m{A = \langle 13, 19, 9, 5, 12, 8, 7, 4, 11, 2, 6, 21 \rangle} 上的操作過程，
並說明在每一次執行第 4～13 行 {\EMP while} 循環時數列元素的值和輔助變量的值。
\stopitem

\startANSWER
輔助變量的值： \m{x = 13}， \m{j = 9}， \m{i = 10}。

{\externalfigure[output/p7_1_a-1]}
{\externalfigure[output/p7_1_a-2]}
{\externalfigure[output/p7_1_a-3]}
\stopANSWER
\stopigBase

後續的三個問題要求讀者仔細論證 \ALGO{HOARE-PARTITION} 的正確性。
在這裏假設子數列 \m{A[p..r]} 至少包含 2 個元素，證明下列問題：
\startigBase[a,continue]
\startitem
下標 \m{i} 和 \m{j} 可以使我們不會訪問在子數列 \m{A[p..r]} 意外的數列 \m{A} 的元素。
\stopitem

\startANSWER
第一次比較時， \m{i < j}， \m{i=p} 且 \m{j\ge p} （因爲 \m{A[p]=x}）。
如果 \m{i=j}，算法終止，不會訪問任何“無效”元素。
如果 \m{i<j}，下一次循環中 \m{i} 和 \m{j} 都仍有效（\m{i\le r} 且 \m{j\ge p}）。
如果某一個下標到達數列兩端，則 \m{i} 不再小於等於 \m{j}。
\stopANSWER

\startitem
當 \ALGO{HOARE-PARTITION} 結束時，他返回的值 \m{j} 滿足 \m{p\le j < r}。
\stopitem

\startANSWER
第一次迭代時，如果 \m{A[p]} 是最大元素，則 \m{i=p} 且 \m{j=p<r}；
否則會交換 \m{A[p]} 和 \m{A[j]}，其中 \m{j\le r}。
算法此時不會終止，下一次迭代時， \m{j} 會減小，因此 \m{p\le j < r}。
\stopANSWER

\startitem
當 \ALGO{HOARE-PARTITION} 結束時， \m{A[p..j]} 中的每一個元素都小於或等於 \m{A[j+1..r]} 中的元素。
\stopitem

\startANSWER
比較 \m{i} 和 \m{j} 之前， \m{A[p..i-1]} 中所有元素都小於等於 \m{x}；
而 \m{A[j+1..r]} 中所有元素都大於等於 \m{x}。

{\EMP 初始化：}兩個 {\EMP repeat} 塊將建立此條件；

{\EMP 保持：}通過交換 \m{A[i]} 和 \m{A[j]}，使得 \m{A[p..i]\le x} 且 \m{A[j..r]\ge x}。
增大 \m{i} 和減小 \m{j} 都將維持不變式；

{\EMP 終止：}當 \m{i\ge j} 時循環終止。不變式仍然得以保持。
\stopANSWER

\stopigBase

在\refsection{desc_quicksort} 的 \ALGO{PARTITION} 過程中，
主元（原來存儲在 \m{A[r]} 中）是與他所劃分的兩個分區分離的。
與之對應，在 \ALGO{HOARE-PARTITION} 中，
主元（原來存儲在 \m{A[p]} 中）是存在於 \m{A[p..j]} 或 \m{A[j+1..r]} 中的。
因爲由 \m{p\le j<r}，所以這一劃分總是非平凡的。
\startigBase[a,continue]
\startitem
利用 \ALGO{HOARE-PARTITION}，重寫 \ALGO{QUICKSORT} 算法。
\stopitem

\startANSWER
\CLRSH{QUICKSORT''(A, p, r)}
\startCLRS
if p < r
	q = HOARE-PARTITION(A, p, r)
	QUICKSORT(A, p, q)
	QUICKSORT(A, q + 1, r)
\stopCLRS
\stopANSWER
\stopigBase
\stopPROBLEM

%p7-2
\startPROBLEM[problem:quicksort_with_equal]
（Quicksort with equal element values）
在節 7.4.2 對隨機化快速排序的分析中，
我們假設輸入元素的值是互異的，
本題中，我們來看看如果這一假設不成立會出現什麼情況。
\startigBase[a]
\startitem
如果所有輸入元素的值都相同，那麼隨機化快速排序的運行時間會是多少？
\stopitem

\startANSWER
運行時間是 \m{\Theta(n^2)}。所有的劃分都將是 \m{(n-1):1} （參見\refexercise{same_partition}）。
\stopANSWER

\startitem
\ALGO{PARTITION} 過程返回一個數列下標 \m{q}，
使得 \m{A[p..q-1]} 中的每個元素都小於或等於 \m{A[q]}，
而 \m{A[q+1..r]} 中的每個元素都大於 \m{A[q]}。
修改 \ALGO{PARTITION} 代碼來構造一個新的 \ALGO{PARTITION'(A, p, r)}，
他將 \m{A[p..r]} 中的元素排序後，
返回值是兩個數列下標 \m{q} 和 \m{t}，
其中 \m{p\le q\le t\le r}，且：
\startigBase[a]
\item \m{A[q..t]} 中的所有元素都項燈；
\item \m{A[p..q-1]} 中的所有元素都小於 \m{A[q]}；
\item \m{A[t+1..r]} 中的所有元素都大於 \m{A[q]}。
\stopigBase
與 \ALGO{PARTITION} 類似，新構造的 \ALGO{PARTITION'} 的時間復雜度是 \m{\Theta(r-p)}。
\stopitem

\startANSWER
\CLRSH{PARTITION'(A, p, r)}
\startCLRS
x = A[r]
q = p - 1
t = q
for j = p to r - 1
	if A[j] <= x
		if A[j] = x
			q = q + 1
			exchange A[q] with A[j]
		t = t + 1
		exchange A[t] with A[j]
q = q + 1
t = t + 1
exchange A[t] with A[r]

return q, t
\stopCLRS
\stopANSWER

\startitem
將 \ALGO{RANDOMIZED-QUICKSORT} 過程改爲調用 \ALGO{PARTITION'}，
並重新命名爲 \ALGO{RANDOMIZED-QUICKSORT'}。
修改 \ALGO{QUICKSORT} 的代碼構造一個新的 \ALGO{QUICKSORT'(A, p, r)}，
他調用 \ALGO{RANDOMIZED-PARTITION'}，
並且只有分區內的元素互不相同時才做遞迴調用。
\stopitem

\startANSWER
\CLRSH{RANDOMIZED-QUICKSORT'(A, p, r)}
\startCLRS
if p < r
	q, t = PARTITION'(A, p, r)
	RANDOMIZED-QUICKSORT'(A, p, q - 1)
	RANDOMIZED-QUICKSORT'(A, t + 1, r)
\stopCLRS

\CLRSH{QUICKSORT'(A, p, r)}
\startCLRS
if p < r
	q, t = RANDOMIZED-PARTITION'(A, p, r)
	QUICKSORT'(A, p, q - 1)
	QUICKSORT'(A, t + 1, r)
\stopCLRS
\stopANSWER

\startitem
在 \ALGO{QUICKSORT'} 中，如何改變節 7.4.2 中的分析方法，
才能避免所有元素互異這一假設？
\stopitem

\startANSWER
\TODO{需要處理}
\stopANSWER
\stopigBase
\stopPROBLEM

\startPROBLEM[problem:alt_quicksort_analysis]
（Alternative quicksort analysis）
在隨機化快速排序中，還有一種性能分析方法，
這一方法關注於每一次單獨遞迴調用的期望運行時間，而不是比較的次數。
\startigBase[a]
\startitem
證明：給定一個大小爲 \m{n} 的數列，任何特定元素被選爲主元的概率爲 \m{1/n}。
利用這一點來定義指示器隨機變量 \m{X_i=I\{\text{第 \m{i} 小的元素被選爲主元}\}}，
那麼 \m{E[X_i]} 是什麼？
\stopitem

\startANSWER
\m{E[X_i] = 1/n}。
\stopANSWER

\startitem
令 \m{T(n)} 表示快速排序在大小爲 \m{n} 的數列上的運行時間，證明：
\setnumber[formula]{5}
\placeformula
\startformula
E[T(n)] = E\left[\sum_{q=1}^nX_q(T(q-1) + T(n-q) + \Theta(n))\right]
\stopformula
\stopitem

\startANSWER
令第 \m{q} 小元素爲主元，則有 \m{n} 種可能，每種概率爲 \m{X_q}。
每種都會將數列劃分成 \m{(q-1):(n-q)} 兩部分。
\stopANSWER

\startitem
證明公式可以重寫爲：
\placeformula[formula:7_6]
\startformula
E[T(n)] = \frac{2}{n}\sum_{q=2}^{n-1}E[T(q)] + \Theta(n)
\stopformula
\stopitem

\startANSWER
\startformula\startmathalignment
\NC E[T(n)] \NC= E\left[\sum_{q=1}^nX_q(T(q-1) + T(n-q) + \Theta(n))\right] \NR
\NC         \NC= \sum_{q=1}^n\frac{1}{n}(E[T(q-1)] + E[T(n-q)] + \Theta(n)) \NR
\NC         \NC= \frac{1}{n}\sum_{q=1}^nE[T(q-1)]
             + \frac{1}{n}\sum_{q=1}^nE[T(n - q)]
             + \frac{1}{n}\sum_{q=1}^n\Theta(n) \NR
\NC         \NC= \frac{1}{n}\sum_{q=0}^{n-1}E[T(q)]
             + \frac{1}{n}\sum_{q=0}^{n-1}E[T(n - q - 1)]
             + \Theta(n) \NR
\NC         \NC= \frac{1}{n}\sum_{q=0}^{n-1}E[T(q)]
             + \frac{1}{n}\sum_{q=0}^{n-1}E[T(q)]
             + \Theta(n) \NR
\NC         \NC= \frac{2}{n}\sum_{q=0}^{n-1}E[T(q)] + \Theta(n) \NR
\NC         \NC= \frac{2}{n}\sum_{q=2}^{n-1}E[T(q)]
             + \frac{2E[T(0)]}{n}
             + \frac{2E[T(1)]}{n}
             + \Theta(n) \NR
\NC         \NC= \frac{2}{n}\sum_{q=2}^{n-1}E[T(q)] + \Theta(n)
\stopmathalignment\stopformula
\stopANSWER

\startitem
證明：
\placeformula[formula:7_7]
\startformula
\sum_{k=2}^{n-1}k\lg{k} \le \frac{1}{2}n^2\lg{n} - \frac{1}{8}n^2
\stopformula
（\hint 以將其分成兩部分，一部分是 \m{k=2,3,\ldots,\lceil n/2\rceil-1}，
另一部分是 \m{k=\lceil n/2 \rceil,\ldots,n-1}。）
\stopitem

\startANSWER
\startformula\startmathalignment
\NC \sum_{k=2}^{n-1}k\lg{k}
   \NC=   \sum_{k=2}^{\lceil n/2 \rceil - 1}k\lg{k} + \sum_{k=\lceil n/2 \rceil}^{n - 1}k\lg{k} \NR
\NC\NC\le \sum_{k=2}^{n/2}k\lg{k} + \sum_{k=n/2 + 1}^{n}k\lg{k} \NR
\NC\NC\le \sum_{k=2}^{n/2}k\lg(n/2) + \sum_{k=n/2 + 1}^{n}k\lg{n} \NR
\NC\NC=   \lg(n/2)\sum_{k=2}^{n/2}k\ + \lg{n}\sum_{k=n/2 + 1}^{n}k \NR
\NC\NC=   (\lg{n} - \lg{2})\left(\frac{(n/2)(n/2 + 1)}{2}\right) +
          \lg{n}\left(\frac{n(n+1)}{2} - \frac{(n/2)(n/2 + 1)}{2}\right) \NR
\NC\NC=   \lg{n}\frac{n(n+1)}{2} - \frac{(n/2)(n/2 + 1)}{2} \NR
\NC\NC=   \frac{1}{2}\lg{n}(n^2 + 2n + 1) - \frac{1}{8}(n^2 + 2n + 1/8) \NR
\NC\NC=   \frac{1}{2}n^2\lg{n} - \frac{1}{8}n^2 - \frac{8n\lg{n} + 4\lg{n} - 2n - 1/8}{8} \NR
\NC\NC\le \frac{1}{2}n^2\lg{n} - \frac{1}{8}n^2 \NR
\stopmathalignment\stopformula
\stopANSWER

\startitem
利用\refformula{7_7} 給出的界證明：\refformula{7_6} 中的遞迴式有解 \m{E[T(n)]=\Theta(n\lg{n})}。
（\hint 用代入法，證明對於某個正常數 \m{a} 和足夠大的 \m{n}，有 \m{E[T(n)]\le an\lg{n}}。）
\stopitem

\startANSWER
猜測 \m{E[T(n)] \le an\lg{n}}：
\startformula\startmathalignment
\NC E[T(n)]
   \NC=   \frac{2}{n}\sum_{q=2}^{n-1}E[T(q)] + \Theta(n) \NR
\NC\NC\le \frac{2}{n}\sum_{q=2}^{n-1}aq\lg{q} + \Theta(n) \qquad \text{（根據猜測）} \NR
\NC\NC\le \frac{2a}{n}\left(\frac{1}{2}n^2\lg{n} - \frac{1}{8}n^2\right)
                 + \Theta(n) \qquad \text{（\refformula{7_7}）} \NR
\NC\NC=   an\lg{n} - \frac{a}{4}n + \Theta(n) \qquad \text{（根據 \m{\Theta} 記號的定義）} \NR
\NC\NC\le an\lg{n} \NR
\stopmathalignment\stopformula
\stopANSWER
\stopigBase
\stopPROBLEM

\startPROBLEM
（Stack depth for quicksort）
\refsection{desc_quicksort} 中的 \ALGO{QUICKSORT} 算法包含了兩個對其自身的遞迴調用。
在調用 \ALGO{PARTITION} 後， \ALGO{QUICKSORT} 分別遞迴調用了左邊的子數列和右邊的子數列。
 \ALGO{QUICKSORT} 中的第二個遞迴調用並不是必須的。
我們可以用一個循環控制結構來代替他。
這一技術稱爲{\EMP 尾遞迴}，好的編譯器都提供這一功能。
考慮廈門這個版本的快速排序，他模擬了尾遞迴的情況：

\CLRSH{TAIL-RECURSIVE-QUICKSORT(A, p, r)}
\startCLRS
while p < r
	// Partition and sort left subarray.
	q = PARTITION(A, p, r)
	TAIL-RECURSIVE-QUICKSORT(A, p, q-1)
	p = q + 1
\stopCLRS

\startigBase[a]
\startitem
證明： \ALGO{TAIL-RECURSIVE-QUICKSORT(A, 1, A.length)} 能正確地對數列 \m{A} 進行排序。
\stopitem

\startANSWER
原 \ALGO{QUICKSORT} 將數列劃分成兩部分，並對其分別遞迴調用自身。
而這個版本所做的事情是一樣的，只是方式不同，不是調用 \ALGO{TAIL-RECURSIVE-QUICKSORT}，
而是改變 \m{p}，繼續循環。
\stopANSWER
\stopigBase

編譯器通常試用{\EMP 棧}來存儲遞迴過程中的相關信息，
包括每一次遞迴調用的參數等。
最新調用的信息存在棧的頂部；
當他結束時，其信息則被{\EMP 彈出}。
因爲我們假設數列參數是用指針來指示的，所以每次過程調用只需要 \m{O(1)} 的棧空間。
{\EMP 棧深度}是在一次計算仲會用到的棧空間的最大值。
\startigBase[a,continue]
\startitem
請描述一個場景，使得針對一個包含 \m{n} 個元素數列的 \ALGO{TAIL-RECURSIVE-QUICKSORT} 的
棧深度爲 \m{\Theta(n)}。
\stopitem

\startANSWER
如果 \ALGO{PARTITION} 返回的一直是 \m{r}，則棧深度爲 \m{\Theta(n)}。
在數列已經排好序時就會出現這種情況。
\stopANSWER

\startitem
修改 \ALGO{TAIL-RECURSIVE-QUICKSORT} 的代碼，
使其最壞請看下棧深度爲 \m{\Theta(\lg{n})}，
並且能夠保持 \m{O(n\lg{n})} 的期望時間複雜度。
\stopitem

\startANSWER
如果每次針對較大的子數列進行尾遞迴，則能滿足要求。

\CLRSH{TAIL-RECURSIVE-QUICKSORT‘(A, p, r)}
\startCLRS
while p < r
	// Partition and sort left subarray.
	q = PARTITION(A, p, r)
	if q < (p + r) / 2
		TAIL-RECURSIVE-QUICKSORT’(A, p, q-1)
		p = q + 1
	else
		TAIL-RECURSIVE-QUICKSORT’(A, q+1, r)
		r = q - 1
\stopCLRS
\stopANSWER
\stopigBase
\stopPROBLEM

\startPROBLEM
（Median-of-3 partition）
一種改進 \ALGO{RANDOMIZED-QUICKSORT} 的方法就是在劃分時，
從子數列中更細緻地選擇主元（而不是簡單的隨機選擇）。
通常用的是三數取中法：
從字數列仲隨機選出三個元素，取其中位數作爲主元（參見\refexercise{random_three_median}）。
對於這個問題的分析，我們不妨假設數列 \m{A[1..n]} 的元素是互異的且有 \m{n\ge 3}。
我們用 \m{A'[1..n]} 來表示已排好序的數列。
用三數取中法選擇主元 \m{x}，並定義 \m{p_i=\Pr\{x=A'[i]\}}。
\startigBase[a]
\startitem
對於 \m{i=2,3,\ldots,n-1}，請給出以 \m{n} 和 \m{i} 表示的 \m{p_i} 的準確表達式（注意 \m{p_1=p_n=0}）。
\stopitem

\startANSWER
共有 \m{n!/(n-3)!} 種三元素排列。如果中位數是第 \m{i} 小元素，
則需要有一個小於他的元素，一個大於他的元素。
小於他的元素有 \m{i-1} 個，大於他的有 \m{n-i} 個。
這三個元素共有 \m{3!} 種選取順序。因此：
\startformula
p_i = \frac{6(i-1)(n-i)}{n(n-1)(n-2)}
\stopformula
\stopANSWER

\startitem
與普通實現相比，在這種實現中，選擇 \m{x=A'\left[\left\lfloor (n+1)/2 \right\rfloor\right]} （即 \m{A[1..n]} 的中位數）
的值作爲主元的概率增加了多少？
假設 \m{n\to\infty}，請給出這一概率的極限值。
\stopitem

\startANSWER
\startformula
\lim_{n \to \infty}\frac{6(i-1)(n-i)}{n(n-1)(n-2)}/\frac{1}{n}
 = \lim_{n \to \infty}\frac{6n(n/2 - 1)(n/2)}{n(n-1)(n-2)}
 = \lim_{n \to \infty}\frac{6(n^2 - 2n)}{4(n^2 - 3n + 2)}
 = \frac{6}{4}
\stopformula
概率變爲原來的 1.5 倍，變化不大。
\stopANSWER

\startitem
如果我們定義一個“好”的劃分意味着選擇 \m{x=A'[i]} 作爲主元，其中 \m{n/3\le i\le 2n/3}。
與普通實現相比，這種實現仲得到一個好的劃分的概率增加了多少？
（\hint 積分來近似累加和）
\stopitem

\startANSWER
由\refexercise{const_part_probability}可知，
普通實現中得到“好”的劃分的概率爲 \m{1-2(1/3)=1/3}。
而三數取中法可將概率變爲：
\startformula\startmathalignment
\NC \lim_{n \to \infty}\sum_{i=n/3}^{2n/3}\frac{6(i-1)(n-i)}{n(n-1)(n-2)}
   \NC= \lim_{n \to \infty}\frac{6}{n(n-1)(n-2)}\sum_{i=n/3}^{2n/3}(i-1)(n-i) \NR
\NC\NC= \lim_{n \to \infty}\binom{n}{3}\int_{n/3}^{2n/3}(i-1)(n-i)\mathrm{d}i \NR
\NC\NC  \qquad \left( \int(i-1)(n-i)\mathrm{d}i = \frac{1}{6}(3ni^2 - 6ni - 2i^3 + 3i^2) \right) \NR
\NC\NC= \lim_{n \to \infty}\binom{n}{3}\frac{1}{6}\left[
          \frac{36}{27}n^3 - \frac{16}{27}n^3 + o(n^3) -
          \frac{9}{27}n^3 + \frac{2}{27}n^3 + o(n^3)
        \right] \NR
\NC\NC= \lim_{n \to \infty}\frac{1}{n(n-1)(n-2)} \frac{13}{27}(n^3 + o(n^3)) \NR
\NC\NC= \lim_{n \to \infty}\frac{13}{27}\frac{n^3 + o(n^3)}{n^3 + o(n^3)} \NR
\NC\NC= \frac{13}{27} \NR
\stopmathalignment\stopformula

\m{n} 增大時，概率收斂爲 \m{13/27}，是普通實現的 \m{\frac{13}{27} \div \frac{1}{3} = \frac{39}{27} \approx 1.444(4)} 倍。
\stopANSWER

\startitem
證明：對快速排序而言，三數取中法只影響其時間複雜度 \m{\Omega(n\lg{n})} 的常數項因子。
\stopitem

\startANSWER
如果新的方法總能得到“好”的劃分，則會減少運行時間。然而，他不能。
新方法只能保證無論怎樣劃分，都不會出現空的子數列，但是仍會出現 \m{1:(n-2)} 的劃分。
他提升了“好”的劃分的概率，同時也增加了選擇主元的開銷，
但無法保證劃分的質量。
因此算法的時間複雜度仍然爲 \m{\Omega(n\lg{n})} 和 \m{O(n^2)}。
\stopANSWER
\stopigBase
\stopPROBLEM

\startPROBLEM
（Fuzzy sorting of intervals）
考慮這樣一種排序問題：我們無法準確知道待排序的數字是什麼，
但是對於每一個數，我們知道他屬於實數數軸上的某個區間。
也就是說，我們得到了 \m{n} 個形如 \m{[a_i,b_i]} 的閉區間，其中 \m{a_i\le b_i}。
我們的目標是實現這些區間的{\EMP 模糊排序}，
即對 \m{j=1,2,\ldots,n} 生成一個區間的排列 \m{\langle i_1,i_2,\ldots,i_n\rangle}，
且存在 \m{c_j \in [a_{i_j}, b_{i_j}]}，滿足 \m{c_1\le c_2\le\ldots\le c_n}。
\startigBase[a]
\startitem
爲 \m{n} 個區間的模糊排序設計一個隨機算法。
你的算法應該具有算法的一般結構，他可以對左邊端點（即 \m{a_i} 的值）進行快速排序，
同時他也能利用區間的重疊性質來改善時間性能。
（當區間重疊越來越多的時候，區間的模糊排序問題變得越來越容易。
你的算法應充分利用這一重疊性質。）
\stopitem

\startANSWER
與\refproblem{quicksort_with_equal} 類似。
在（隨機）選擇主元區間後，檢查與其他區間是否重疊。
具體而言，累計主區間和其他區間的重疊區間。
然後用此區間進行比較，而不是用主元進行比較。
比較時，凡是包含此區間的其他區間都可以認爲是相等的。
在將主區間左邊的區間排列完畢後，可以將相等的區間全部放到主元的右邊。
與\refproblem{quicksort_with_equal} 類似，返回兩個點（區間）用來進行遞迴。

即使劃分時需要掃描三次子數列（最壞情況），整個算法仍然是線性的。
\stopANSWER

\startitem
證明：在一般情況下，你的算法期望運行時間爲 \m{\Theta(n\lg{n})}。
但是，當所有的區間都有重疊的時候，算法的期望運行時間爲 \m{\Theta(n)}。
也就是說，存在一個值 \m{x}，對所有的 \m{i}，都有 \m{x\in [a_i,b_i]}。
你的算法不必顯式地檢查這種情況，
而是隨着重疊情況的增加，算法的性能自然地提高。
\stopitem

\startANSWER
\CLRSH{FUZZY-PARTITION(A, p, r)}
\startCLRS
x = A[r]
// find the minimus interval for pivot
for j = p to r - 1
	if x.left <= A[j].right and A[j].right < x.right
		x.right = A[j].right
	if x.left < A[j].left and A[j].left <= x.right
		x.left = A[j].left

q = p - 1
t = q
for j = p to r - 1
	if A[j].right <= x.right
		if A[j].right = x.right
			q = q + 1
			exchange A[q] with A[j]
		t = t + 1
		exchange A[t] with A[j]
q = q + 1
t = t + 1
exchange A[t] with A[r]

return q, t
\stopCLRS
\stopANSWER
\stopigBase
\stopPROBLEM

\stopchapter
\stopcomponent

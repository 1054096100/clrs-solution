\startcomponent c_all_pairs_shortest_paths

\startchapter[
  title={All-Pairs Shortest Paths},
]

\startsection[
  title={Shortest paths and matrix multiplication},
  reference=section:25.1,
]

%e25.1-1
\startEXERCISE
圖 25-2 爲一帶權重有向圖，
在其上運行算法 \ALGO{SLOW-ALL-PAIRS-SHORTEST-PATHS}。
給出循環的每次迭代所計算出的矩陣。
然後用算法 \ALGO{FASTER-ALL-PAIRS-SHORTEST-PATHS} 重新做一遍。
附圖 25-2：

\externalfigure[output/e25_1_1-1]
\stopEXERCISE

\startANSWER
慢速版本：

\startcombination[2*3]
{\startformula

L^{(1)} = \left(\startmatrix
\NC 0\NC \infty\NC \infty\NC \infty\NC -1\NC \infty \NR
\NC 1\NC 0\NC \infty\NC 2\NC \infty\NC \infty \NR
\NC \infty\NC 2\NC 0\NC \infty\NC \infty\NC -8 \NR
\NC -4\NC \infty\NC \infty\NC 0\NC 3\NC \infty \NR
\NC \infty\NC 7\NC \infty\NC \infty\NC 0\NC \infty \NR
\NC \infty\NC 5\NC 10\NC \infty\NC \infty\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

L^{(2)} = \left(\startmatrix
\NC 0\NC 6\NC \infty\NC \infty\NC -1\NC \infty \NR
\NC -2\NC 0\NC \infty\NC 2\NC 0\NC \infty \NR
\NC 3\NC -3\NC 0\NC 4\NC \infty\NC -8 \NR
\NC -4\NC 10\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 8\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 6\NC 5\NC 10\NC 7\NC \infty\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

L^{(3)} = \left(\startmatrix
\NC 0\NC 6\NC \infty\NC 8\NC -1\NC \infty \NR
\NC -2\NC 0\NC \infty\NC 2\NC -3\NC \infty \NR
\NC -2\NC -3\NC 0\NC -1\NC 2\NC -8 \NR
\NC -4\NC 2\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 5\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 3\NC 5\NC 10\NC 7\NC 5\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

L^{(4)} = \left(\startmatrix
\NC 0\NC 6\NC \infty\NC 8\NC -1\NC \infty \NR
\NC -2\NC 0\NC \infty\NC 2\NC -3\NC \infty \NR
\NC -5\NC -3\NC 0\NC -1\NC -3\NC -8 \NR
\NC -4\NC 2\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 5\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 3\NC 5\NC 10\NC 7\NC 2\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

L^{(5)} = \left(\startmatrix
\NC 0\NC 6\NC \infty\NC 8\NC -1\NC \infty \NR
\NC -2\NC 0\NC \infty\NC 2\NC -3\NC \infty \NR
\NC -5\NC -3\NC 0\NC -1\NC -6\NC -8 \NR
\NC -4\NC 2\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 5\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 3\NC 5\NC 10\NC 7\NC 2\NC 0 \NR
\stopmatrix\right)

\stopformula}{}
{}{}
\stopcombination

快速版本：

\startcombination[2*2]
{\startformula

L^{(1)} = \left(\startmatrix
\NC 0\NC \infty\NC \infty\NC \infty\NC -1\NC \infty \NR
\NC 1\NC 0\NC \infty\NC 2\NC \infty\NC \infty \NR
\NC \infty\NC 2\NC 0\NC \infty\NC \infty\NC -8 \NR
\NC -4\NC \infty\NC \infty\NC 0\NC 3\NC \infty \NR
\NC \infty\NC 7\NC \infty\NC \infty\NC 0\NC \infty \NR
\NC \infty\NC 5\NC 10\NC \infty\NC \infty\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

L^{(2)} = \left(\startmatrix
\NC 0\NC 6\NC \infty\NC \infty\NC -1\NC \infty \NR
\NC -2\NC 0\NC \infty\NC 2\NC 0\NC \infty \NR
\NC 3\NC -3\NC 0\NC 4\NC \infty\NC -8 \NR
\NC -4\NC 10\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 8\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 6\NC 5\NC 10\NC 7\NC \infty\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

L^{(4)} = \left(\startmatrix
\NC 0\NC 6\NC \infty\NC 8\NC -1\NC \infty \NR
\NC -2\NC 0\NC \infty\NC 2\NC -3\NC \infty \NR
\NC -5\NC -3\NC 0\NC -1\NC -3\NC -8 \NR
\NC -4\NC 2\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 5\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 3\NC 5\NC 10\NC 7\NC 2\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

L^{(8)} = \left(\startmatrix
\NC 0\NC 6\NC \infty\NC 8\NC -1\NC \infty \NR
\NC -2\NC 0\NC \infty\NC 2\NC -3\NC \infty \NR
\NC -5\NC -3\NC 0\NC -1\NC -6\NC -8 \NR
\NC -4\NC 2\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 5\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 3\NC 5\NC 10\NC 7\NC 2\NC 0 \NR
\stopmatrix\right)

\stopformula}{}
\stopcombination
\stopANSWER

%e25.1-2
\startEXERCISE
爲什麼要求對於所有 \m{1\le i\le n}，必須滿足 \m{\omega_{ii} = 0}？
\stopEXERCISE

\startANSWER
這樣才能保證遞歸式 25.2 的正確性。附遞歸式 25.2：
\startformula
l_{ij}^{(m)} = \min(l_{ij}^{(m-1)}, \min_{1\le k\le n}\{l_{ik}^{(m-1)} + \omega_{kj}\})
=\min_{1\le k\le n}\{l_{ik}^{(m-1)} + \omega_{kj}\}
\stopformula
\stopANSWER

%e25.1-3
\startEXERCISE
在最短路徑算法中使用的矩陣 \m{L^{(0)}} 對應傳統矩陣乘法裏的什麼？
\startformula
L^{(0)} = \left(\startmatrix
\NC 0 \NC \infty \NC \infty \NC \ldots \NC \infty \NR
\NC \infty \NC 0 \NC \infty \NC \ldots \NC \infty \NR
\NC \infty \NC \infty \NC 0 \NC \ldots \NC \infty \NR
\NC \vdots \NC \vdots \NC \vdots \NC \ddots \NC \vdots \NR
\NC \infty \NC \infty \NC \infty \NC \ldots \NC 0 \NR
\stopmatrix\right)
\stopformula
\stopEXERCISE

\startANSWER
單位矩陣。將單位矩陣中加法所用的 \m{0} 換成 \m{\min} 所用的 \m{\infty}，
將乘法所用的 \m{1} 換成加法所用的 \m{0}。
\startformula
I = \left(\startmatrix
\NC 1 \NC 0 \NC 0 \NC \ldots \NC 0 \NR
\NC 0 \NC 1 \NC 0 \NC \ldots \NC 0 \NR
\NC 0 \NC 0 \NC 1 \NC \ldots \NC 0 \NR
\NC \vdots \NC \vdots \NC \vdots \NC \ddots \NC \vdots \NR
\NC 0 \NC 0 \NC 0 \NC \ldots \NC 1 \NR
\stopmatrix\right)
\stopformula
\stopANSWER

%e25.1-4
\startEXERCISE
證明：由 \ALGO{EXTEND-SHORTEST-PATHS} 所定義的矩陣乘法滿足結合律。
\stopEXERCISE

\startANSWER
\m{\min} 和 \m{+} 都滿足結合律。
\stopANSWER

%e25.1-5
\startEXERCISE
說明如何將單源最短路徑問題表示爲矩陣和向量的乘積，
並解釋該乘積的計算過程如何對應 \ALGO{BELLMAN-FORD} 算法？
（請參閱\refsection{24.1}）
\stopEXERCISE

\startANSWER
\startformula
L^{(n-1)} = W^{n-1} = L^{(0)}\cdot W^{n-1}
\stopformula
其中 \m{L^{(0)}} 是單位矩陣， \m{l_{ij}^{(n-1)} = \delta(i,j)}。
即矩陣中第 \m{i} 行第 \m{j} 列的元素表示
從第 \m{i} 個節點到第 \m{j} 個節點的最短路徑權重。
第 \m{i} 行元素表示從第 \m{i} 個節點出發到達其他各個節點的最短路徑權重。

矩陣“相乘” \m{C=A\cdot B}，
 \m{C} 中第 \m{i} 行元素是由 \m{A} 中第 \m{i} 行元素“乘以”矩陣 \m{B} 得到。
由於我們只需要 \m{C} 中第 \m{i} 行元素，因此也只需要 \m{A} 中第 \m{i} 行元素。

所以源節點爲 \m{i} 的單源最短路徑就是 \m{L_{i}^{(0)} \cdot W^{n-1}}，
其中 \m{L_{i}^{(0)}} 就是 \m{L^{(0)}} 的第 \m{i} 行元素，是一個向量，
此向量中第 \m{i} 個元素是 \m{0}，其他元素都是 \m{\infty}。

自左至右進行“乘法”操作與 \ALGO{BELLMAN-FORD} 的運行過程一樣。
向量對應的就是 \ALGO{BELLMAN-FORD} 算法中的 \m{d}。

\startigBase[2]
\item 一開始向量中只有源節點所處位置元素爲 \m{0}，其他均爲 \m{\infty}，
與 \ALGO{INITIALIZE-SINGLE-SOURCE} 相同。
\item 每次向量“乘以” \m{W} 就會對所有邊進行一遍鬆弛操作。
\item 一共執行 \m{n-1} 次乘法，即 \m{n-1} 邊鬆弛操作。
\stopigBase
\stopANSWER

%e25.1-6
\startEXERCISE
假定我們還希望在本節討論的算法裏計算出最短路徑上的節點。
說明如何在 \m{O(n^3)} 時間內從已經計算出的
最短路徑權重矩陣 \m{L} 計算出前驅矩陣 \m{\prod}。
\stopEXERCISE

\startANSWER
\startCLRS
for each edge (u,v) in G.E
	for s in G.V
		if L[s][u] + w(u,v) == L[s][v]
			PI[s][v] = u
\stopCLRS
\stopANSWER

%e25.1-7
\startEXERCISE
我們可以用計算最短路徑權重的辦法來計算最短路徑上的節點。
定義 \m{\pi_{ij}^{(m)}} 爲從 \m{i} 到 \m{j} 的至多
包含 \m{m} 條邊的任意最小權重路徑上節點 \m{j} 的前驅。
請修改 \ALGO{EXTEND-SHORTEST-PATHS} 和 \ALGO{SLOW-ALL-PAIRS-SHORTEST-PATHS}，
使其在計算出矩陣 \m{L^{(1)},L^{(2)},\ldots,L^{(n-1)}} 的同時，
計算出矩陣 \m{\prod^{(1)},\prod^{(2)},\ldots,\prod^{(n-1)}}。
\stopEXERCISE

\startANSWER
更新 \m{L} 的同時更新對應的 \m{\prod} 即可。
\stopANSWER

%e25.1-8
\startEXERCISE
本節討論的 \ALGO{FASTER-ALL-PAIRS-SHORTEST-PATHS} 要求
我們保存 \m{\lceil \lg (n-1)\rceil} 個矩陣，
由於每個矩陣有 \m{n^2} 個元素，總存儲空間需求爲 \m{\Theta(n^2\lg n)}。
請修改算法，使其僅僅使用兩個 \m{n\times n} 矩陣，
從而將存儲空間降至 \m{\Theta(n^2)}。
\stopEXERCISE

\startANSWER
\CLRSH{FASTER-ALL-PAIRS-SHORTEST-PATHS(W)}
\startCLRS
n = W.rows
L[1] = W
m = 1
i = 1
while m < n-1
	L[(i+1) mod 2] = EXTEND-SHORTEST-PATHS(L[i mod 2],L[i mod 2])
	m = 2m
	i = i + 1
return L[i mod 2]
\stopCLRS
\stopANSWER

%e25.1-9
\startEXERCISE
修改 \ALGO{FASTER-ALL-PAIRS-SHORTEST-PATHS}，
使其可以判斷一個圖是否包含負權重環路。
\stopEXERCISE

\startANSWER
爲算法添加以下內容，若返回 FALSE 則代表有負權重環路，否則沒有：
\startCLRS
for i = 1 upto n
	for each edge(u,v) in G.E
		if L[i][v] > L[i][u] + w(u,v)
			return FALSE
return TRUE
\stopCLRS
或者也可以通過判斷對角線上的元素是否有負值，
不過需要計算 \m{W^n}，而不是 \m{W^{n-1}}。
\stopANSWER

%e25.1-10
\startEXERCISE
給出一個有效算法，可以找出圖中所有負權重環路的最短長度（邊的條數）。
\stopEXERCISE

\startANSWER
在計算 \m{W^m} 時，一旦對角線出現負值， \m{m} 即爲所求。
\stopANSWER

\stopsection

\startsection[
  title={The Floyd-Warshall algorithm},
]

%e25.2-1
\startEXERCISE
在圖 25-2 所示的帶權重有向圖上運行算法 \ALGO{FLOYD-WARSHALL}，
給出外層循環的每一次迭代所成城的矩陣 \m{D^{(k)}}。
\stopEXERCISE

\startANSWER
\startcombination[2*3]
{\startformula

D^{(1)} = \left(\startmatrix
\NC 0\NC \infty\NC \infty\NC \infty\NC -1\NC \infty \NR
\NC 1\NC 0\NC \infty\NC 2\NC 0\NC \infty \NR
\NC \infty\NC 2\NC 0\NC \infty\NC \infty\NC -8 \NR
\NC -4\NC \infty\NC \infty\NC 0\NC -5\NC \infty \NR
\NC \infty\NC 7\NC \infty\NC \infty\NC 0\NC \infty \NR
\NC \infty\NC 5\NC 10\NC \infty\NC \infty\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

D^{(2)} = \left(\startmatrix
\NC 0\NC \infty\NC \infty\NC \infty\NC -1\NC \infty \NR
\NC 1\NC 0\NC \infty\NC 2\NC 0\NC \infty \NR
\NC 3\NC 2\NC 0\NC 4\NC 2\NC -8 \NR
\NC -4\NC \infty\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 8\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 6\NC 5\NC 10\NC 7\NC 5\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

D^{(3)} = \left(\startmatrix
\NC 0\NC \infty\NC \infty\NC \infty\NC -1\NC \infty \NR
\NC 1\NC 0\NC \infty\NC 2\NC 0\NC \infty \NR
\NC 3\NC 2\NC 0\NC 4\NC 2\NC -8 \NR
\NC -4\NC \infty\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 8\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 6\NC 5\NC 10\NC 7\NC 5\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

D^{(4)} = \left(\startmatrix
\NC 0\NC \infty\NC \infty\NC \infty\NC -1\NC \infty \NR
\NC -2\NC 0\NC \infty\NC 2\NC -3\NC \infty \NR
\NC 0\NC 2\NC 0\NC 4\NC -1\NC -8 \NR
\NC -4\NC \infty\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 5\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 3\NC 5\NC 10\NC 7\NC 2\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

D^{(5)} = \left(\startmatrix
\NC 0\NC 6\NC \infty\NC 8\NC -1\NC \infty \NR
\NC -2\NC 0\NC \infty\NC 2\NC -3\NC \infty \NR
\NC 0\NC 2\NC 0\NC 4\NC -1\NC -8 \NR
\NC -4\NC 2\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 5\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 3\NC 5\NC 10\NC 7\NC 2\NC 0 \NR
\stopmatrix\right)

\stopformula}{}{\startformula

D^{(6)} = \left(\startmatrix
\NC 0\NC 6\NC \infty\NC 8\NC -1\NC \infty \NR
\NC -2\NC 0\NC \infty\NC 2\NC -3\NC \infty \NR
\NC -5\NC -3\NC 0\NC -1\NC -6\NC -8 \NR
\NC -4\NC 2\NC \infty\NC 0\NC -5\NC \infty \NR
\NC 5\NC 7\NC \infty\NC 9\NC 0\NC \infty \NR
\NC 3\NC 5\NC 10\NC 7\NC 2\NC 0 \NR
\stopmatrix\right)

\stopformula}{}
\stopcombination
\stopANSWER

%e25.2-2
\startEXERCISE
說明如何使用\refsection{25.1} 的技術來計算傳遞閉包。
\stopEXERCISE

\startANSWER
將 \ALGO{EXTEND-SHORTEST-PATHS} 中的“\m{\min}”換成“\m{\lor}”，
將“\m{+}”換成“\m{\land}”。
\stopANSWER

%e25.2-3
\startEXERCISE
請修改 \ALGO{FLOYD-WARSHALL} 算法，
以便根據式 25.6 和 25.7 計算出矩陣 \m{\prod^{(k)}}。
再請嚴格證明：
對於所有節點 \m{i\in V}，
前驅子圖 \m{G_{\pi,i}} 是一棵根節點爲 \m{i} 的最短路徑樹。
（\hint 爲了證明 \m{G_{\pi,i}} 無環，
可以首先證明：根據 \m{G_{\pi,i}} 的定義，
 \m{\pi_{ij}^{(k)} = l} 蘊含 \m{d_{ij}^{(k)}\ge d_{il}^{(ik)} + \omega_{lj}}。
然後，再採用引理 24.16 的證明。）
附式 25.6：
\startformula
\pi_{ij}^{(0)} = \startcases
\NC NIL \MC \text{若 \m{i=j} 或 \m{\omega_{ij} = \infty}} \NR
\NC i \MC \text{若 \m{i\ne j} 且 \m{\omega_{ij} < \infty}} \NR
\stopcases
\stopformula

式 25.7：
\startformula
\pi_{ij}^{(k)} = \startcases
\NC \pi_{ij}^{(k-1)} \MC \text{若 \m{d_{ij}^{(k-1)} \le d_{ik}^{(k-1)} + d_{kj}^{(k-1)}}} \NR
\NC \pi_{kj}^{(k-1)} \MC \text{若 \m{d_{ij}^{(k-1)} > d_{ik}^{(k-1)} + d_{kj}^{(k-1)}}} \NR
\stopcases
\stopformula
\stopEXERCISE

\startANSWER
\CLRSH{FLOYD-WARSHALL(W)}
\startCLRS
n = W.rows
D[0] = W
for i = 1 to n
	for j = 1 to n
		if d[0][i][j] != infinity
			pi[0][i][j] = i
		else
			pi[0][i][j] = NIL
for k = 1 to n
	for i = 1 to n
		for j = 1 to n
			d[k][i][j] = min(d[k-1][i][j], d[k-1][i][k] + d[k-1][k][j])
			if d[k-1][i][j] <= d[k-1][i][k] + d[k-1][k][j]
				pi[k][i][j] = pi[k-1][i][j]
			else
				pi[k][i][j] = pi[k-1][k][j]
return D[n], Pi[n]
\stopCLRS

最短路徑樹的證明略。
\stopANSWER

%e25.2-4
\startEXERCISE
如前所述， \ALGO{FLOYD-WARSHALL} 的空間需求爲 \m{\Theta(n^3)}，
因爲要計算 \m{d_{ij}^{(k)}}，其中 \m{i,j,k=1,2,\ldots,n}。
請證明下面算法的正確性，下面算法跟 \ALGO{FLOYD-WARSHALL} 的區別就是沒有上標了，
其空間需求可以降低到 \m{\Theta(n^2)}。

\CLRSH{FLOYD-WARSHALL'(W)}
\startCLRS
n = W.rows
D = W
for k = 1 to n
	for i = 1 to n
		for j = 1 to n
			d[i][j] = min(d[i][j], d[i][k] + d[k][j])
return D
\stopCLRS
\stopEXERCISE

\startANSWER
就這個動態規劃算法而言，下一個狀態只跟上一個狀態有關，沒有必要保存其他狀態。
\stopANSWER

%e25.2-5
\startEXERCISE
假定我們修改式 25.7 對等式的處理辦法如下：
\startformula
\pi_{ij}^{(k)} = \startcases
\NC \pi_{ij}^{(k-1)} \MC \text{若 \m{d_{ij}^{(k-1)} < d_{ik}^{(k-1)} + d_{kj}^{(k-1)}}} \NR
\NC \pi_{kj}^{(k-1)} \MC \text{若 \m{d_{ij}^{(k-1)} \ge d_{ik}^{(k-1)} + d_{kj}^{(k-1)}}} \NR
\stopcases
\stopformula
請問這種前驅矩陣 \m{\prod} 的定義正確嗎？
\stopEXERCISE

\startANSWER
正確。
\stopANSWER

%e25.2-6
\startEXERCISE
我們怎樣才能使用 \ALGO{FLOYD-WARSHALL} 算法的輸出來檢測負權重環路？
\stopEXERCISE

\startANSWER
在算法最後再跑一遍循環，如果還有矩陣元素可以更新，則表明有負權重環路。
\stopANSWER

%e25.2-7
\startEXERCISE
在算法 \ALGO{FLOYD-WARSHALL} 中構建最短路徑的另一種辦法是使用 \m{\phi_{ij}^{(k)}}，
其中 \m{i,j,k=1,2,\ldots,n}，
 \m{\phi_{ij}^{(k)}} 是從節點 \m{i} 到節點 \m{j} 的最短路徑上編號最大的中間節點，
這條路徑上中間所有節點都取自集合 \m{\{1,2,\ldots,k\}}。
請給出 \m{\phi_{ij}^{(k)}} 的一個遞歸公式，
並修改 \ALGO{FLOYD-WARSHALL} 計算 \m{\phi_{ij}^{(k)}}。
然後重寫 \ALGO{PRINT-ALL-PAIRS-SHORTEST-PATH}，
其輸入爲矩陣 \m{\Phi=(\phi_{ij}^{(n)})}。
矩陣 \m{\Phi} 與\refsection{15.2} 所討論的鏈式矩陣乘法中的表格有哪些相似之處？
\stopEXERCISE

\startANSWER
\startformula
\phi_{ij}^{(k)} = \startcases
\NC \phi_{ij}^{(k-1)} \MC \text{若 \m{d_{ij}^{(k-1)} \le d_{ik}^{(k-1)} + d_{kj}^{(k-1)}}} \NR
\NC k \MC \text{若 \m{d_{ij}^{(k-1)} > d_{ik}^{(k-1)} + d_{kj}^{(k-1)}}} \NR
\stopcases
\stopformula

\CLRSH{PRINT-ALL-PAIRS-SHORTEST-PATH(\phi, i, j)}
\startCLRS
if i == j
	print i
else if phi[i][j] = NIL
	print no path from i to j exist
else
	PRINT-ALL-PAIRS-SHORTEST-PATH(phi, i, phi[i][j])
	print phi[i][j]
	PRINT-ALL-PAIRS-SHORTEST-PATH(phi, phi[i][j], i)
\stopCLRS
\stopANSWER

%e25.2-8
\startEXERCISE
給出一個 \m{O(VE)} 時間複雜度的算法來計算有向圖 \m{G=(V,E)} 的傳遞閉包。
\stopEXERCISE

\startANSWER
\startCLRS
for each vertex s in G.V
	R[s][s] = 1
for each edge (u,v) in G.E
	for each vertex s in G.V
		if R[s][u] = 1
			R[s][v] = 1
\stopCLRS
\stopANSWER

%e25.2-9
\startEXERCISE
假定我們可以在 \m{f(|V|,|E|)} 的時間內計算出一個有向無環圖的傳遞閉包，
其中 \m{f} 是一個自變量爲 \m{|V|} 和 \m{|E|} 的單調遞增函數。
證明：對於一個常規的有向圖 \m{G=(V,E)}，計算其傳遞閉包 \m{G^*=(V,E^*)} 的
時間複雜度爲 \m{f(|V|,|E|)+O(V+E^*)}。
\stopEXERCISE

\startANSWER
先計算 \m{G} 的強連通分量圖 \m{G_{SCC}}，用時 \m{O(V+E)}。
在這個過程中需要記錄 \m{G} 中的節點與 \m{G_{SCC}} 中節點的關係，
對於 \m{G} 中任一節點 \m{v}，都可以通過一個函數 \m{g(v)} 得到 \m{G_{SCC}} 中與其對應的節點。

然後在圖 \m{G_{SCC}} 上運行算法找到其傳遞閉包。
用時 \m{O(f(|V|,|E|)}。
剩下的就是將 \m{G_{SCC}} 的傳遞閉包轉換回 \m{G} 的傳遞閉包。

當且僅當 \m{G} 的傳遞閉包中有邊 \m{(u,v)} 時，
 \m{G_{SCC}} 的傳遞閉包中纔有 \m{(g(u),g(v)}。
據此，我們可以遍歷 \m{G_{SCC}} 的傳遞閉包中的邊 \m{(a,b)}，
對於每個邊 \m{(a,b)}，找到所有的 \m{x\in g^{-1}(a)} 和 \m{y\in g^{-1}(b)}。
那麼 \m{(x,y)} 就屬於 \m{E^*}。用時爲 \m{O(E^*)}。

由於 \m{E<E^*}，所以總時間爲 \m{O(V+E) + O(f(|V|,|E|)) + O(E^*) = O(f(|V|,|E|) + V + E^*)}。
\stopANSWER

\stopsection

\startsection[
  title={Johnson’s algorithm for sparse graphs},
]

%e25.3-1
\startEXERCISE
請在圖 25-2 上使用 Johnson 算法來找到所有節點對之間的最短路徑。
給出算法計算出 \m{h} 和 \m{\hat{\omega}}。附圖 25-2：

\externalfigure[output/e25_3_1-1]
\stopEXERCISE

\startANSWER
\startcombination[2*1]
{\startformula
h = \left(\startmatrix
\NC 0 \NR
\NC -5 \NR
\NC -3 \NR
\NC 0 \NR
\NC -1 \NR
\NC -6 \NR
\NC -8 \NR
\stopmatrix\right)
\stopformula}{}

{\startformula
\hat{\omega} = \left(\startmatrix
\NC \infty\NC \infty\NC \infty\NC \infty\NC 0\NC \infty \NR
\NC 3\NC \infty\NC \infty\NC 0\NC \infty\NC \infty \NR
\NC \infty\NC 5\NC \infty\NC \infty\NC \infty\NC 0 \NR
\NC 0\NC \infty\NC \infty\NC \infty\NC 8\NC \infty \NR
\NC \infty\NC 4\NC \infty\NC \infty\NC \infty\NC \infty \NR
\NC \infty\NC 0\NC 2\NC \infty\NC \infty\NC \infty \NR
\stopmatrix\right)
\stopformula}{}
\stopcombination
\stopANSWER

%e25.3-2
\startEXERCISE
在算法 \ALGO{JOHNSON} 裏，給集合 \m{V} 加入了新節點 \m{s}，
形成了新集合 \m{V'}，這樣做的目的是什麼？
\stopEXERCISE

\startANSWER
爲了使所有節點都可達。
\stopANSWER

%e25.3-3
\startEXERCISE
假定對於所有的邊 \m{(u,v)\in E}，
我們有 \m{\omega(u,v)\ge 0}。
請問權重函數 \m{\omega} 和 \m{\hat{\omega}} 之間是什麼關係？
\stopEXERCISE

\startANSWER
\m{h(u)=h(v)=0}， \m{\omega=\hat{\omega}}。
\stopANSWER

%e25.3-4
\startEXERCISE
Greenstreet 教授聲稱，
他有一種新方法給邊的權重重新賦值，比 \ALGO{JOHNSON} 算法中的更簡單。
設 \m{\omega^*=\min_{(u,v)\in E}\{\omega(u,v)\}}，
只要對所有的邊 \m{(u,v)\in E}，
定義 \m{\hat{\omega}(u,v)=\omega(u,v)-\omega^*} 即可。
請問這種方法錯在哪？
\stopEXERCISE

\startANSWER
這樣 \m{\hat{\omega}(p)=\omega(p)-(k-1)\omega^*}，
也就是說與路徑上的邊數有關了。
對於一個路徑而言， \m{\omega^*} 最小，不能說明這條路徑最短。
\stopANSWER

%e25.3-5
\startEXERCISE
假定在一個權重函數爲 \m{\omega} 的有向圖 \m{G} 上運行 \ALGO{JOHNSON}。
證明：如果圖 \m{G} 包含一條權重爲 0 的環路 \m{c}，
那麼對於環路 \m{c} 上的每條邊 \m{(u,v)}， \m{\hat{\omega}(u,v)=0}。
\stopEXERCISE

\startANSWER
\startformula\startmathalignment
\NC \delta(s,v) \le \NC \delta(s,u) + \omega(u,v) \NR
\NC \delta(s,u) \le \NC \delta(s,v) + (0 - \omega(u,v)) \NR
\stopmathalignment\stopformula
根據上面兩式，有 \m{\delta(s,v) = \delta(s,u) + \omega(u,v)}。
因此 \m{\hat{\omega(u,v)} = \omega(u,v) + \delta(s,u) - \delta(s,v) = 0}。
\stopANSWER

%e25.3-6
\startEXERCISE
Michener 教授聲稱，
沒有必要在 \ALGO{JOHNSON} 的第 1 行創建一個新的源節點。
他主張可以使用 \m{G'=G}，並設 \m{s} 爲任意節點。
請給出一個帶權重的有向圖例子，
如果按這種方法做會導致錯誤的結果。
然後證明：如果圖 \m{G} 是強連通的（每個節點都可以從其他每個節點到達），
那麼使用這位教授的方法不影響結果的正確性。
\stopEXERCISE

\startANSWER
假定 \m{\infty-\infty} 未定義，而不是 0。
令 \m{G=(V,E)}，其中 \m{V=\{s,u\}}， \m{E=\{(u,s)\}}，
且 \m{\omega(u,s)=0}。也就是說 \m{G} 中只有一條邊。

從 \m{s} 開始運行 \ALGO{BELLMAN-FORD} 時，
 \m{h(s)=\delta(s,s)=0}， \m{h(u)=\delta(s,u)=\infty}。
在重新給權重賦值時， \m{\hat{\omega}(u,s)=0+\infty-0=\infty}。
從而計算出 \m{\hat{\delta}(u,s)=\infty}， \m{d_{us}=\infty+0-\infty\ne 0}。
但由於 \m{\delta(u,s)=0}，所以結果是錯的。

而如果 \m{G} 是強連通的，則對於所有節點 \m{v\in V}，
都有 \m{h(v)=\delta(s,v)<\infty}。
因此，根據三角不等式，對於所有 \m{(u,v)\in E}，
都有 \m{h(v)\le h(u)+\omega(u,v)}，從而有 \m{\hat{\omega}(u,v)=\omega(u,v)+h(u)-h(v)\ge 0}。
滿足算法 \ALGO{JOHNSON} 的要求。
後面 \m{\hat{\delta}(u,v)<\infty} 對所有 \m{(u,v)\in E} 也成立。
最後 \m{d_{uv}=\hat{\delta}(u,v)+h(v)-h(u) < \infty} 也成立。
\stopANSWER

\stopsection

\startsubject[
  title={Problems},
]

%p25-1
\startPROBLEM
（Transitive closure of a dynamic graph）
假定我們希望給有向圖 \m{G=(V,E)} 插入新邊的時候維持其傳遞閉包，
即在插入每條邊後，更新圖的傳遞閉包。
假定圖 \m{G} 開始時不包含任何邊，並且傳遞閉包用布爾矩陣來表示。
\startigBase[a]\startitem
說明給圖 \m{G} 加入一條新邊時，
如何在 \m{O(V^2)} 時間內更新圖 \m{G=(V,E)} 的傳遞閉包 \m{G^*=(V,E^*)}。
\stopitem\stopigBase

\startANSWER
令 \m{T} 爲圖 \m{G} 的傳遞閉包矩陣：
\startformula
T[i,j] = \startcases
\NC 1 \MC if i = j \NR
\NC 0 \MC otherwise \NR
\stopcases
\stopformula

\CLRSH{TRANSITIVE-CLOSURE-UPDATE(u,v)}
\startCLRS
for i = 1 upto |V|
	for j = 1 upto |V|
		if T[i,u] == 1 and T[v,j] == 1
			T[i,j] = 1
\stopCLRS

\stopANSWER

\startigBase[continue]\startitem
給出一個圖 \m{G} 與一條邊 \m{e}，
使得將 \m{e} 插入 \m{G} 時，不管使用什麼算法，
更新其傳遞閉包的時間複雜度都是 \m{\Omega(V^2)}。
\stopitem\stopigBase

\startANSWER
假定圖 \m{G} 中只有一條從 \m{v_1} 到 \m{v_n} 的一條直線：
 \m{v_1\rightarrow v_2\rightarrow \ldots \rightarrow v_n}，
其中 \m{n=|V|}。在插入新邊之前， \m{T} 中只有 \m{n(n+1)/2} 個 \m{1}，
即對角線及上半部分的元素。
插入新邊後，變成了一個環路，任意兩點間均可達，
即 \m{T} 中會有 \m{n^2} 個 \m{1}。
新增加的 \m{1} 個數爲 \m{n^2-n(n+1)/2 = n(n-1)/2}。
因此無論用什麼算法時間都會是 \m{\Omega(n^2)}。
\stopANSWER

\startigBase[continue]\startitem
描述一個有效的算法，
使得在將邊加入到圖 \m{G} 中時更新傳遞閉包。
對於任意 \m{n} 次插入的序列，
算法總運行時間爲 \m{\sum_{i=1}^{n}t_i=O(V^3)}，
其中 \m{t_i} 是插入第 \m{i} 條邊時更新傳遞閉包所用的時間。
請證明你的算法確實達到了這個時間效率。
\stopitem\stopigBase

\startANSWER
如果用 a）中的方式插入 \m{\Theta(V^2)} 條邊，則總時間爲 \m{\Theta(V^4)}。

\CLRSH{TRANSITIVE-CLOSURE-UPDATE'(u,v)}
\startCLRS
for i = 1 upto |V|
	if T[i,u] == 1 and T[i,v] == 0
		for j = 1 upto |V|
			if T[v,j] == 1
				T[i,j] = 1
\stopCLRS

前兩行執行時間爲 \m{O(nV)=O(V^3)}。
後三行執行時間爲 \m{O(V)}，共執行 \m{O(V^2)} 次，
因爲這三行執行一遍至少會將 \m{T[i,v]} 改成 \m{1}，
而整個矩陣只有 \m{O(V^2)} 個元素，也就是說最後三行最多執行 \m{O(V^2)} 次。
所以總時間爲 \m{O(V^3)}。
\stopANSWER

%p25-2
\startPROBLEM
（Shortest paths in \m{\epsilon}-dense graphs）
對於圖 \m{G=(V,E)} 而言，如果 \m{|E|=\Theta(V^{1+\epsilon})}，
則圖 \m{G} 爲{\EMP \m{\epsilon} 稠密圖}，其中 \m{\epsilon} 爲某個常數，
且 \m{0<\epsilon \le 1}。
如果在 \m{\epsilon} 稠密圖的最短路徑算法中使用 \m{d} 叉最小堆
（請參閱\refproblem{6-2}），
則能使算法的運行時間相當於基於 Fibonacci 堆的算法的運行時間，
卻無需引入後者所用的複雜數據結構。

\startigBase[a]\startitem
\ALGO{INSERT}、 \ALGO{EXTRACT-MIN}、 \ALGO{DECREASE-KEY} 的漸進運行時間是多少？
請以 \m{d} 和元素個數 \m{n} 爲參數來表示。
如果選擇 \m{d=\Theta(n^\alpha)}，其中 \m{0<\alpha\le 1}，
這些運行時間又是多少？
與 Fibonacci 堆的攤還代價相比如何？
\stopitem\stopigBase

\startANSWER
\ALGO{INSERT}： \m{\Theta(\log_d n = \Theta(1/\alpha)}

\ALGO{EXTRACT-MIN}： \m{\Theta(d\log_d n) = \Theta(n^\alpha / \alpha)}

\ALGO{DECREASE-KEY}： \m{\Theta(\log_d n) = \Theta(1/\alpha)}
\stopANSWER

\startigBase[continue]\startitem
說明如何在 \m{O(E)} 時間內，
在一個 \m{\epsilon} 稠密的有向圖中計算除單源最短路徑，
這裏界定該圖不包含權重爲負值的邊。
（\hint 選一個以 \m{\epsilon} 爲自變量的函數作爲 \m{d}）
\stopitem\stopigBase

\startANSWER
用算法 \ALGO{DIJKSTRA}，如果 \m{d=V^\epsilon}，則：
\startformula\startmathalignment
\NC \NC O(d\log_d V\cdot V + \log_d V\cdot E) \NR
\NC = \NC O(V^\epsilon \cdot V/\epsilon + E / \epsilon) \NR
\NC = \NC O((V^{1+\epsilon} + E)/\epsilon) \NR
\NC = \NC O((E+E)/\epsilon) \NR
\NC = \NC O(E) \NR
\stopmathalignment\stopformula
\stopANSWER

\startigBase[continue]\startitem
說明如何在 \m{O(VE)} 時間內，
在一個 \m{\epsilon} 稠密的有向圖中計算除所有節點對之間的最短路徑，
這裏假定該圖不包含權重爲負值的邊。
\stopitem\stopigBase

\startANSWER
運行 \m{|V|} 次 \ALGO{DIJKSTRA}，根據 b）可知總時間爲 \m{O(VE)}。
\stopANSWER

\startigBase[continue]\startitem
說明如何在 \m{O(VE)} 時間內，
在一個 \m{\epsilon} 稠密的有向圖中計算除所有節點對之間的最短路徑，
這裏假定圖中可以包含權重爲負值的邊，
但不包含權重爲負值的環路。
\stopitem\stopigBase

\startANSWER
用 \ALGO{JOHNSON} 重新計算權重，總時間爲 \m{O(VE)}。
\stopANSWER

\stopPROBLEM

\stopPROBLEM

\stopsubject%Problems

\stopchapter
\stopcomponent

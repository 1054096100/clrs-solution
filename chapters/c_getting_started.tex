\startcomponent c_getting_started

\chapter{The Role of Algorithms in Computing}

\chapter{getting started}

\section{Insertion sort}

\startEXERCISE
參照圖 2.2，描述如何對數列 \math{A = <31, 41, 59, 26, 41, 58>} 進行排序。
\stopEXERCISE
\startANSWER
\startigBase[a]\dorecurse{6}{
  \item \framed[frame=off, location=lohi]{
  \startMPcode
	input insert_sort

	numeric gridsize;
	numeric ALength;	% don't use 'length' which is keyword used by arrow
	numeric data[];
	data[1] := 31;
	data[2] := 41;
	data[3] := 59;
	data[4] := 26;
	data[5] := 41;
	data[6] := 58;
	ALength := 6;
	gridsize := .5cm;

	for i := 2 upto \recurselevel:
		draw insert_sort_step(data, ALength)(gridsize, i, true, false);
	endfor;
	if (\recurselevel < ALength):
		draw insert_sort_step(data, ALength)(gridsize, (\recurselevel + 1), true, true);
	else:
		draw insert_sort_result(data, ALength)(gridsize);
	fi;
  \stopMPcode
  }
}\stopigBase
\stopANSWER

\startEXERCISE
重寫插入排序例程，以實現遞減排序。
\stopEXERCISE
\startANSWER

\startCLRS
for j = 2 to A.length
	key = A[j]
	// Insert A[j] into the sorted sequence A[1 .. j-1].
	i = j - 1
	while i > 0 and A[i] > key
		A[i+1] = A[i]
		i = i - 1
	A[i + 1] = key
\stopCLRS

\startigBase[a]\dorecurse{6}{
  \item \framed[frame=off, location=lohi]{
  \startMPcode
	input insert_sort

	numeric gridsize;
	numeric ALength;	% don't use 'length' which is keyword used by arrow
	numeric data[];
	data[1] := 31;
	data[2] := 41;
	data[3] := 59;
	data[4] := 26;
	data[5] := 41;
	data[6] := 58;
	ALength := 6;
	gridsize := .5cm;

	for i := 2 upto \recurselevel:
		draw insert_sort_step(data, ALength)(gridsize, i, false, false);
	endfor;
	if (\recurselevel < ALength):
		draw insert_sort_step(data, ALength)(gridsize, (\recurselevel + 1), false, true);
	else:
		draw insert_sort_result(data, ALength)(gridsize);
	fi;
  \stopMPcode
  }
}\stopigBase
\stopANSWER

\startEXERCISE
線性查找問題。
\stopEXERCISE
\startANSWER

\startCLRS
for j = 1 to A.length
	if A[i] == v
		return i
return NIL
\stopCLRS

\stopANSWER

\startEXERCISE
二進制加法問題。
\stopEXERCISE
\startANSWER

\startCLRS
for i = 1 to n + 1
	C[i] = 0
for i = 1 to n
	if A[i] == 1 and B[i] == 1
		C[i+1] = 1
	else if A[i] == 1 or B[i] == 1
		if C[i] == 1
			C[i] = 0
			C[i+1] = 1
		else
			C[i] = 1
\stopCLRS

\stopANSWER

\section{Analyzing algorithms}

\startEXERCISE
用 $\Theta$ 標記表示函式 $n^3 / 1000 - 100 n^2 - 100 n + 3$。
\stopEXERCISE
\startANSWER
$\Theta(n^3)$
\stopANSWER

\startEXERCISE
選擇排序。
\stopEXERCISE
\startANSWER
\startCLRS
n = A.length
for j = 1 to n - 1
	smallest = j
	for i = j + 1 to n
		if A[i] < A[smallest]
			smallest = i
	exchange A[j] with A[smallest]
\stopCLRS

所用時間爲 $\Theta(n^2)$。
\stopANSWER

\startEXERCISE
線性查找所用時間。
\stopEXERCISE
\startANSWER
一般情況 $\Theta(n)$。
最壞情況 $\Theta(n)$。
\stopANSWER

\startEXERCISE
如何修改算法時期最好情況下運行時間最短。
\stopEXERCISE
\startANSWER
測試輸入是否滿足某個特例，如果滿足，則直接輸出預先算好的結果。

最好情況下的運行時間一般不能作爲衡量一個算法好壞的標準。
\stopANSWER

\section{Designing algorithms}

\startEXERCISE
參照圖 2.4，對數列 $A=<3,41,52,26,38,57,9,49>$ 進行歸並排序。
\stopEXERCISE
\startANSWER
  \startMPcode
	input merge_sort

	numeric gridsize;
	numeric ALength;	% don't use 'length' which is keyword used by arrow
	numeric data[];
	data[1] := 3;
	data[2] := 41;
	data[3] := 52;
	data[4] := 26;
	data[5] := 38;
	data[6] := 57;
	data[7] := 9;
	data[8] := 49;
	ALength := 8;
	gridsize := .5cm;

	draw merge_sort(data, ALength)(gridsize, 1, ALength, true, true);
  \stopMPcode
\stopANSWER

\startEXERCISE
不使用哨兵，重寫 MERGE 例程。
\stopEXERCISE
\startANSWER
\startCLRS
n1 = q - p + 1
n2 = r - q
let L[1..n1+1] and R[1..n2+1] be new arrays
for i = 1 to n1
	L[i] = A[p + i - 1]
for j = 1 to n2
	R[j] = A[q + j]
i = 1
j = 1
for k = p to r
	if i > n1
		while j <= n2
			A[k] = R[j]
			k = k + 1
			j = j + 1
		return
	if j > n2
		while i <= n1
			A[k] = L[i]
			k = k + 1
			i = i + 1
		return
	if L[i] <= R[j]
		A[k] = L[i]
		i = i + 1
	else A[k] = R[j]
		j = j + 1
\stopCLRS
\stopANSWER

\startEXERCISE
用數學歸納法證明 \m{T(n) = n \lg(n)}：
\startformula
T(n) = \startmathcases
\NC 2		\MC \text{若 \m{n = 2}，} \NR
\NC 2T(n/2) + n	\MC \text{若 \m{n = 2^k}， \m{k > 1}。} \NR
\stopmathcases
\stopformula
\stopEXERCISE
\startANSWER
如果 \m{T(n) = n \lg(n)}，那麼：
\startformula\startalign
\NC T(2n)	\NC = 2n \lg(2n) \NR
\NC		\NC = 2n (\lg(n) + 1) \NR
\NC		\NC = 2n \lg(n) + 2n \NR
\NC		\NC = 2T(n) + 2n \NR
\stopalign\stopformula
\stopANSWER

\startEXERCISE
用遞迴方式重寫插入排序。
\stopEXERCISE
\startANSWER
\CLRSH{INSERTION(A, n)}
\startCLRS
if n < 2
	return
INSERTION-SORT(A, n-1)
key = A[n]
i = n - 1
while i > 0 and A[i] > key
	A[i+1] = A[i]
	i = i - 1
A[i + 1] = key
\stopCLRS

\startformula
T(n) = \startmathcases
\NC \Theta(1)		\MC \text{若 \m{n = 1}，} \NR
\NC T(n-1) + C(n-1)	\MC \text{否則。} \NR
\stopmathcases
\stopformula
\stopANSWER

\startEXERCISE[exercise:bin_search]
二分查找。
\stopEXERCISE
\startANSWER
\CLRSH{BINARY-SEARCH(A, v)}
\startCLRS
low = 1
high = A.length
while low <= high
	m = (low + high) / 2
	if A[m] == v
		return m
	if A[m] < v
		low = m + 1
	else
		high = m - 1
return NIL
\stopCLRS

\startformula
T(n+1) = T(n/2) + c
\stopformula
\stopANSWER

\startEXERCISE
插入排序時用二分法查找要插入的位置，以改進插入排序最壞情況的總運行時間至 \m{\Theta(nlgn)}？
\stopEXERCISE
\startANSWER
不行，二分查找只可能減少比較的次數，而無法減少數據搬移的次數。
\stopANSWER

\startEXERCISE
設計一個所用時間爲 \m{\Theta(nlgn)} 的算法，用來在集合 \m{S} 中是否有兩個數的和正好是 \m{x}。
\stopEXERCISE
\startANSWER
\CLRSH{PAIR-EXISTS(S, x)}
\startCLRS
A = MERGE-SORT(S)

for i = 1 to S.length
	if BINARY-SEARCH(A, x - S[i]) != NIL
		return true

return false
\stopCLRS
\stopANSWER

\startPROBLEM
在歸並排序中對小數列使用插入排序。
\startigBase[a]

\item 證明對 \m{n/k} 個長度爲 \m{k} 的子列進行插入排序的最多需要時間 \m{\Theta(nk)}。

\startANSWER
設對長度爲 \m{k} 的數列進行插入排序所用時間爲 \m{a k^2 + b k + c}，則總時間爲：
\startformula
\frac{n}{k}\m{a k^2 + b k + c} = a n k + b n + \frac{c n}{k} = \Theta(nk)
\stopformula
\stopANSWER

\item 證明歸並這些子列最多所需時爲爲 \m{\Theta(n \lg(n/k))}。

\startANSWER
對 \m{a} 個長度爲 \m{k} 的子列進行歸並排序所需時間爲：
\startformula
T(a) = \startcases
\NC 0	\NC \text{若 \m{a = 1}，} \NR
\NC 2 T(a/2) + a k \NC \text{若 \m{a = 2^p}， \m{p > 0}。} \NR
\stopcases
\stopformula

設 \m{G(a) = \frac{T(a)}{a}}，則：
\startformula\startalign
\NC G(a)	\NC = \frac{T(a)}{a} \NR
\NC 		\NC = \frac{2 T(a/2) + a k}{a} \NR
\NC		\NC = \frac{T(a/2)}{a/2} + k \NR
\NC		\NC = G(a/2) + k \NR
\stopalign\stopformula
即
\startformula
G(a) = \startcases
\NC 0	\NC \text{若 \m{a = 1}，} \NR
\NC G(a/2) + k \NC \text{若 \m{a = 2^p}， \m{p > 0}。} \NR
\stopcases
\stopformula

設 \m{H(p) = G(2^p)}，則：
\startformula\startalign
\NC H(p)	\NC = G(2^p) \NR
\NC		\NC = G(2^p/2) + k \NR
\NC		\NC = G(2^{p-1}) + k \NR
\NC		\NC = H(p-1) + k \NR
\stopalign\stopformula
即
\startformula
H(p) = \startcases
\NC 0	\NC \text{若 \m{p = 0}，} \NR
\NC H(p-1) + k \NC \text{若 \m{p > 0}。} \NR
\stopcases
\stopformula

\startformula\startalign
\NC H(p) \NC = k p \NR
\NC G(2^p) \NC = kp \NR
\NC G(a) \NC = k \lg(a) \NR
\NC \frac{T(a)}{a} \NC = k \lg(a) \NR
\NC T(a) \NC = k a \lg(a) \NR
\NC T(\frac{n}{k}) \NC = k \frac{n}{k} \lg(\frac{n}{k}) \NR
\NC		\NC = n \lg(\frac{n}{k}) \NR
\stopalign\stopformula
\stopANSWER

\item 假定修改後的算法運行時間爲 \m{\Theta(nk+n \lg(n/k))}，
\m{k} 最大爲多少時（作爲 \m{n} 的函式），新算法與原歸並排序算法所用時間相同？

\startANSWER
\startformula\startalign
\NC k \NC = \lg(n) \NR
\NC \Theta(nk + n \lg(n/k)) \NC = \Theta(n \lg(n) + n \lg(\frac{n}{\lg(n)}) \NR
\NC			\NC = \Theta(n \lg(n)) \NR
\stopalign\stopformula
\stopANSWER

\stopigBase
\stopPROBLEM

\startPROBLEM
冒泡排序

\CLRSH{BUBBLE-SORT(A)}
\startCLRS
for i = 1 to A.length - 1
	for j = A.length downto i + 1
		if A[j] < A[j - 1]
			exchange A[j] with A[j - 1]
\stopCLRS

\startigBase[a]

\item 要證明算法的正確性，除了要證明算法一定終止且排序完成後相鄰元素的大小關系外，還需要證明什麼？

\startANSWER
還需要證明排序完成後，新數列包含舊數列中的所有元素。
\stopANSWER

\item 內循環變量

\item 外循環變量

\item 運行時間？與插入排序相比如何？

\startANSWER
冒泡排序的比較次數最多爲：
\startformula
n - 1, n - 2, \cdots , 1 = \frac{n(n - 1)}{2}
\stopformula
相應的交換次數也一樣，所以最壞情況下所用時間爲 \m{\Theta(n^2)}，與插入排序所用時間相同。

通常，兩種算法最好情況下時間均爲 \m{\Theta(n)}，但是此處的實現卻爲 \m{\Theta(n^2)}。
要想在最好情況下達到 \m{\Theta(n)}，在外部循環中，如果沒有發生任何交換就直接返回。

另外，冒泡排序會比插入排序慢很多，因爲交換所引入的賦值操作太多了。
\stopANSWER

\stopigBase
\stopPROBLEM

\startPROBLEM
Horner 規則：
\startformula\startalign
\NC P(x) \NC = \sum_{k=0}^n a_kx^k \NR
\NC	\NC = a_0 + x(a_1 + x(a_2 + \cdots + x(a_{n-1} + xa_n) \cdots)) \NR
\stopalign\stopformula

\startCLRS
y = 0
for i = n downto 0
	y = a[i] + x * y
\stopCLRS

\startigBase[a]
\item 所用時間。

\startANSWER
\m{\Theta(n)}
\stopANSWER

\item 按其原本的多項式定義來計算，需要多少時間？

\startANSWER
\startCLRS
y = 0
for i = 0 to n
	m = 1
	for k = 1 to n
		m = m * x
	y = y + a[i] * m
\stopCLRS
所用時間爲 \m{\Theta(n^2)}。
\stopANSWER

\item 在循環每次迭代前：
\startformula
y = \sum_{k=0}^{n-(i+1)} a_{k+i+1}x^k
\stopformula
將沒有任何項的多項式求和結果定義爲 0。
證明結果爲 \m{y = \sum_{k=0}^n a_kx^k}。

\startANSWER
每次迭代完成後：
\startformula\startalign
\NC y \NC = a_i + x \sum_{k=0}^{n-(i+1)}a_{k+i+1}x^k \NR
\NC	\NC = a_i x^0 + \sum_{k=0}^{n-i-1}a_{k+i+1}x^{k+1} \NR
\NC	\NC = a_i x^0 + \sum_{k=1}^{n-i}a_{k+i}x^{k} \NR
\NC	\NC = \sum_{k=0}^{n-i}a_{k+i}x^{k} \NR
\stopalign\stopformula
最後一次 \m{i} 爲 \m{0}，帶入上式可得 \m{y = \sum_{k=0}^{n}a_{k}x^{k}}。
\stopANSWER

\stopigBase

\stopPROBLEM

\startPROBLEM[problem:inversion]
逆序對
\startformula
f(i,j) = \startcases
\NC true	\NC \text{若 \m{i<j}， \m{A[i] > A[j]}} \NR
\NC false	\NC \text{否則。} \NR
\stopcases
\stopformula
\startigBase[a]
\item 列出數列 \m{<2,3,8,6,1>} 中的五個逆序對。

\startANSWER
\m{(2,1),(3,1),(8,6),(8,1),(6,1)}
\stopANSWER

\item 如果數列中元素全部取自集合 \m{\{1,2,\cdots,n\}}，則最多有多少逆序對。

\startANSWER
\m{<n, n-1, \cdots, 1>}，其逆序對數目爲 \m{(n-1)+(n-2)+\cdots+1=\frac{n(n-1)}{2}}。
\stopANSWER

\item 插入排序的運行時間與數列中逆序對的數目有什麼關系？

\startANSWER
\m{\Theta(n+d)}，其中 \m{d} 爲逆序對的數目， \m{n} 爲外層循環所用時間。
\stopANSWER

\item 給出所用時間爲 \m{\Theta(n\lg(n))} 的算法，以確定數列中逆序對的數目。

\startANSWER
\CLRSH{MERGE-SORT(A, p, r)}
\startCLRS
if p < r
	inversions = 0
	q = (p + r) / 2
	inversions += merge_sort(A, p, q)
	inversions += merge_sort(A, q + 1, r)
	inversions += merge(A, p, q, r)
	return inversions
else
	return 0

MERGE(A, p, q, r)

n1 = q - p + 1
n2 = r - q
// let L[1..n₁] and R[1..n₂] be new arrays
for i = 1 to n1
	L[i] = A[p + i - 1]
for j = 1 to n2
	R[j] = A[q + j]
i = 1
j = 1
for k = p to r
	if i > n1
		A[k] = R[j]
		j = j + 1
	else if j > n2
		A[k] = L[i]
		i = i + 1
	else if L[i] <= R[j]
		A[k] = L[i]
		i = i + 1
	else
		A[k] = R[j]
		j = j + 1
		inversions += n1 - i
return inversions
\stopCLRS
\stopANSWER

\stopigBase
\stopPROBLEM

\stopcomponent

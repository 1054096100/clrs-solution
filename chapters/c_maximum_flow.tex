\startcomponent c_maximum_flow

\startchapter[
  title={Maximum Flow},
]

\startsection[
  title={Flow networks},
  reference=section:flow_networks,
]

%e26.1-1
\startEXERCISE
證明：在一個流網絡中，
將一條邊分解爲兩條邊所得到的是一個等價的網絡。
更形式化地說，假定網絡 \m{G} 包含邊 \m{(u,v)}，
我們以如下方式創建一個新的流網絡 \m{G'}：
創建一個新節點 \m{x}，
用新的邊 \m{(u,x)} 和 \m{(x,v)} 來替換原來的邊 \m{(u,v)}，
並設置 \m{c(u,x)=c(x,v)=c(u,v)}。
證明： \m{G'} 中的一個最大流與 \m{G} 中的一個最大流具有相同的值。
\stopEXERCISE

\startANSWER
\m{f(u,x)=f(x,v)}。
\stopANSWER

%e26.1-2
\startEXERCISE
將流的性值和定義推廣到多源點和多匯點的流問題上。
證明：在多源點多匯點流網絡中，
通過增加一個超級源點和超級匯點，可以所形成一個單源點單匯點流網絡，
新網絡與原網絡中的流是一一對應的。
\stopEXERCISE

\startANSWER
容量限制：對於所有 \m{u,v\in V}，都有 \m{0\le f(u,v)\le c(u,v)}；

流量守恆：對於所有 \m{u\in V-S-T}，都有 \m{\sum_{v\in V}f(v,u)=\sum_{v\in V}f(u,v)}。
\stopANSWER

%e26.1-3
\startEXERCISE
假定流網絡 \m{G=(V,E)} 違反了如下假設：對於所有節點 \m{v\in V}，
網絡必須包括一條路徑 \m{s\leadsto v\leadsto t}。
設節點 \m{u} 滿足：不存在路徑 \m{s\leadsto u\leadsto t}。
證明： \m{G} 中必然存在一個最大流 \m{f}，
使得對於所有節點 \m{v\in V}， \m{f(u,v)=f(v,u)=0}。
\stopEXERCISE

\startANSWER
\m{u} 只能扇入或只能扇出，因此只能是既無扇入亦無扇出。
\stopANSWER

%e26.1-4
\startEXERCISE
設 \m{f} 爲網絡中的一個流， \m{\alpha} 爲一實數，
將 \m{\alpha f} 稱爲{\EMP 標量流積（scalar flow product）}，
是從 \m{V\times V} 到 \m{R} 的函數，定義如下：
\startformula
(\alpha f)(u,v) = \alpha \cdot f(u,v)
\stopformula
證明：網絡中的流形成一個{\EMP 凸集（convex set）}。
也就是說，證明：如果 \m{f_1} 和 \m{f_2} 爲兩個流，
則 \m{\alpha f_1 + (1-\alpha)f_2} 也是一個流，這裏 \m{0\le \alpha \le 1}。
\stopEXERCISE

\startANSWER
\m{0\le \alpha f_1 + (1-\alpha)f_2 \le \max(f_1,f_2)}。
\stopANSWER

%e26.1-5
\startEXERCISE
將最大流問題表述爲一個線性規劃問題。
\stopEXERCISE

\startANSWER
\startformula\startmathalignment
\NC \max \NC (\sum_{v\in V}f(s,v) - \sum_{v\in V}f(v,s)) \NR
\NC s.t. \NC 0\le f(u,v) \le c(u,v) \NR
\NC \NC \sum_{v\in V}f(v,u) - \sum_{v\in V}f(u,v) = 0 \NR
\stopmathalignment\stopformula
\stopANSWER

%e26.1-6
\startEXERCISE
Adam 教授有兩個兒子，可不幸的是，他們互相討厭對方。
隨着時間的推移，問題變得如此嚴重，
他們不僅不願意一起到學校，
而且都拒絕走對方當天所走過的街區。
兩個孩子並不在意自己走的路徑與對方所走的路徑在街角交叉。
幸運的是，教授的房子和學校都位於街角。
但除此之外，教授不能肯定是否可以在滿足上述條件的情況下
把兩個小孩送到同一所學校。
教授有一份小鎮的地圖，試說明如何將這個問題轉換爲一個最大流問題，
以便決定是否可以將孩子送到同一所學校。
\stopEXERCISE

\startANSWER
每條路的容量都是 1，最大流必須大於 1。
\stopANSWER

%e26.1-7
\startEXERCISE
假定除邊的容量外，流網絡還有{\EMP 節點容量}。
即對於每個節點 \m{v}，有一個極限值 \m{l(v)}，
這是可以流經此節點的最大流量。
請說明如何將一個帶有節點容量的流網絡 \m{G=(V,E)} 轉換
爲一個等價的但沒有節點容量的流網絡 \m{G'=(V',E')}，
使得 \m{G'} 中的最大流與 \m{G} 中的最大流取值相同。
圖 \m{G'} 裏有多少個節點和多少條邊？
\stopEXERCISE

\startANSWER
將每個節點 \m{v} 轉換成一條邊 \m{v,v‘}，其容量爲 \m{l(v)}。
 \m{V' = 2V}， \m{E'=V+E}。
\stopANSWER

\stopsection

\startsection[
  title={The Ford-Fulkerson method},
]

%e26.2-1
\startEXERCISE
證明式 26.6 中的和值等於式 26.7 中的和值。
\stopEXERCISE

\startANSWER
\startformula\startmathalignment
\NC |f\uparrow f'| \NC = \sum_{v\in V_1}f(s,v) - \sum_{v\in V_2}f(v,s)
  + \sum_{v\in V_1\cup V_2}f'(s,v) - \sum_{v\in V_1\cup V_2}f'(v,s) \NR
\NC \NC = \sum_{v\in V}f(s,v) - \sum_{v\in V}f(v,s)
  + \sum_{v\in V}f'(s,v) - \sum_{v\in V}f'(v,s) \NR
\NC \NC = |f| + |f'| \NR
\stopmathalignment\stopformula
\stopANSWER

%e26.2-2
\startEXERCISE
在圖 26-1（b）中，橫跨切割（\m{\{s,v_2,v_4\}}， \m{\{v_1,v_3,t\}}）的流是多少？
該切割的容量又是多少？附圖 26-1：

\externalfigure[output/e26_2_2-1]
\stopEXERCISE

\startANSWER
\startformula
f(s,t) = f(s,v_1) + f(v_2,v_1) + f(v_4,v_3) + f(v_4,t) - f(v_3,v_2) = 19
\stopformula

\startformula
f(s,t) = c(s,v_1) + c(v_2,v_1) + c(v_4,v_3) + c(v_4,t) = 31
\stopformula
\stopANSWER

%e26.2-3
\startEXERCISE
在圖 26-1（a）所示的流網絡上演示 \ALGO{EDMONDS-KARP} 的執行過程。
附圖 26-1（a）：

\externalfigure[output/e26_2_3-1]
\stopEXERCISE

\startANSWER
\startcombination[nx=2]
{\externalfigure[output/e26_2_3-2]}{}
{\externalfigure[output/e26_2_3-3]}{}
\stopcombination
\startcombination[nx=2]
{\externalfigure[output/e26_2_3-4]}{}
{\externalfigure[output/e26_2_3-5]}{}
\stopcombination
\startcombination[nx=2]
{\externalfigure[output/e26_2_3-6]}{}
{\externalfigure[output/e26_2_3-7]}{}
\stopcombination
\startcombination[nx=2]
{\externalfigure[output/e26_2_3-8]}{}
{}{}
\stopcombination
\stopANSWER

%e26.2-4
\startEXERCISE
在圖 26-6 的例子中，對應圖中所示最大流的最小切割是什麼？
在例子中出現的增廣路徑裏，哪一條路徑抵消了先前被傳輸的流？
\stopEXERCISE

\startANSWER
最小切割爲 \m{(\{s,v_1,v_2,v_4\},\{v_3,t\})}。
（c）中的 \m{(v_1,v_2)} 抵消了（b）中的 \m{(v_2,v_1)}。
（c）中的 \m{(v_2,v_3)} 抵消了（a）中的 \m{(v_3,v_2)}。
\stopANSWER

%e26.2-5
\startEXERCISE
在\refsection{flow_networks} 中，我們通過增加容量無限的邊，
把多源點多匯點的流網絡轉換爲單源點單匯點的流網絡。
證明：
如果原來的網絡容量是有限的，則轉換後的網絡中任何一個流的值都是有限的。
\stopEXERCISE

\startANSWER
因爲我們可以找到一個最小切割，只包含有限個有限權重的邊。
\stopANSWER

%e26.2-6
\startEXERCISE
假定在一個多源點多匯點的流網絡中，
每個源節點 \m{s_i} 生產出恰好 \m{p_i} 個單位的流，
因此， \m{\sum_{v\in V}f(s_i,v)=p_i}。
假定每個匯點 \m{t_j} 恰好消費 \m{q_j} 個單位的流，
因此 \m{\sum_{v\in V}f(v,t_j)=q_j}，其中 \m{\sum_{i}p_i = \sum_{j}q_j}。
說明如何在此網絡中尋找最大流 \m{f} （可以先將其轉換爲一個單源點單匯點的流網絡）。
\stopEXERCISE

\startANSWER
新添加源點 \m{s} 和匯點 \m{t}。
邊 \m{(s,s_i)} 的容量爲 \m{c(s,s_i) = p_i}。
邊 \m{(t_j,t)} 的容量爲 \m{c(t_j,t) = q_j}。
\stopANSWER

%e26.2-7
\startEXERCISE
證明引理 26.2。附引理 26.2：

設 \m{G=(V,E)} 爲一個流網絡，
 \m{f} 是圖 \m{G} 的一個流，
設 \m{p} 爲殘存網路 \m{G_f} 中的一條增光路徑。
定義一個函數 \m{f_p: V\times V\rightarrow R} 如下：
\startformula
f_p(u,v)=\startcases
\NC c_f(p) \MC \text{如果 \m{(u,v)} 在 \m{p} 上} \NR
\NC 0 \MC 否則 \NR
\stopcases
\stopformula
則 \m{f_p} 是殘存網絡 \m{G_f} 中的一個流，
其值爲 \m{|f_p| = c_f(p) > 0}。
\stopEXERCISE

\startANSWER
容量限制：由於 \m{c_f(p)} 是 \m{p} 上所有邊的最小權重，
因此滿足 \m{0\le f_p(u,v) = c_p(u,v) \le c_f(p)}。

流量守恆： \m{\sum_{v\in V}f(v,u) = c_f(p) = \sum_{v\in V}f(u,v)}。
\stopANSWER

%e26.2-8
\startEXERCISE
假定我們重新定義殘存網絡，
進制一切進入源節點 \m{s} 的邊。
算法 \ALGO{FORD-FULKERSON} 所計算出的最大流是否仍然正確？
\stopEXERCISE

\startANSWER
正確。
\stopANSWER

%e26.2-9
\startEXERCISE
假定 \m{f} 和 \m{f'} 都是流網絡 \m{G} 中的流，
計算流 \m{f\uparrow f'}。
加增後的流滿足流量守恆嗎？
滿足容量限制嗎？
\stopEXERCISE

\startANSWER
滿足流量守恆，不滿足容量限制。
\stopANSWER

%e26.2-10
\startEXERCISE
說明在流網絡 \m{G=(V,E)} 中，
如何使用一個最多包含 \m{|E|} 條增廣路徑的序列找到最大流。
（\hint 找到最大流後再確定路徑）
\stopEXERCISE

\startANSWER
先找到最大流，可以得到網絡的最小切割。
在最小切割的基礎上，每次增加一條邊，上限爲 \m{|E|}。
\stopANSWER

%e26.2-11
\startEXERCISE
無向圖的{\EMP 邊連通性}是指使圖變爲非連通圖所需要刪除的最少邊數 \m{k}。
例如，樹的邊連通性爲 \m{1}，環路的邊連通性爲 \m{2}。
請說明如何在最多 \m{|V|} 個流網絡上運行最大流算法，
從而確定無向圖 \m{G=(V,E)} 的邊連通性，
這裏的每個流網絡節點數爲 \m{O(V)}，邊數爲 \m{O(E)}。
\stopEXERCISE

\startANSWER
先將圖 \m{G} 轉換成帶權有向圖 \m{G'}，兩圖頂點相同。
 \m{G} 中的每條邊 \m{(u,v)} 對應 \m{G'} 中的兩條邊 \m{(u,v)} 和 \m{(v,u)}。
 \m{G'} 中所有邊權重均爲 \m{1}。
在 \m{G'} 基礎上構造 \m{|V|} 個網絡流，
分別令每個頂點作爲匯點，源點可任意選取，只要不是匯點即可。
依次求這 \m{|V|} 個流網絡的最大流。
所有最大流的最小值即爲 \m{G} 的邊連通性。
\stopANSWER

%e26.2-12
\startEXERCISE
給定一個流網絡 \m{G}， \m{G} 中包含進入源節點 \m{s} 的邊。
設 \m{f} 爲網絡 \m{G} 中的一個流，
在該流中，其中一條進入源點的邊 \m{(v,s)} 有 \m{f(v,s)=1}。
證明：圖 \m{G} 中必存在另一個流 \m{f'}，
滿足 \m{f'(v,s)=0}，使得 \m{|f|=|f'|}。
給出一個 \m{O(E)} 時間複雜度的算法，
在給定流 \m{f} 的情況下計算 \m{f'}，
這裏假定所有邊的容量都是正整數。
\stopEXERCISE

\startANSWER
在流網絡 \m{G=(V,E)} 中，對於節點 \m{v\in V-s}，
如果沒有路徑 \m{s\leadsto v}，則 \m{f(v,s)=0}。

令從 \m{s} 可達的節點集合爲 \m{Y}，
從 \m{s} 不可達的節點集合爲 \m{Z}，有：
\startformula\startmathalignment
\NC \sum_{z\in Z} \sum_{x\in V} f(x,z) \NC = \sum_{z\in Z}\sum_{x\in V} f(z,x) \qquad \text{流量守恆} \NR
\NC \sum_{z\in Z}\sum_{x\in Z}f(x,z) + \sum_{z\in Z}\sum_{x\in Y}f(x,z) \NC
  \sum_{z\in Z}\sum_{x\in Z}f(z,x) + \sum_{z\in Z}\sum_{x\in Y}f(z,x) \NR
\stopmathalignment\stopformula

根據流量守恆有 \m{\sum_{z\in Z}\sum_{x\in Z}f(x,z) = \sum_{z\in Z}\sum_{x\in Z}f(z,x)}。
又由於 \m{\sum_{z\in Z}\sum_{x\in Y} f(x,z) = 0}，所以：
對於所有 \m{z\in Z} 和 \m{x\in Y}，都有 \m{f(z,x) = 0}。
因此，對於所有 \m{v\in Z} 和 \m{s\in Y}，都有 \m{f(v,s) = 0}。

而如果 \m{f(v,s)=1}，那麼 \m{v\notin Z}，即肯定存在路徑 \m{s\leadsto v}。
從而有環路 \m{s\leadsto v \leadsto s}，給其中每條邊都減 \m{1}，形成新的流 \m{f'}，
不會影響總流量，即 \m{|f| = |f'|}。

首先搜索節點 \m{v}，使得 \m{(v,s)\in E} 且 \m{f(v,s)=1}，
可以通過 \ALGO{BFS} 搜索路徑 \m{s\leadsto s}。
確保路徑上所有邊 \m{(u,v)} 都有 \m{f(u,v)\ge 1}。

然後將所得路徑上所有邊 \m{(u,v)} 的 \m{f(u,v)} 都減去 \m{1}。得到 \m{f'}，返回即可。
\stopANSWER

%e26.2-13
\startEXERCISE
假定我們希望找到流網絡 \m{G} 的一個最小切割，使其邊數是所有最小切割中最少的。
這裏假定 \m{G} 的所有容量都是整數。
說明如何修改 \m{G} 的容量來創建一個新的流網絡 \m{G'}，
使得 \m{G'} 中的任一最小切割都是 \m{G} 中邊數最少的最小切割。
\stopEXERCISE

\startANSWER
\m{G'} 的頂點、邊與 \m{G} 的相同，但邊的容量有所區別。
對於所有 \m{(u,v)\in E}，有 \m{c_{G'}(u,v) = c_{G}(u,v) + \sigma}。
其中 \m{\sigma} 是一個常數，保證最小切割的邊數最多不會超過 \m{G} 中邊數最小的最小切割。
同時 \m{\sigma} 也不能太大，因爲在減少最小切割邊數的同時可能導致切割不再是最小切割。

\startformula
\sigma = \frac{m}{2|E|}
\stopformula
其中 \m{m} 是 \m{G} 中最小切割與非最小切割的最小差異。
要證明其正確性，我們需要證明：

1） \m{G} 中邊數最少的最小切割是 \m{G'} 中的唯一最小切割。

2） \m{G} 中非最小切割不是 \m{G'} 的最小切割。

先證明（1），令 \m{(S,T),(X,Y)} 是 \m{G} 的最小切割， \m{|(S,T)|<|(X,Y)|}，有：
\startformula\startmathalignment
\NC c'(S,T) \NC = c(S,T) + |(S,T)|\sigma \NR
\NC \NC < c(X,Y) + |(X,Y)|\sigma \qquad c(S,T) = c(X,Y) \text{且} |(S,T)| < |(X,Y)| \NR
\NC \NC = c'(X,Y) \NR
\stopmathalignment\stopformula

再證明（2），令 \m{(S,T)} 爲 \m{G} 的最小切割， \m{c(S,T)<c(X,Y)}，
我們來證明 \m{c'(X,Y)} 不是 \m{G'} 的最小切割：
\startformula\startmathalignment
\NC c'(S,T) \NC = c(S,T) + |(S,T)|\sigma \NR
\NC \NC \le c(S,T) + |E|\sigma \qquad |(S,T)| \le |E| \NR
\NC \NC = c(S,T) + \frac{m}{2} \NR
\NC \NC \le c(X,Y) \qquad c(X,Y) - c(S,T) \ge m \NR
\NC \NC < c'(X,Y) \NR
\stopmathalignment\stopformula

\stopANSWER

\stopsection

\startsection[
  title={Maximum bipartite matching},
]

%e26.3-1
\startEXERCISE
在圖 26-8（c）上運行算法 \ALGO{FORD-FULKERSON}，
給出每次流量遞增後的殘存網絡。
將集合 \m{L} 中的節點從上至下編號 1～5，
集合 \m{R} 中的編號從上至下編號 6～9。
對於每次迭代，選擇字典次序最小的增廣路徑。
附圖 26-8（c）：

\externalfigure[output/e26_3_1-1]
\stopEXERCISE

\startANSWER
\startcombination[nx=4]
{\externalfigure[output/e26_3_1-2]}{}
{\externalfigure[output/e26_3_1-3]}{}
{\externalfigure[output/e26_3_1-4]}{}
{\externalfigure[output/e26_3_1-5]}{}
\stopcombination
\startcombination[nx=4]
{\externalfigure[output/e26_3_1-6]}{}
{\externalfigure[output/e26_3_1-7]}{}
{\externalfigure[output/e26_3_1-8]}{}
{}{}
\stopcombination
\stopANSWER

%e26.3-2
\startEXERCISE
證明定理 26.10。
附定理 26.10：

如果容量函數 \m{c} 只能取整數值，
則 \ALGO{FORD-FULKERSON} 所生成的最大流 \m{f} 滿足： \m{|f|} 是整數值。
而且，對於所有節點 \m{u} 和 \m{v}， \m{f(u,v)} 的值都是整數。
\stopEXERCISE

\startANSWER
算法 \ALGO{FORD-FULKERSON} 中增廣路徑中邊的最小容量肯定是整數，
流的容量每次的變化都是整數，因此最終的最大流 \m{|f|} 是整數，且任一邊的流量都是整數。
\stopANSWER

%e26.3-3
\startEXERCISE
設 \m{G=(V,E)} 是一個二分圖，
其節點劃分爲 \m{V=L\cup R}，設 \m{G'=(V',E')} 爲其對應的流網絡。
在 \ALGO{FORD-FULKERSON} 執行過程中，
對在 \m{G'} 中找出的任意增廣路徑的長度給出一個適當的上界。
\stopEXERCISE

\startANSWER
根據定義，殘存網絡 \m{G'_{f}} 的增廣路徑是 \m{s\leadsto t} 的簡單路徑。
在 \m{G} 中不存在兩端均在 \m{L} 或 \m{R} 中的邊，
 \m{G'} 和 \m{G'_f} 中也沒有這樣的邊。
只有 \m{s} 連接 \m{L} 中的節點， \m{R} 中的節點連接到 \m{t}。
 \m{G'} 中的邊均從 \m{L} 到 \m{R}，
而 \m{G'_f} 中的邊則可能從 \m{R} 到 \m{L}。
所以增廣路徑只能是：
\startformula
s\rightarrow L\rightarrow R\rightarrow \ldots \rightarrow L\rightarrow R\rightarrow t
\stopformula
在 \m{L} 和 \m{R} 中來回穿梭，但每個節點只能通過一次。
總節點數爲 \m{2 + 2\times \min(|L|,|R|)}。
因此增廣路徑的長度上限爲 \m{2\times \min(|L|,|R|) + 1}。
\stopANSWER

%e26.3-4
\startEXERCISE\DIFFICULT
{\EMP 完全匹配（perfect matching）}指包含圖中所有節點的匹配。
設 \m{G=(V,E)} 是節點劃分爲 \m{V=L\cup R} 的無向二分圖，
其中 \m{|L|=|R|}。
對於任意 \m{X\subseteq V}，定義 \m{X} 的{\EMP 鄰居（neighborhood）}爲：
\startformula
N(X)=\{y\in V:\exists x\in X, (x,y)\in E\}
\stopformula
即集合中的元素由 \m{X} 中的節點可達。
請證明 Hall 定理：

圖 \m{G} 中存在一個完全匹配當且僅當對於每個子集 \m{A\subseteq L}，
有 \m{|A|\le |N(A)|}。
\stopEXERCISE

\startANSWER
先證明：如果存在完全匹配，則對於任一 \m{A\subseteq L}，有 \m{|A|\le |N(A)|}。

根據完全匹配的定義， \m{L} 中的每個節點都連接到了 \m{R} 中的節點，且互不相同。
即 \m{|A|\le |N(A)|}。

現在看另一面：如果所有 \m{A\subseteq L}，都有 \m{|A|\le |N(A)|}，
則存在完全匹配。

如果 \m{|L|=|R|=1}，很顯然存在完全匹配，
即 \m{G} 中只有一條邊。假定上述假設對 \m{|L|=|R|=1,2,\ldots,n-1} 均成立。
當 \m{|L|=|R|=n} 時，分兩種情況考慮：

第一種情況：對於所有 \m{A\subseteq L}，都有 \m{|A|<|N(A)|}。
在 \m{L} 中任取一個節點 \m{u}，然後在 \m{R} 中選取 \m{u} 的任一鄰居，
然後將這兩個點從 \m{G} 中移除。
剩下的爲圖 \m{G'}，仍然能保證：對於所有 \m{A\subseteq L}，都有 \m{|A|\le |N(A)|}。
由於在 \m{G'} 中， \m{|L|=|R|=n-1}，根據歸納假設，有完全匹配 \m{M'}，
在此基礎上添加 \m{(u,v)}，即爲 \m{G} 的完全匹配。

第二種情況：至少存在一個 \m{A\subset L}，滿足 \m{|A|=|N(A)|}。
根據歸納假設，在 \m{A} 和 \m{N(A)} 間存在完全匹配 \m{M_A}。
從 \m{G} 中移除 \m{A} 和 \m{N(A)}。
在剩下的 \m{G'} 中，仍然滿足：對於所有 \m{B\subseteq L - A}，都有 \m{|B|\le |N(B)|}。
用反證法。假如 \m{|B|>|N(B)|}，那麼 \m{|A\cup B|>|N(A\cup B)|}，顯然矛盾。
因此， \m{G'} 有完全匹配 \m{M'}。
結合 \m{M_A} 和 \m{M'}，就可以得到 \m{G} 的完全匹配。
\stopANSWER

%e26.3-5
\startEXERCISE\DIFFICULT
將圖 \m{G=(V,E)} 中的節點劃分爲 \m{V=L\cup R}，
如果二分圖中的每個節點 \m{v} 的度數都是 \m{d}，
則稱該二分圖是 {\EMP \m{d} 正則的（\m{d}-regular）}。
對於每個 \m{d} 正則的二分圖，都有 \m{|L|=|R|}。
證明：
每個 \m{d} 正則二分圖的匹配基數都是 \m{|L|}。
（\hint 證明對應的流網絡最小切割的容量爲 \m{|L|}）
\stopEXERCISE

\startANSWER
\m{L} 的總出度與 \m{R} 的總入度相同，每個節點的度數又都相同，所以 \m{|L|=|R|}。

最大匹配的基數就是 \m{G'} 中最大流的值。
定義 \m{G'} 的一個流：
\startformula
f(u,v)=\startcases
\NC 1/d \MC \text{如果 \m{(u,v)\in E}} \NR
\NC 1 \MC \text{如果 \m{u=s} 或者 \m{v=t}} \NR
\NC 0 \MC \text{其他} \NR
\stopcases
\stopformula
則 \m{f} 是 \m{G'} 的一個流，其值就是完全匹配的基數。
\stopANSWER

\stopsection

\startsection[
  title={Push-relabel algorithms},
]

%e26.4-1
\startEXERCISE
證明：算法 \ALGO{INITIALIZE-PREFLOW(G,s)} 終止後，
有 \m{s.e\le -|f^*|}，其中 \m{f^*} 是流網絡 \m{G} 的一個最大流。
\stopEXERCISE

\startANSWER
\startformula
s.e = -\sum_{(s,v)\in E}c(s,v)
\stopformula
\stopANSWER

%e26.4-2
\startEXERCISE
說明如何實現通用的推送-重貼標籤算法，
使得每個重貼標籤的操作成本爲 \m{O(V)}，
每個推送操作的成本爲 \m{O(1)}，
並且可以在 \m{O(1)} 時間內選擇一個合適的操作，
從而使得整個算法運行時間爲 \m{O(V^2E)}。
\stopEXERCISE

\startANSWER
\m{s} 和 \m{t} 不會溢出，也就不會被重貼標籤。
 \m{t} 可以吸收無限多流，也就不會推送。

有邊 \m{(u,v)\in E_f}， \m{u.h = v.h + 1}。
則可以進行推送，一旦調用 \ALGO{PUSH(u,v)}，若 \m{u.e = 0}，則爲非飽和推送，
在下一次迭代中我們不會對 \m{u} 進行推送或重貼標籤，因爲 \m{u} 不再溢出。
而如果推送後 \m{u.e > 0}，則爲飽和推送，
在下一次迭代中我們會對 \m{u} 進行推送或重貼標籤。
除此之外， \m{v.e} 一定大於零，
因爲 \m{v.e} 一直非負，在執行 \ALGO{PUSH(u,v)} 時還會增大。
至於 \m{v}，是推送，還是重貼標籤，就很難判斷了。

令 \m{G} 和 \m{G_f} 分別代表流和殘存網絡。
在 \m{G_f} 中，對於每個節點 \m{u\in V_f}，
令 \m{u.r} 表示 \m{G_f} 中 \m{u} 的一個鄰接點，即 \m{(u,u.r)\in E_f}，
且 \m{u.h = u.r.h + 1}。
如果不存在這樣的節點，則 \m{u.r = NIL}，
 \ALGO{RELABEL(u)} 會正確設置 \m{u.r}。
除此之外，我們用兩個鏈表實現通用的推送重貼標籤算法。

\m{L_1} 是待處理鏈表，對於所有 \m{u\in L_1}，都有 \m{u.e\le 0}。
根據之前的討論，在下一次迭代中，我們不會對這些節點進行推送或重貼標籤，
因爲他們沒有溢出。

\m{L_2} 是推送重貼標籤鏈表，對於所有 \m{u\in L_2}，都有 \m{u.e > 0}。
即這些節點全部溢出，我們會對其進行推送或重貼標籤。
如果 \m{L_2} 爲空，則算法終止。

初始化的時候進行如下操作。
在執行完 \ALGO{INITIALIZE-PREFLOW} 後，對於所有節點 \m{u\in V}，
如果 \m{u.e\le 0}，則將其移入 \m{L_1}，否則將其移入 \m{L_2}。

從 \m{L_2} 中取出一個節點 \m{u} 後，
根據 \m{u.r} 的值進行不同的處理。
如果 \m{u.r} 是 \m{NIL}，則重貼標籤，然後插入到 \m{L_2} 的最前端。
否則令 \m{v = u.r}，
先檢查 \m{u.h = v.h + 1} 是否成立，
如果不成立，還是重貼標籤，然後插入到 \m{L_2} 的最前端，
否則調用 \ALGO{PUSH(u,v)}。
調用 \ALGO{PUSH(u,v)} 之後，如果 \m{u.e = 0}，
則將 \m{u} 移入 \m{L_1}；
如果 \m{u.e > 0}，則先將 \m{u.h} 重置爲 \m{NIL}，
然後將其插入到 \m{L_2} 末尾。
但 \m{v.e} 還是正值，如果下一次迭代中可以推送 \m{v}，就必須推送。
幸運的是，通過跟蹤 \m{v.r}，很容易做到這一點。
只需在執行完 \ALGO{PUSH(u,v)} 後，將 \m{v} 移到 \m{L_2} 的最前端，
下一次迭代時，算法會自動判斷。

我們知道每個重貼標籤操作的代價是 \m{O(V)}，
每個推送操作的代價是 \m{O(1)}，
選擇操作需要 \m{O(1)}。

然而我們還有點不放心：
（1）調用完 \ALGO{PUSH(u,v)} 後，
如果 \m{u.e=0}，則會將其移到正確位置。
而如果 \m{u.e>0}，我們將其移到了 \m{L_2} 尾端，
如果還可以繼續推送 \m{u} （但沒有立刻推送），會出現什麼情況？
最壞情況下，調用完 \ALGO{PUSH(u,v)} 後（正好是一個飽和推送），
我們會額外執行一個重貼標籤操作。
根據引理 26.22，最多會有 \m{2|V||E|} 個飽和推送，
因此總代價最多爲 \m{2|V||E| \times O(V) = O(V^2 E)}。
（2）從 \m{L_2} 中取出一個節點 \m{u}，
如果 \m{u.r = v}，且 \m{u.h \ne v.h+1}，
則從 \m{v} 到 \m{u} 迴流，
即 \m{u} 仍然溢出，不能再從 \m{u} 推送到 \m{v}。
對於每條邊 \m{(u,v)\in E_f}，
這種情況最多有 \m{2|V|} 次。
 \m{u.r=v} 意味着之前進行過一次非飽和推送 \m{(u,v)}，
即 \m{u.h = v.h+1}。
但現在 \m{u.h\ne v.h + 1}，即 \m{u.h\le v.h}， \m{v.h} 增大了。
下一次執行 \ALGO{PUSH(u,v)} 時會發現仍然有 \m{u.h=v.h + 1}，
即 \m{u.h} 又增大了。
因此對於每條邊 \m{(u,v)\in E_f}，
最多有 \m{2|V|} 次重貼標籤操作。
總代價爲 \m{|E|\times (2|V|) \times O(V)=O(V^2 E)}。
\stopANSWER

%e26.4-3
\startEXERCISE
證明：在通用推送重貼標籤算法中，
所有 \m{O(V^2)} 個重貼標籤操作，總共只用了 \m{O(VE)} 的時間。
\stopEXERCISE

\startANSWER
每次調用 \ALGO{RELABEL(u)}，我們會檢查所有邊 \m{(u,v)\in E_f}。
對於每個節點而言，最多重貼標籤 \m{2|V|-1} 次，
而對於每條邊 \m{(u,v)}，在重貼標籤過程中，
最多會檢查 \m{4|V|-2} 次，
其中一半用於 \m{u}，另一半用於 \m{v}。
殘存網絡中最多有 \m{2|E|=O(E)} 條邊，
因此重貼標籤總時間爲 \m{O(VE)}。
\stopANSWER

%e26.4-4
\startEXERCISE
假定使用推送重貼標籤算法找到了流網絡 \m{G=(V,E)} 的一個最大流，
如何快速找到 \m{G} 的一個最小切割。
\stopEXERCISE

\startANSWER
可以在 \m{O(V)} 時間內做到。

首先，找到 \m{\hat{h}}，滿足 \m{0<\hat{h}<|V|}，
且算法終止時沒有節點高度爲 \m{\hat{h}}。

由於 \m{s.h = |V|}，且 \m{t.h = 0}，
我們僅需考慮 \m{|V|-2} 個節點。
也就是說 \m{\hat{h}} 的值有 \m{|V|-1} 種可能，
我們知道在 \m{1,2,\ldots,|V|-1} 中，至少有一個值不是任何節點的高。
因此如何選取 \m{\hat{h}}，就很明確了，
很容易通過一個布爾數組，在 \m{O(V)} 時間內就可以找到 \m{\hat{h}}。

令 \m{S=\{u\in V: u.h > \hat{h}\}}， \m{T=\{v\in V: v.h<\hat{h}\}}。
由於 \m{s.h=|V|>\hat{h}}，所以 \m{s\in S}，
又由於 \m{t.h=0<\hat{h}}，所以 \m{t\in T}，
這也符合切割的要求。

我們需要使得對於所有 \m{u\in S} 和 \m{v\in T}， \m{f(u,v)=c(u,v)}。
一旦如此，則 \m{f(S,T)=c(S,T)}，
根據推論 26.6， \m{(S,T)} 就是最小切割。

爲了反證，設存在節點 \m{u\in S} 和 \m{v\in T}， \m{(u,v)\in E_f}。
因爲 \m{h} 始終是高度函數（引理 26.17），有 \m{u.h\le v.h + 1}。
但同時 \m{v.h < \hat{h} < u.h}，
又因爲所有高度都是整數， \m{v.h\le u.h - 2}。
因此， \m{u.h\le v.h + 1\le u.h - 2 + 1 = u.h - 1}，
即 \m{0\le -1}，顯然不成立。
因此 \m{(S,T)} 就是最小切割。

\stopANSWER

%e26.4-5
\startEXERCISE
給出一個有效的推送重貼標籤算法，
使其可以在一個二分圖中找到一個最大匹配，
並分析其效率。
\stopEXERCISE

\startANSWER
\TODO{略。}
\stopANSWER

%e26.4-6
\startEXERCISE
假定在流網絡 \m{G=(V,E)} 中所有邊的容量都在集合 \m{\{1,2,\ldots,k\}} 中。
分析通用推送重貼標籤算法的運行時間，
請以 \m{|V|}、 \m{|E|} 和 \m{k} 來予以表示。
（\hint 每條邊在變爲飽和之前可以支持多少次非飽和推送操作）
\stopEXERCISE

\startANSWER
\TODO{略。}
\stopANSWER

%e26.4-7
\startEXERCISE
證明：我們可以將 \ALGO{INITIALIZE-PREFLOW} 的第 6 行改爲：
\startformula
s.h = |G.V| - 2
\stopformula
而不會影響通用推送重貼標籤算法的正確性和漸進性能。
\stopEXERCISE

\startANSWER
如果設置 \m{s.h = |V|-2}，則需要修改高度函數的定義。

要證明正確性，只需要更新引理 26.18 的證明。
原始證明推導出的是 \m{s.h\le k < |V|} 與 \m{s.h=|V|} 矛盾。
改成 \m{s.h=|V|-2} 之後，這個矛盾不存在了。

在原始證明中，假定有一簡單增廣路徑 \m{\langle v_0,v_1,\ldots,v_k\rangle}，
其中 \m{v_0=s}， \m{v_k = t}，因此 \m{k<|V|}。
 \m{(s,v_1)} 怎樣才能成爲殘存邊？
此邊在 \ALGO{INITIALIZE-PREFLOW} 中已經飽和了，
這意味着曾經有從 \m{v_1} 推送到 \m{s} 的操作。
爲了做到這一點，必須滿足 \m{v_1.h = s.h + 1}。
如果我們設置了 \m{s.h=|V|-2}，
也就意味着 \m{v_1.h} 是 \m{|V|-1}。
在那之後， \m{v_1.h} 不再減小，因此 \m{v_1.h\ge |V|-1}。
回溯增廣路徑，有 \m{v_{k-i}.h\le t.h + i}，
對於 \m{i=0,1,\ldots,k} 均成立。
回顧假設，由於增廣路徑是簡單路徑， \m{k<|V|}。
令 \m{i=k-1}，有 \m{v_1.h\le t.h+k-1 < 0+|V|-1}。
現在就有矛盾了， \m{v_1.h \ge |V|-1} 和 \m{v_1.h < |V|-1}。
也就是說，引理 26.18 依然成立。

漸進分析沒什麼變化。
\stopANSWER

%e26.4-8
\startEXERCISE
設 \m{\delta_{f}(u,v)} 爲殘存網絡 \m{G_f} 中從節點 \m{u} 到節點 \m{v} 的距離（邊的條數）。
證明： \ALGO{GENERIC-PUSH-RELABEL} 維持性質 \m{u.h < |V|} 意味着 \m{u.h\le \delta_{f}(u,t)}，
維持性質 \m{u.h \ge |V|} 意味着 \m{u.h-|V|\le \delta_{f}(u,s)}。
\stopEXERCISE

\startANSWER
\TODO{略。}
\stopANSWER

%e26.4-9
\startEXERCISE\DIFFICULT
如前一個練習，設 \m{\delta_{f}(u,v)} 爲殘存網絡 \m{G_f} 中從節點 \m{u} 到節點 \m{v} 的距離。
請說明如何修改通用推送重貼標籤算法，
使其維持性質 \m{u.h<|V|} 意味着 \m{u.h=\delta_{f}(u,t)}，
維持性質 \m{u.h\ge |V|} 意味着 \m{u.h-|V|=\delta_{f}(u,s)}。
你所設計的算法中，維持該性質所用總時間應爲 \m{O(VE)}。
\stopEXERCISE

\startANSWER
\TODO{略。}
\stopANSWER

%e26.4-10
\startEXERCISE\DIFFICULT
證明：在流網絡 \m{G=(V,E)} 上運行 \ALGO{GENERIC-PUSH-RELABEL}，
非飽和推送的次數爲 \m{4|V|^{2}|E|}，假定 \m{|V|\ge 4}。
\stopEXERCISE

\startANSWER
\TODO{略。}
\stopANSWER

\stopsection

\startsection[
  title={The relabel-to-front algorithm},
]

%e26.5-1
\startEXERCISE
請以圖 26-10 所示的方式，
在圖 26-1（a）所示的流網絡上演示前置貼標籤算法的執行過程。
假設鏈表 \m{L} 中節點的最初順序是 \m{\langle v_1,v_2,v_3,v_4\rangle}，
並且各個鄰接鏈表的內容如下：
\startformula\startmathalignment
\NC v_1 \cdot N \NC = \langle s,v_2,v_3\rangle \NR
\NC v_2 \cdot N \NC = \langle s,v_1,v_3,v_4\rangle \NR
\NC v_3 \cdot N \NC = \langle v_1,v_2,v_4,t\rangle \NR
\NC v_4 \cdot N \NC = \langle v_2,v_3,t\rangle \NR
\stopmathalignment\stopformula
附圖 26-1（a）：

\externalfigure[output/e26_5_1-1]
\stopEXERCISE

\startANSWER

\externalfigure[output/e26_5_1-2]

\externalfigure[output/e26_5_1-3]

\externalfigure[output/e26_5_1-4]

\externalfigure[output/e26_5_1-5]

\externalfigure[output/e26_5_1-6]

\externalfigure[output/e26_5_1-7]

\externalfigure[output/e26_5_1-8]

\externalfigure[output/e26_5_1-9]

\externalfigure[output/e26_5_1-10]

\externalfigure[output/e26_5_1-11]

\externalfigure[output/e26_5_1-12]
\stopANSWER

%e26.5-2
\startEXERCISE\DIFFICULT
我們希望以如下方式來實現推送重貼標籤算法：
在算法中維持一個先進先出隊列，用來存放溢出節點。
算法重複將隊列頭部的節點進行釋放，
任何在釋放前沒有溢出但釋放後出現溢出的節點均被放置在隊列末尾。
在隊列頭部的節點被釋放後，該節點即被刪除。
當隊列爲空時，算法終止。
說明如何實現該算法，以在 \m{O(V^3)} 時間內計算出一個最大流。
\stopEXERCISE

\startANSWER
\TODO{略。}
\stopANSWER

%e26.5-3
\startEXERCISE
證明：如果 \ALGO{RELABEL} 操作對 \m{u.h} 的更新只是簡單地計算 \m{u.h=u.h+1}，
通用算法仍然能夠正確工作。
另外，請說明該變化對前置重貼標籤算法的分析有什麼影響。
\stopEXERCISE

\startANSWER
會增加循環次數。
\stopANSWER

%e26.5-4
\startEXERCISE\DIFFICULT
證明：如果總是釋放高度最高的溢出節點，
則可以使推送重貼標籤算法在 \m{O(V^3)} 時間內完成。
\stopEXERCISE

\startANSWER
\TODO{略。}
\stopANSWER

%e26.5-5
\startEXERCISE
假定在推送重貼標籤算法執行過程中，
某一時刻存在一個整數 \m{0\le k\le |V|-1}，
使得沒有任何一個節點的高度爲 \m{k} （即不存在節點 \m{v}，使得 \m{u.h=k}）。
證明：所有高度大於 \m{k} 的節點都位於某個最小切割的源節點這一邊。
如果存在這樣一個 \m{k}，
則{\EMP 跨越式啓發}（gap heuristic）會更新所有高度大於 \m{k} 的節點 \m{v\in V-\{s\}}，
將 \m{v.h} 設置爲 \m{\max(v.h,|V|+1}。
證明：結果屬性 \m{h} 是一個高度函數。
（實際上，跨越式啓發對於高效實現推送重貼標籤算法起着關鍵作用。）
\stopEXERCISE

\startANSWER
\TODO{略。}
\stopANSWER

\stopsection

\startsubject[
  title={Problems},
]

\stopsubject%Problems

\stopchapter
\stopcomponent

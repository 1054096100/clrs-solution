\startcomponent c_greedy_algorithms

\startchapter[
  title={Greedy Algorithms},
]

\startsection[
  title={An activity-selection problem},
]

%e16.1-1
\startEXERCISE
根據遞歸式（16.2）爲活動選擇問題設計一個動態規劃算法。
算法應該按前文定義計算最大兼容活動集的大小 \m{c[i,j]} 並生成最大集本身。
假定輸入的活動已按公式（16.1）排好序。
比較你的算法和 \ALGO{GREEDY-ACTIVITY-SELECTOR} 的運行時間。
附公式（16.1）：
\startformula
f_1 \le f_2 \le f_3 \le \ldots \le f_{n-1} \le f_n
\stopformula

附遞迴式（16.2）：
\startformula
c[i,j] = \startcases
\NC 0 \MC \text{如果 \m{S_{ij} = \Phi}} \NR
\NC \max_{a_k\in S_{ij}}\{c[i,k] + c[k,j] + 1\} \MC \text{如果 \m{S_{ij}\ne \Phi}} \NR
\stopcases\stopformula
\stopEXERCISE

\startANSWER
令 \m{S_{ij}} 爲兩個不相重疊的活動 \m{a_i} 和 \m{a_j} 的間隔。
下列算法將爲活動選擇問題構建一張表，
其中 \m{s} 和 \m{f} 分別是活動的起始和結束時間，長度均爲 \m{n}。

\CLRSH{BUILD-ACTIVITY-TABLE(s, f)}
\startCLRS
n = s.length
for i = 0 upto n
	c[i][i] = 0

for m = 2 upto n
	for i = 1 upto (n-m+1)
		j = (i+m-1)
		c[i][j] = 0

		for k = i+1 upto j-1
			if f[i] <= s[k] && f[k] <= s[j]
				q = (c[i][k] + c[k][j] + 1)
				if q > c[i][j]
					c[i][j] = q
					c[j][i] = k
return c
\stopCLRS

此算法總運行時間爲 \m{O(n^3)}，而貪婪算法運行時間爲 \m{O(n)}。
\stopANSWER

%e16.1-2
\startEXERCISE
假定我們不再一直選擇最早結束的活動，而是選擇最晚開始的活動，
前提仍然是與之前選出的所有活動兼容。
描述如何利用這一方法設計貪心算法，並證明算法會產生最優解。
\stopEXERCISE

\startANSWER
\CLRSH{GREEDY-ACTIVITY-SELECTOR-JMC(s,f)}
\startCLRS
n = s.length
A.push_front(a[n])
k = n

for m=(n-1) downto 1
	if f[m] <= s[k]
		A.push_front(a[m])
		k = m
\stopCLRS

建議的方式，選擇與開始最晚的活動，總是保持與之前選中的活動相兼容，
這確實是貪心算法，只是從後向前。

我們可以這樣來看：有活動集 \m{S=\{a_1,a_2,\ldots,a_n\}}，
其中 \m{a_i=[s_i,f_i)}，我們想通過選擇開始最晚的活動來得到最優方案，
當然要保證與之前選中的活動相兼容。
創建集合 \m{S'=\{a'_1,a'_2,\ldots,a'_n\}}，
其中 \m{a'_i=[f_i,s_i)}，即 \m{a'_i} 正好與 \m{a_i} 相反。
顯然，\m{\{a_{i_1},a_{i_2},\ldots,a_{i_k}\} \subseteq S} 的子集要想相互兼容，
當且僅當其對應的 \m{\{a'_{i_1},a'_{i_2},\ldots,a'_{i_k}\} \subseteq S'} 的子集也相互兼容。
因此， \m{S} 的最優解與 \m{S'} 的最優解可以相互直接映射。
\stopANSWER

%e16.1-3
\startEXERCISE
對於活動選擇問題，並不是所有貪心方法都能得到最大兼容活動子集。
請舉例說明，在剩餘兼容活動中選擇持續時間最短者不能得到最大集。
類似地，說明在剩餘兼容說動中選擇與其他剩餘活動重疊最少者，
以及選擇最早開始者均不能得到最優解。
\stopEXERCISE

\startANSWER
選擇持續時間最短活動：
\input{tbl/tbl16.1-3-1}
此方法會選擇 \m{\{a_2\}}，但最優解應爲 \m{\{a_1,a_3\}}。

選擇與其他活動重疊最少的活動：
\input{tbl/tbl16.1-3-2}
此方法會先選擇 \m{a_6}，然後只能選擇兩個： \m{a_1,a_2,a_3,a_4} 中的一個，
以及 \m{a_8,a_9,a_{10},a_{11}} 中的一個。而最優解爲 \m{a_1,a_5,a_7,a_{11}}。

選擇最早開始的活動：只要最早開始的活動持續時間足夠長，
就只能選擇這一個活動，其他的都無法與其兼容。
\stopANSWER

%e16.1-4
\startEXERCISE
假定右一組活動，我們需要將他們安排到一些教室，
任意活動都可以在任意教室進行。
我們希望使用最少的教室完成所有活動。
設計一個高效的貪心算法求每個活動應該在哪個教室進行。

（這個問題稱爲{\EMP 區間圖着色問題}（interval-graph color problem）。
我們可以構造一個區間圖，頂點表示給定的活動，
邊連接不兼容的活動。
要求用最少的顏色對頂點進行着色，
使得所有相鄰頂點顏色均不相同——
這與使用最少的教室完成所有活動的問題是對應的。）
\stopEXERCISE

\startANSWER
集合 \m{S} 包含 \m{n} 個活動。
一個顯而易見的方案：使用 \ALGO{GREEDY-ACTIVITY-SELECTOR}，
先爲第一個教室找到最大集合 \m{S_1} （\m{S_1\subseteq S}），
再爲第二個教室找到最大集合 \m{S_1} （\m{S_1\subseteq S - S_1}），
……。最壞情況下需要時間 \m{\Theta(n^2)}。

還有一種更好的算法，然而，其漸進時間只是將活動按時間排序所需的時間 \m{O(n\lg n)}。
如果活動的時間是小整數，甚至有可能達到 \m{O(n)}。

通常我們會按起始時間遍歷所有活動，並將其指派給任何一個可用的教室。
要達到這個目的，我們需要對活動的起始時間和結束時間進行排序，並遍歷所有時間點。
維護兩個教室清單：一個是當前時間點 \m{t} 忙的教室，另一個是當前時間點 \m{t} 空閒的教室。
如果 \m{t} 是某個活動的結束時間點，，則將此活動所佔教室挪到空閒清單中。
如果 \m{t} 是另一個活動的起始時間點，則可以將這個活動安排到一個空閒的教室中。

爲了儘量減少教室佔用，活動結束時將教室放入空閒清單的頭部，爲活動安排教室也從空閒教室頭部選取。

運行時間包括兩部分： a）爲活動起始、結束時間排序。
（如果某活動的結束時間和某活動起始時間相同，則應將結束的活動放在前面。）
所需時間爲 \m{O(n\lg n)}，而如果活動所用時間是受限的（比如，都是小整數），
則所需時間可能是 \m{O(n)}。
 b）處理所有起始、結束時間點所需時間爲 \m{O(n)}：掃描 \m{2n} 個時間點，
 每個時間點的時間爲 \m{O(1)}。
\stopANSWER

%e16.1-5
\startEXERCISE
考慮活動選擇問題的一個變形：
每個活動 \m{a_i} 除了開始和結束時間外，
還有一個值 \m{v_i}。
目標不再是求規模最大的兼容活動子集，
而是求值之和最大的兼容活動子集。
也就是說，
選擇一個兼容活動子集 \m{A}，使得 \m{\sum_{a_k\in A} v_k} 最大化。
設計一個多項式時間的算法求解此問題。
\stopEXERCISE

\startANSWER
動態規劃。時間爲 \m{O(n^2)}。
\stopANSWER

\stopsection

\startsection[
  title={Elements of the greedy strategy},
]

\startEXERCISE
證明：分數揹包問題具有貪心選擇性質。
\stopEXERCISE

\startANSWER
設商品數量爲 \m{n}，序號爲 \m{i\in \{1,2,\ldots,n\}} 的商品
價值爲 \m{v_i}，重量爲 \m{w_i}。
揹包能承重 \m{W}。目標是讓揹包中的商品價值最大。
不必將整個商品都放到揹包內。
即如果可以將價值最大化，可以只將商品的一部分放入揹包。
先計算每個商品的價值密度，即 \m{v_i / w_i}。
按價值密度對所有商品進行排序。
設商品 \m{j} 的價值密度最大。

\startigBase[n]
\item Case 1：如果 \m{W=w_j}，則將商品 \m{j} 放入揹包，問題結束；
\item Case 2：如果 \m{W<w_j}，則將儘量多的 \m{j} 放入揹包，問題結束；
\item Case 3：如果 \m{W>w_j}，則將商品 \m{j} 放入揹包後。然後揹包還可以放入重量 \m{W-w_j} 的商品。
後面採用貪心策略繼續解決子問題：揹包能承重 \m{W-w_j}，有 \m{n-1} 個商品共選擇。
需要注意的是，選擇 \m{j} 時不必考慮子問題的解。
\stopigBase

因此 0-1 揹包問題具有貪婪選擇性質。
\stopANSWER

%e16.2-2
\startEXERCISE
設計動態規劃算法求解 0-1 揹包問題，要求運行時間爲 \m{O(nW)}， \m{n} 爲商品數量，
揹包最大承重爲 \m{W}。
\stopEXERCISE

\startANSWER
\m{w} 和 \m{v} 長度均爲 \m{n}；
 \m{W} 是揹包的最大承重；
 \m{B} 是 \m{(w+1)\times(n+1)} 矩陣；
 \m{B[i][j]} 是揹包最大承重爲 \m{j}、只能在前 \m{i} 個商品中選擇時所能得到的最大價值。

\CLRSH{KNAPSACK(w, v, W, n)}
\startCLRS
\\ initialization B[i,j]:
\\ i is index of items, j is weight
for i=1 to n
	B[i,0] = 0
for j=0 to W
	B[0,j] = 0

for i=1 to n
	for j=0 to W
		if w[i] <= j
			B[i,j] = max((v[i] + B[i-1, j-w[i]]), B[i-1,w])
		else
			B[i,j] = B[i-1,w]
\stopCLRS

\CLRSH{KNAPSACK-ITEMS(v, w, B)}
\startCLRS
i=n
k=W

while i>0 and k>0
	if B[i,k] != B[i-1,k]
		add item i in the knapsack
		k = k - w[i]
	--i
\stopCLRS

\stopANSWER

%e16.2-3
\startEXERCISE
假定在 0-1 揹包問題中，商品越重，價值越小，
設計一個高效算法求解此變形問題的最優解，
並證明算法的正確性。
\stopEXERCISE

\startANSWER
按重量由輕到重選擇 \m{k} 個商品，
使得 \m{\sum_{i=1}^k w[i] \le W} 且 \m{\sum_{i=1}^{k+1} w[i] > W}，這就是最優解。
如果這 \m{k} 個商品中第 \m{j} 個沒有被選中，而 \m{i>k} 被選中，
則我們可以將 \m{i} 換成 \m{j}，總重量不增加但價值會增加。
\stopANSWER

%e16.2-4
\startEXERCISE
Gekko 教授計劃沿 U.S. 2 號高速公路用直排輪滑橫穿 North Dakota，
這條高速公路從 Minnesota 東部邊境的 Grand Forks 一直到達 Montana 西部邊境的 Williston。
教授能夠帶兩公升水，在喝光之前能滑行 \m{m} 英里。
（North Dakota 相當平坦，教授無需擔心上坡路段喝水速度比平地或下坡路段快。）
教授從 Grand Forks 出發，並攜帶兩公升水。
地圖上顯示了高速公訴上所有補給點，以及他們之間的距離。

教授的目標是儘量減少途中補充水的次數。
設計一個高效的方法，幫助教授確定應該在哪些地點補充水。
證明你的策略會生成最優解，並分析其運行時間。
\stopEXERCISE

\startANSWER
我們需要選擇補給站，每次選擇的補給站離上一個的距離應離 \m{m} 最近但不大於 \m{m}。

首先，此問題的解包含子問題的最優解。
令 \m{S} 爲解， \m{G} 爲選中的某個補給站。
如果從起點到 \m{G} 之間，教授停下的次數不是最少，
則我們可以有一個更好的解。
但 \m{S} 是最優解，所以 \m{S} 包含子問題的最優解。

下面來證明貪心選擇會得到最優解。
令貪心選擇法選中的補給站爲 \m{G_1,G_2,\ldots,G_k}，且這不是最優解。
則最優解中的第一個站點 \m{O_1} 不是 \m{G_1} 就是 \m{G_1} 之前的站點，
否則從起點到 \m{O_1} 的距離會超過 \m{m}。
由於 \m{O_1} 到 \m{O_2} 的距離小於 \m{m}，
因此 \m{O_2} 不是 \m{G_2} 就是 \m{G_2} 之前的站點。
以此類推， \m{O_k} 不是 \m{G_k} 就是 \m{G_k} 之前的站點。
從而最優解選中站點個數不會少於貪心選擇法的解。
即，貪心選擇法的解就是最優解。

貪心選擇法的運行時間爲 \m{O_n}，其中 \m{n} 爲站點總數。
\stopANSWER

%e16.2-5
\startEXERCISE
設計一個高效算法，對實數線上給定的一個點集 \m{\{x_1,x_2,\ldots,x_n\}}，
求一個單位長度閉區間的集合，包含所有給定的點，並要求此集合最小。
證明你的算法是正確的。
\stopEXERCISE

\startANSWER
貪心選擇法。先對所有點排序，然後以第一個點爲閉區間的起點，
找到單位長度閉區間中最後一個點；以上一個閉區間後面緊挨的點爲新區間的起點，
往後依次搜索。直到遍歷完所有點，得到的區間個數即爲所求。
\stopANSWER

%e16.2-6
\startEXERCISE\DIFFICULT
設計算法，在 \m{O(n)} 時間內求解分數揹包問題。
\stopEXERCISE

\startANSWER
先按 \m{v/w} 從大到小排序，然後依次累加，直到重量超標。
除最後一個外，其他累計物品即爲所求。
\stopANSWER

%e16.2-7
\startEXERCISE
給定兩個集合 \m{A} 和 \m{B}，各包含 \m{n} 個正整數。
你可以按需要任意重排每個集合。
重排後，令 \m{a_i} 爲集合 \m{A} 的第 \m{i} 個元素，
 \m{b_i} 爲集合 \m{B} 的第 \m{i} 個元素。
於是你得到回報 \m{\prod_{i=1}^{n}a_i^{b_i}}。
設計算法使回報最大化。
證明算法的正確性，並分析運行時間。
\stopEXERCISE

\startANSWER
將兩個集合均按單調遞減進行排序。

任取兩個索引 \m{i}、 \m{j}，其中 \m{i<j}。
則 \m{a_i^{b_i} \times a_j^{b_j} \ge a_i^{b_j}\times a_j^{b_i}}。
\stopANSWER

\stopsection

\startsection[
  title={Huffman codes},
]

%e16.3-1
\startEXERCISE
在證明引理 16.2 過程中，如果 \m{x.freq = b.freq}，
則 \m{a.freq = b.freq = x.freq = y.freq}，爲什麼？
\stopEXERCISE

\startANSWER
\m{x} 和 \m{y} 是頻度最低的兩個字符，則由於 \m{a.freq \le b.freq}，可知 \m{y.freq \le b.freq}。
又由於 \m{x.freq = b.freq}，因此 \m{y.freq \le x.freq}；
再者 \m{x.freq \le y.freq}，所以 \m{x.freq = y.freq}。
而 \m{a.freq \le b.freq = x.freq}，因爲 \m{x} 的頻度最低，
所以 \m{x.freq \le a.freq}，即 \m{x.freq \le a.freq \le x.freq}，
所以 \m{a.freq = x.freq}。
\stopANSWER

%e16.3-2
\startEXERCISE
證明：亦可不滿的二叉樹不可能對應一個最優前綴碼。
\stopEXERCISE

\startANSWER
對於只有一個字節點的節點，將其字節點提升爲兄弟節點，必然更優。
\stopANSWER

%e16.3-3
\startEXERCISE
如下所示： 8 個字符對應的出現頻率是 Fibonacci 數列的前 8 個數，
其 Huffman 編碼是什麼？

a:1 b:1 c:2 d:3 e:5 f:8 g:13 h:21

其結論是否可以推廣，求頻度爲 Fibonacci 數列的最優前綴碼？
\stopEXERCISE

\startANSWER
結論可以推廣，用數學歸納法。

\externalfigure[output/e16_3_3-1]
\stopANSWER

%e16.3-4
\startEXERCISE
證明：編碼樹的總代價還可以表示爲所有內部節點的兩個孩子節點的聯合頻率之和。
\stopEXERCISE

\startANSWER
公式 16.4：
\startformula
B(T) = \sum_{c\in C} f(c)d_{T} (c)
\stopformula

如果改成計算內部節點的孩子節點聯合頻率，
對於任何一個葉子節點 \m{c} 而言，每一個祖先都會計算一次 \m{f(c)}，
總共 \m{d_{T} (c)} 次。因此結果與公式 16.4 一樣。
\stopANSWER

%e16.3-5
\startEXERCISE
證明：如果我們將字母表中字符按頻率單調遞減排序，
那麼存在一個最優編碼，其碼字長度是單調遞增的。
\stopEXERCISE

\startANSWER
反證法。
\stopANSWER

%e16.3-6
\startEXERCISE
假定我們有字母表 \m{C=\{0,1,\ldots,n-1\}} 上的一個最優前綴碼，
我們希望用最少的二進制位傳輸此編碼。
說明如何僅用 \m{2n-1+n\left\lceil \lg n\right\rceil} 位表示 \m{C} 上的任意最優前綴碼。
（\hint 通過對樹的遍歷，用 \m{2n-1} 位說明編碼樹的結構。）
\stopEXERCISE

\startANSWER
深度優先遍歷整棵樹，每個葉子節點的值用 \m{\left\lceil \lg n\right\rceil} 位表示，
內部節點用 1 表示，葉子節點用 0 表示，共 \m{n-1} 個內部節點， \m{n} 個葉子節點。
\stopANSWER

%e16.3-7
\startEXERCISE
推廣 Huffman 算法，使之能生成三進制的碼字（即碼字由符號 0、 1、 2 組成），
並證明此算法能生成最優三進制碼。
\stopEXERCISE

\startANSWER
改成每次取頻率最小的三個節點組成一個新節點。
新節點的頻率爲三個子節點頻率之和。
但如果總數爲偶數，最後剩餘節點個數會小於 3，從而無法形成完整的三叉樹，
解決辦法是先增加一些頻率爲 0 的葉子節點，從而使得總數爲 \m{(k-1)t + 1}；
其中 \m{k} 代表是 \m{k} 叉樹，此時是 3， \m{t} 爲任意正整數。
\stopANSWER

%e16.3-8
\startEXERCISE
假定一個數據文件由 8 位字符組成，
其中有 256 個字符出現的頻率大致相同：
最高的頻率也低於最低頻率的 2 倍。
證明：在此情況下， Huffman 編碼並不比 8 位固定長度編碼更高效。
\stopEXERCISE

\startANSWER
令最小頻率爲 \m{f_{\min}}：
\startformula
B(T) = \sum_{c\in C}f(c) d_{T}(c) \ge \sum_{c\in C} f_{\min} \times d_{T}(c) = f_{\min}\times\sum_{c\in C}d_{T}(c)
\stopformula

其中 \m{\sum_{c\in C}d_{T}(c)} 是葉子節點高度之和。
當 T 爲完全平衡二叉樹的時候，他取得最小值。
因此：
\startformula
B(T) \ge f\times \sum_{c\in C} d_{T}(c) \ge f\times 256 \times 9
\stopformula

而直接只用 8 位編碼的話，則：
\startformula
B(T') = \sum_{c\in C} 8 \times f(c)\le \sum_{c\in C} 8 \times 2 \times f = 256 \times 8 \times 2 \times f
\stopformula
\stopANSWER

%e16.3-9
\startEXERCISE
證明：對於一個由隨機生成的 8 位字符組成的文件，
沒有任何壓縮方法可以將其壓縮，哪怕只是壓縮一位。
（\hint 比較原始文件和編碼後文件可能的數量。）
\stopEXERCISE

\startANSWER
假設原始文件有 \m{n} 位，壓縮後的文件小於 \m{n} 位。
源文件有 \m{2^n} 種。壓縮後的文件最多有 \m{2^1 + 2^2 + \ldots + 2^{n-1} < 2^n} 種。
即至少有兩種原始文件壓縮後內容相同，這顯然是不可能的，
因此壓縮後的文件程度必定有大於 \m{n} 的。
\stopANSWER

\stopsection

\startsection[
  title={Matroids and greedy methods},
]

%e16.4-1
\startEXERCISE
證明：若 \m{S} 是任意一個有限集， \m{I_k} 是 \m{S} 的所有規模不超過 \m{k} 的子集的集合（\m{k\le |S|}），
則 \m{(S, I_k)} 是一個擬陣。
\stopEXERCISE

\startANSWER
\TODO{}
\stopANSWER

%e16.4-2
\startEXERCISE\DIFFICULT
給定某個域（如實數域）上的 \m{m\times n} 矩陣 \m{T}，
證明： \m{(S, I)} 是一個擬陣，其中 \m{S} 是 \m{T} 的列的集合，
且 \m{A\in I} 當且僅當 \m{A} 中的列是線性無關的。
\stopEXERCISE

\startANSWER
\TODO{}
\stopANSWER

%e16.4-3
\startEXERCISE
證明：若 \m{(S, I)} 是一個擬陣，則 \m{(S, I')} 也是一個擬陣，其中
\startformula
I' = \{ \text{\m{A'}： \m{S-A'} 包含某些最大獨立子集 \m{A\in I}} \}
\stopformula
即 \m{(S,I')} 的最大獨立子集恰好是 \m{(S,I)} 的最大獨立子集的補集。
\stopEXERCISE

\startANSWER
\TODO{}
\stopANSWER

%e16.4-4
\startEXERCISE\DIFFICULT
令 \m{S} 是一個有限集， \m{S_1,S_2,\ldots,S_k} 是 \m{S} 的一個劃分，
這些集合都是非空且不相交的。
定義結構 \m{(S,I)} 滿足條件 \m{I=\{ A: |A\cap S_i|\le 1, i=1,2,\ldots,k \}}。
證明： \m{(S,I)} 是一個擬陣。
也就是說，與劃分中所有子集都最多有一個共同元素的集合 \m{A} 組成的集合構成了擬陣的獨立集。
\stopEXERCISE

\startANSWER
\TODO{}
\stopANSWER

%e16.4-5
\startEXERCISE
對於一個所需最優化解爲{\EMP 最小權重}最大獨立子集的加權擬陣問題，
如何將其權重函數進行轉換，
使其變爲標準的加權擬陣問題。
詳細論證你的轉換方法是正確的。
\stopEXERCISE

\startANSWER
\TODO{}
\stopANSWER

\stopsection

\startsection[
  title={A task-scheduling problem as a matroid},
  reference=section:task_schedule,
]

%e16.5-1
\startEXERCISE
對圖 16-7 給出的調度問題的實例，
將每個懲罰值 \m{\omega_i} 替換爲 \m{80 - \omega_i}，
求解修改後的問題。
\stopEXERCISE

\startANSWER
\TODO{}
\stopANSWER

%e16.5-2
\startEXERCISE
說明如何利用引理 16.12 的性質 2 在 \m{O(|A|)} 時間內
確定一個給定任務集合 \m{A} 是獨立的。
\stopEXERCISE

\startANSWER
\TODO{}
\stopANSWER

\stopsection

\startsubject[
  title={Problems},
]

%p16-1
\startPROBLEM
（Coin changing）
考慮用最少的硬幣找 \m{n} 美分零錢的問題。
假定每種硬幣的面額都是整數。
\startigBase[a]
\startitem
設計貪心算法求解找零問題，
假定有 25 美分、 10 美分、 5 美分和 1 美分 4種面額的硬幣。
證明你的算法能找到最優解。
\stopitem
\startANSWER
\CLRSH{MAKE-CHANGE(M)}
\startCLRS
for i = k downto 1
	Q[i] = ceil(M / d[i])
	M = M - Q[i] * d[i]
\stopCLRS
\stopANSWER

\startitem
假定硬幣面額是 \m{c} 的冪，
即面額爲 \m{c^0,c^1,\ldots,c^k}，
其中 \m{c} 和 \m{k} 爲整數， \m{c>1}、 \m{k\ge 1}。
證明：貪心算法總能得到最優解。
\stopitem

\startANSWER
\startformula
M = \sum_{i=1}^k Q[i] \times d[i]
\stopformula
總的硬幣數目爲 \m{\sum_{i=1}^k n[i]}。
對於任意 \m{i < k}，都有 \m{Q[i] < c}。
否則，如果 \m{Q[i]\ge c}，
我們可以將 \m{Q[i]} 減小 \m{c}，
並將 \m{Q[i+1]} 增加 1。

下面來證明貪心算法會得到最優解。
令最優解中各面值硬幣數目爲 \m{O[i]}。
令 \m{j} 第一個（最大的）滿足 \m{Q[j]\ne O[j]}。
我們知道 \m{Q[j]>O[j]}，
因爲貪心算法始終會曲最大數目的硬幣。
如果 \m{O[j]>Q[j]}，則最優解找零會超過 \m{M}。

\startformula\startmathalignment
\NC \sum_{i=1}^{j}O[i]\times d_i = \NC \sum_{i=1}^{j}Q[i]\times d_i \NR
\NC O[j]\times d_j + \sum_{i=1}^{j-1}O[i]\times d_i = \NC \sum_{i=1}^{j-1}Q[i]\times d_i + Q[j] \times d_j\NR
\NC \sum_{i=1}^{j-1}O[i]\times d_i = \NC \sum_{i=1}^{j-1}Q[i]\times d_i + (Q[j] -O[j]) \times d_j\NR
\NC \sum_{i=1}^{j-1}O[i]\times d_i = \NC \sum_{i=1}^{j-1}Q[i]\times d_i + (Q[j] -O[j]) \times c^{j-1}\NR
\NC \sum_{i=1}^{j-1}O[i]\times d_i - \sum_{i=1}^{j-1}Q[i]\times d_i = \NC (Q[j] -O[j]) \times c^{j-1} > c^{j-1}\NR
\stopmathalignment\stopformula

如果對於 \m{i=1,2,\ldots,j-1}，滿足 \m{O[i] < c}，則：
\startformula\startmathalignment
\NC     \NC \sum_{i=1}^{j-1}O[i]\times d_i \NR
\NC \le \NC \sum_{i=1}^{j-1}(c-1)\times c^{i-1} \NR
\NC   = \NC (c-1) \sum_{i=1}^{j-1} c^{i-1} \NR
\NC   = \NC (c-1) \sum_{i=0}^{j-2} c^i \NR
\NC   = \NC (c-1) \frac{c^{j-1}-1}{c-1} \NR
\NC   = \NC c^{j-1} - 1
\stopmathalignment\stopformula
這與上面得到的 \m{\sum_{i=1}^{j-1}O[i]\times d_i > c^{j-1}} 矛盾。因此最優解中編號爲 1 到 \m{j-1} 的硬幣中，必定有一種面值的硬幣個數達到或超過了 \m{c}。
但是如上所述，這樣的話就不可能是最優的了。

因此，貪心算法的解必定是最優解。
\stopANSWER

\startitem
設計一組硬幣面額，使得貪心算法不能保證得到最優解。
這組硬幣面額中應該包含 1 美分，
使得對每個值都存在找零方案。
\stopitem

\startANSWER
面額爲 \m{10,9,1}。
貪心算法解爲 \m{2+7=9} 個硬幣，而最優解爲 3 個硬幣。
\stopANSWER

\startitem
設計一個 \m{O(nk)} 時間的找零算法，
適用於任何 \m{k} 種不同面額的硬幣，
假定總是包含 1 美分硬幣。
\stopitem

\startANSWER
使用動態規劃。
令找零 j 美分至少需要 \m{c[j]} 枚硬幣。
\startformula
c[j] = \startcases
\NC 0 \MC \text{如果 \m{j\le 0}；} \NR
\NC 1 + \min_{1\le i \le k}\{c[j-d_i]\} \MC \text{如果 \m{j>1}。} \NR
\stopcases\stopformula
\stopANSWER

\stopigBase
\stopPROBLEM

%p16-2
\startPROBLEM
（Scheduling to minimize average completion time）
給定任務集合 \m{S=\{a_1,a_2,\ldots,a_n\}}，
其中任務 \m{a_i} 需要時間爲 \m{p_i}。
用於執行這些任務的計算機，一次只能執行一個任務。
令 \m{c_i} 表示任務 \m{a_i} 的{\EMP 完成時間（completion time）}。
目標是使得平均完成時間最小，即 \m{(1/n)\sum_{i-1}^{n}c_i} 最小。
例如，有兩個任務 \m{a_1} 和 \m{a_2}， \m{p_1=3}， \m{p_2=5}，
如果先執行 \m{a_2}，則 \m{c_2=5,c_1=8}，平均完成時間爲 \m{(5+8)/2=6.5}。
如果先執行 \m{a_1}，則 \m{c_1=3,c_2=8}，平均完成時間爲 \m{(3+8)/2=5.5}。

\startigBase[a]
\startitem
設計算法，求解調度方案，使得平均完成時間最小。
執行任務時不允許搶佔，即一旦開始一個任務，必須等其執行完後才能執行另一個任務。
證明算法的正確性，並分析其運行時間。
\stopitem

\startANSWER
輸入：任務集合 \m{\{a_i\}}， \m{1\le i\le n}。 \m{a_i} 的執行時間爲 \m{p_i}。
如果任務按 \m{a_1,a_2,\ldots,a_n} 的順序執行，則 \m{a_k} 的完成時間爲：
\startformula
c_k = \sum_{i=1}^{k}p_i
\stopformula

直覺：如果先執行處理時間長的任務，則之後的所有任務的完成時間都會增加，
因此先執行處理時間短的任務是比較明智的。

貪婪算法：首先將任務按處理時間遞增順序排序，
即使得 \m{p_1 \le p_2 \le \ldots \le p_n}。
然後按 \m{\{a_1,a_2,\ldots,a_n\}} 的順序執行任務。
排序時間爲 \m{O(n\lg n)}，執行任務時間固定或者爲 \m{O(n)}（用於選擇任務）。
總用時爲 \m{O(n\lg n)}。

正確性的證明：假設按序列 \m{a_1 a_2 \ldots a_m \ldots a_n} 的順序執行任務，
其中 \m{a_m} 的處理時間最少。
則我們可以調換 \m{a_1} 和 \m{a_m}，
按 \m{a_m a_2 \ldots a_{m-1} a_1 a_{m+1} \ldots a_n} 的順序執行任務。
重新排序後的平均完成時間要少於原來順序的平均完成時間。
\startformula\startmathalignment[n=1, m=3, align={left,left,left}, distance=2em]
\NC n \NC p_1 \NC p_m \NR
\NC n-1 \NC p_2 \NC p_2 \NR
\NC \ldots \NC \ldots \NC \ldots \NR
\NC n-(m-2) \NC p_{m-1} \NC p_{m-1} \NR
\NC n-(m-1) \NC p_m \NC p_1 \NR
\NC n-m \NC p_{m+1} \NC p_{m+1} \NR
\NC \ldots \NC \ldots \NC \ldots \NR
\NC 1 \NC p_n \NC p_n \NR
\stopmathalignment\stopformula

我們可以按每個任務對總完成時間的貢獻來考慮，這個貢獻只與任務的執行順序有關。
假設任務 \m{i} 的在執行順序中的位置爲 \m{j}，則其貢獻爲 \m{p_i \times (n-(j-1))}。
這樣我們再來比較這兩種執行順序，則只有 \m{a_1} 和 \m{a_m} 的貢獻發生了變化，
其餘任務對總完成時間的貢獻不變。
由於 \m{p_m < p_1}，則 \m{n p_1 + (n-(m-1)) p_m > n p_m + (n-(m-1)) p_1}，
因此重新排序後總完成時間變少了，
這樣一直執行剩餘任務中執行時間最少的，就可以滿足要求。

\stopANSWER

\startitem
現在假定任務並不是立刻就可以開始執行，
每個任務都有一個{\EMP 釋放時間（release time）} \m{r_i}，
在此時間之後才可以開始。
此外假定任務執行是可以{\EMP 搶佔的（preemption）}，
這樣可以將任務掛起，稍後再重新開始。
例如，任務 \m{a_i} 的運行時間爲 \m{p_i=6}，
釋放時間爲 \m{r_i=1}，
他可能在時刻 1 開始運行，在時刻 4 被搶佔。
然後在時刻 10 恢復運行，
在時刻 11 再次被搶佔，
最後在時刻 13 恢復運行，
在時刻 15 運行完畢。
任務 \m{a_i} 共運行了 6 個時間單位，
但運行時間被分割成三部分。
在此情況下， \m{a_i} 的完成時間爲 15。
設計算法，對此問題求解平均完成時間最小的調度方案。
證明完成時間確實最小，並分析算法的運行時間。
\stopitem

\startANSWER
任意時刻 \m{t}，在 \m{r_i \le t} 的任務中選擇{\EMP 剩餘}時間最小的運行。
由於可搶佔，我們可以在任意時刻執行這個動作。
實際上，只需要在有新任務準備好，以及某個任務執行完畢時才需要做此動作。
也就是說一旦開始執行任務，如果沒有新任務準備好，
則可以一直執行完畢（此過程中，當前任務的剩餘時間一直是最小）。
即一旦有新任務，則要做插入排序，新任務和當前正在執行且沒有執行完的任務都需要插入。
此算法運行時間爲 \m{O(n\lg n)}。
\stopANSWER

\stopigBase
\stopPROBLEM

%p16-3
\startPROBLEM
（Acyclic subgraphs）
\startigBase[a]
\startitem
有無向圖 \m{G=(V,E)}，其{\EMP 關聯矩陣（incidence matrix）}是一個 \m{|V|\times|E|} 的矩陣 \m{M}，
若邊 \m{e} 與頂點 \m{v} 關聯，則 \m{M_{ve}=1}，否則 \m{M_{ve}=0}。
論證當且僅當對應的邊集無環時， \m{M} 的列集合在整數模 2 的域上線性無關。
\stopitem

\startANSWER
\TODO{}
\stopANSWER

\startitem
假定我們對一個無向圖 \m{G=(V,E)} 的每條邊都關聯一個非負權重 \m{\omega(e)}。
設計一個高效算法，求權重之和最大的無環邊集。
\stopitem

\startANSWER
\TODO{}
\stopANSWER

\startitem
令 \m{G=(V,E)} 是任意的有向圖，定義 \m{(E,\cal{I})} 滿足 \m{A\in \cal{I}} 當且僅當 \m{A} 不包含任何有向環。
給出一個有向圖 \m{G} 的例子，使得關聯的系統 \m{(E, \cal{I})} 不是一個擬陣。
指出定義中哪個條件使得系統 \m{(E,\cal{I})} 不是擬陣。
\stopitem

\startANSWER
\TODO{}
\stopANSWER

\startitem
無自環的有向圖 \m{G=(V,E)} 的{\EMP 關聯矩陣}是一個 \m{|V|\times|E|} 的矩陣 \m{M}，
若邊 \m{e} 從頂點 \m{v} 發出，則 \m{M_{ve}=-1}，
若邊 \m{e} 指向頂點 \m{v}，則 \m{M_{ve}=1}，否則 \m{M_{ve}=0}。
證明：如果 \m{M} 的一個列集合線性無關，那麼對應的邊集不包含有向環。
\stopitem

\startANSWER
\TODO{}
\stopANSWER

\startitem
練習 16.4-2 告訴我們任意矩陣 \m{M} 的線性無關的列集合的集合構成一個擬陣。
仔細解釋 (c) 和 (e) 的結果爲什麼不矛盾。
什麼情況下邊集無環與關聯矩陣中對應列集合線性無關
這兩個問題間沒有完美的對應關係？
\stopitem

\startANSWER
\TODO{}
\stopANSWER
\stopigBase
\stopPROBLEM%p16-3

%p16-4
\startPROBLEM
（Scheduling variations）
對\refsection{task_schedule} 中帶截止時間和懲罰的單位時間任務調度問題，
考慮如下算法。
初始時另 \m{n} 個時間槽均爲空，時間槽 \m{i} 爲單位時間長度，結束於時刻 \m{i}。
我們按懲罰值單調遞減的順序處理所有任務。
當處理任務 \m{a_j} 時，如果存在不晚於 \m{a_j} 的截止時間 \m{d_j} 的空時間槽，
則將 \m{a_j} 分配到其中最晚的那個。
如果不存在這樣的時間槽，將 \m{a_j} 分配到最晚的空時間槽。
\startigBase[a]
\startitem
證明：此算法總能得到最優解。
\stopitem

\startANSWER
此算法本質上只是\refsection{task_schedule} 中所給算法的一種實現。
此算法中，我們將任務放入沒有懲罰的最晚的空槽。
如果沒有這樣的時間槽，我們則將其放入最晚的空槽。
這種算法是所有方案中最極端的一個。
如果這種算法無法爲某個任務找到可用的時間槽，則換任何調度算法都沒用。
\stopANSWER

\startitem
利用\refsection{disjoint_set_op} 提出的快速不相交集合森林來高效實現此算法。
假定輸入任務集合已經按懲罰值單調遞減的順序排序。
分析實現程序的運行時間。
\stopitem

\startANSWER
\TODO{}
\stopANSWER
\stopigBase
\stopPROBLEM

%p16-5
\startPROBLEM
（off-line caching）
現代計算機用 cache 將少量數據存儲在快速存儲器中。
雖然程序可能訪問大量數據，
但通過將主存中少量數據保存在{\EMP cache} —— 容量小但更快的存儲器中，
還是可以大幅降低總體存取時間。
當一個計算機程序運行時，
他會訪問 \m{n} 次存儲器，順序爲 \m{\langle r_1,r_2,\ldots,r_n\rangle}，
每次請求存取一個特定數據元素。
例如，一個程序存取 4 個不同元素 \m{\{a,b,c,d\}}，
存取序列爲 \m{\langle d,b,d,b,d,a,c,d,b,a,c,b\rangle}。
令 \m{k} 爲 cache 的規模。
當 cache 已經保存了 \m{k} 個元素，而程序存取第 \m{k+1} 個元素時，
系統必須決定，對於本次以及後續的存取請求，
要將哪 \m{k} 個元素保存在 cache 中。
更準確地說，對每個請求 \m{r_i}， cache 管理算法檢查元素 \m{r_i} 是否已經在 cache 中。
如果找到了，則產生一次 {\EMP cache hit}；
否則，產生一次 {\EMP cache miss}。
若未找到，則從主存中提取 \m{r_i}，
同時 cache 管理算法必須決定是否將 \m{r_i} 保留在 cache 中。
如果算法決定保留 \m{r_i} 且 cache 中已經保存了 \m{k} 個元素，
則他必須將某個元素逐出 cache 爲 \m{r_i} 騰出空間。
 cache 管理算法逐出數據的目標是在處理整個訪問請求序列的過程中儘量減少 cache miss 的次數。

通常， cache 管理是一個在線問題。
也就是說，我們在決定將哪些數據保留在 cache 中時，
並不知道未來的請求是什麼。
但是，我們這裏考慮此問題的離線版本，
即預先知道完整的請求序列（包含 \m{n} 個訪問請求）及 cache 的規模 \m{k}，
目標仍然是最小化 cache miss 的次數。

我們可以用一種稱爲 {\EMP furthest-in-future} 的貪心策略求解此問題，
此策略選擇逐出 cache 中數據的方法是選擇在請求序列中下一次訪問距離最遠的數據。
\startigBase[a]
\startitem
編寫使用將來最遠策略的 cache 管理器的僞碼。
輸入是請求序列 \m{\langle r_1,r_2,\ldots,r_n\rangle} 和 cache 規模 \m{k}，
輸出是決策結果序列——處理每個請求時逐出 cache 的是哪個數據（如果需要的話）。
分析算法的運行時間。
\stopitem

\startANSWER
\CLRSH{FURTHEST-IN-FUTURE(r, k)}
\startCLRS
/// r[1-n] : array of data request
/// o[1-n] : array of kick out
/// c[1-k] : array of cache
/// l : cache content number
l = 0
for i = 1 to n
	j = 1
	while j <= l
		if c[j] == r[i]
			break
		++j
	if j <= l
		print "cache hit"
	else
		print "cache miss"
		if l < k
			++l
			c[l] = r[i]
		else	/// cache full
			dfurther = 0	/// distance
			jfurther = 0	/// cache index
			j = 1
			while j <= k
				p = i + 1
				while p <= n
					if r[p] == c[j]
						break
				if p > n	/// no further use
					jfurther = j
					break
				else
					if p - i > dfurther
						dfurther = p - i
						jfurther = j
			o[i] = c[j]
			c[j] = r[i]
\stopCLRS

外循環 n 次，內循環 k 次，內循環中每次迭代最壞情況需 \m{n-i} 次。
總時間爲：
\startformula
\sum_{i=1}^{n}k(n-i) = \frac{kn(n-1)}{2} = O(kn^2)
\stopformula
\stopANSWER

\startitem
證明：此問題具有最優子結構性質。
\stopitem

\startANSWER
\TODO{}
\stopANSWER

\startitem
證明：將來最遠策略可以保證 cache miss 的次數最小。
\stopitem

\startANSWER
參考 \from[urlgreedyalgo]。
\stopANSWER
\stopigBase
\stopPROBLEM

\stopsubject%Problems

\stopchapter
\stopcomponent

\startcomponent c_minimum_spanning_trees

\startchapter[
  title={Minimum Spanning Trees},
]

\startsection[
  title={Growing a minimum spanning tree},
]

%e23.1-1
\startEXERCISE
設 \m{(u,v)} 是連通圖 \m{G} 中的一條權重最小的邊，證明：
邊 \m{(u,v)} 爲圖 \m{G} 的某棵最小生成樹中的一條邊。
\stopEXERCISE

\startANSWER
根據定理 23.1 可知，如果切割 \m{(S,V-S)} 將 \m{u} 和 \m{v} 分割開來，
由於 \m{(u,v)} 是橫跨此切割的最輕邊，所以 \m{(u,v)} 屬於最小生成樹。
\stopANSWER

%e23.1-2
\startEXERCISE
Sabatier 教授猜想出了定理 23.1 的一個逆定理如下：
設 \m{G=(V,E)} 是一個連通無向圖，
並有定義在邊集合 \m{E} 上的實數值權重函數 \m{\omega}。
設集合 \m{A} 爲 \m{E} 的一個子集，
該子集包含在圖 \m{G} 的某個最小生成樹中。
又設 \m{(S,V-S)} 爲 \m{G} 中任意尊重集合 \m{A} 的一個切割，
邊 \m{(u,v)} 是一條橫跨切割 \m{(S,V-S)} 且對於集合 \m{A} 安全的邊。
那麼邊 \m{(u,v)} 是該切割的一條輕量級邊。
請通過舉出反例來證明 Sabatier 教授的猜想是不正確的。
\stopEXERCISE

\startANSWER
令 \m{S=\{a,b,c\}}， \m{A=\{(a,b),(b,c)\}}，
可以看到 \m{(a,d),(b,e),(c,f)} 均橫跨切割 \m{(S,V-S)}，且對 \m{A} 都是安全的，
但只有 \m{(b,e)} 是此切割的輕量級邊。

\externalfigure[output/e23_1_2-1]
\stopANSWER

%e23.1-3
\startEXERCISE[exercise:23.1-3]
證明：如果圖 \m{G} 的一條邊 \m{(u,v)} 包含在圖 \m{G} 的某棵最小生成樹中，
則該條邊是橫跨圖 \m{G} 的某個切割的一條輕量級邊。
\stopEXERCISE

\startANSWER
將最小生成樹分成兩部分，一部分包含頂點 \m{u}，一部分包含頂點 \m{v}。
則兩部分包含了原圖的所有頂點， \m{(u,v)} 橫跨此切割。
任何橫跨此切割的邊都可以將兩部分連接起來形成一個生成樹。
假設有另一個邊 \m{(x,y)} 橫跨此切割，且 \m{\omega(x,y)<\omega(u,v)}，
則由 \m{(x,y)} 連接而成的生成樹的權重要小於用 \m{(u,v)} 連接而成的生成樹。
這與最小生成樹的假設矛盾，因此不存在這樣的 \m{(x,y)}，即 \m{(u,v)} 是此切割的一條輕量級邊。
\stopANSWER

%e23.1-4
\startEXERCISE
給出一個連通圖的例子，
使得如下邊集合所形成的不是最小生成樹：
\startformula
\left{(u,v): \text{存在一個切割 \m{(S,V-S)}，使得 \m{(u,v)} 是橫跨該切割的一條輕量級邊}\right}
\stopformula
\stopEXERCISE

\startANSWER
一個切割可能有多個輕量級邊，這樣會造成重複，從而形成環路，當然就不是最小生成樹。
\stopANSWER

%e23.1-5
\startEXERCISE
設 \m{e} 爲連通圖 \m{G=(V,E)} 的某條環路上權重最大的邊。
證明：圖 \m{G'=(V,E-\{e\})} 中存在一棵最小生成樹，
他也同時是 \m{G} 的最小生成樹。
也就是說，圖 \m{G} 中存在一棵不包含邊 \m{e} 的最小生成樹。
\stopEXERCISE

\startANSWER
\TODO{略。}
\stopANSWER

%e23.1-6
\startEXERCISE
證明：如果對於圖的每個切割，
都存在一條橫跨該切割的唯一的輕量級邊，
則該圖存在一棵唯一的最小生成樹。
並通過舉出反例來證明其逆論斷不成立。
\stopEXERCISE

\startANSWER
假設存在兩個最小生成樹 \m{T} 和 \m{T'}，
如果從 \m{T} 中移除 \m{e}，
則 \m{T} 變得不連通，形成切割 \m{(S,V-S)}，
根據\refexercise{23.1-3} 可知， \m{e} 是橫跨切割 \m{(S,V-S)} 的最輕邊。
假設邊 \m{x} 屬於 \m{T'}，並橫跨切割 \m{(S,V-S)}，則 \m{x} 同樣是最輕邊。
由於橫跨切割 \m{(S,V-S)} 的最輕邊唯一，所以 \m{e} 和 \m{x} 是同一條邊，
所以 \m{e} 也屬於 \m{T'}，
由於我們選擇 \m{e} 是任意的，所有在 \m{T} 中的邊，均在 \m{T'} 中，
即最小生成樹唯一。

但是反過來不成立，如下：

\externalfigure[output/e23_1_6-1]
\stopANSWER

%e23.1-7
\startEXERCISE
證明：如果一個圖的所有邊的權重都是正值，
則任意一個連接所有節點且總權重最小的一個邊集合必然形成一棵樹。
另外，請舉出例子來證明：
如果允許某些邊的權重爲負值，則該論斷不成立。
\stopEXERCISE

\startANSWER
如果不是一棵樹，由於連接所有節點，那麼必定存在環路，
這樣去掉一個邊，仍然可以連接所有節點，但總權重會變小（權重都是正值），
與總權重最小矛盾。

如果權重可以爲負，則不一定可以形成一棵樹，下圖三條邊總權重最小：

\externalfigure[output/e23_1_7-1]
\stopANSWER

%e23.1-8
\startEXERCISE
設 \m{T} 爲圖 \m{G} 的一棵最小生成樹，
設 \m{L} 爲樹 \m{T} 中一個邊權重的有序列表。
證明：對於圖 \m{G} 的任何其他最小生成樹 \m{T'}，
列表 \m{L} 也是 \m{T'} 中一個邊權重的有序列表。
\stopEXERCISE

\startANSWER
假設最小生成樹有 \m{n} 條邊，存在兩個最小生成樹 \m{T} 和 \m{T'}，
用 \m{\omega(e)} 表示邊的權值。

\m{T} 的權值遞增序列爲 \m{\omega(a_1)\le \omega(a_2)\le \ldots \le \omega(a_n)}。

\m{T'} 的權值遞增序列爲 \m{\omega(b_1)\le \omega(b_2)\le \ldots \le \omega(b_n)}。

假設 \m{i} 是兩個列表中，第一次出現邊不同的位置，即 \m{a_i \ne b_i}，先假定 \m{\omega(a_i)\ge \omega(b_i)}。

情況 1：如果 \m{T} 中包含邊 \m{b_i}，由於兩個列表在 \m{i} 之前均相同，若含有 \m{b_i}，
則位置一定在 \m{i} 之後，即有 \m{j>i}，使得 \m{\omega(a_j)=\omega(b_i)}，
從而有 \m{\omega(b_i)=\omega(a_j)\ge\omega(a_i)\ge\omega(b_i)}，
即 \m{\omega(b_i)=\omega(a_j)=\omega(a_i)}，
故 \m{\omega(a_i)=\omega(b_i)}。

情況 2：如果 \m{T} 不包含邊 \m{b_i}，則把 \m{b_i} 加到 \m{T} 中，
會在某處形成一個環路。
由於 \m{T} 是最小生成樹，環路內任何一條邊的權值都小於等於 \m{\omega(b_i)}。
另外這個環路內必定存在 \m{a_j}，不再 \m{T'} 中（否則 \m{T'} 中會形成環路）。
從而有 \m{\omega(a_j)\le \omega(b_i)}，且 \m{j>i}。
因此 \m{\omega(b_i)\le\omega(a_i)\le\omega(a_j)\le\omega(b_i)}，
即 \m{\omega(b_i)=\omega(a_j)=\omega(a_i)}。
\stopANSWER

%e23.1-9
\startEXERCISE
設 \m{T} 爲 \m{G=(V,E)} 的一棵最小生成樹，
設 \m{V'} 爲 \m{V} 的一個子集。
設 \m{T'} 爲由 \m{V'} 所誘導的 \m{T} 的子圖，
設 \m{G'} 爲由 \m{V'} 所誘導的 \m{G} 的子圖。
證明：如果 \m{T'} 是連通的，
則 \m{T'} 是 \m{G'} 的一棵最小生成樹。
\stopEXERCISE

\startANSWER
用切割 \m{(V',V-V')} 分割圖 \m{G}，
該切割一定不影響 \m{T'}，且 \m{T'} 是 \m{T} 的子集，
所以 \m{T'} 對於 \m{G'} 是安全的。
如果 \m{T'} 是連通的，則 \m{T'} 一定是 \m{G'} 的最小生成樹。
\stopANSWER

%e23.1-10
\startEXERCISE
給定圖 \m{G} 和 \m{G} 的一棵最小生成樹 \m{T}，
假設減小了 \m{T} 中一條邊的權重。
證明： \m{T} 仍然是 \m{G} 的一棵最小生成樹。
更形式化的，設 \m{T} 爲 \m{G} 的一棵最小生成樹， \m{G} 的邊權重由權重函數 \m{\omega} 給出。
選擇一條邊 \m{(x,y)\in T} 和一個正數 \m{k}，
並定義下述的權重函數 \m{\omega'}：
\startformula
\omega'(u,v)=\startcases
\NC \omega(u,v) \MC \text{若 \m{(u,v)\ne(x,y)}；} \NR
\NC \omega(x,y)-k \MC \text{若 \m{(u,v)=(x,y)}；} \NR
\stopcases
\stopformula

證明： \m{T} 仍然是 \m{G} 的一棵最小生成樹，
這裏 \m{G} 的邊權重由函數 \m{\omega'} 給出。
\stopEXERCISE

\startANSWER
由於 \m{\omega(T)-k=\omega'(T)} 且 \m{k} 是正數，
假設 \m{X} 是任意其他生成樹，有 \m{\omega(T)\le \omega(X)}。
如果 \m{X} 含有 \m{(x,y)}，則 \m{\omega'(T)\le\omega'(X)}；
如果 \m{X} 不包含 \m{(x,y)}，則 \m{\omega'(T)\le\omega'(X)-k}。
兩種情況下， \m{\omega'(T)} 均最小。
另外，減少權值後 \m{T} 的其他屬性無變化，仍然連通所有點，且無還，
所以用 \m{\omega'} 計算權值， \m{T} 仍然是最小生成樹。
\stopANSWER

%e23.1-11
\startEXERCISE\DIFFICULT
給定圖 \m{G} 和一棵最小生成樹 \m{T}，
假設減小了位於 \m{T} 之外的某條邊的權重。
請給出一個在修改後的圖中尋找最小生成樹的算法。
\stopEXERCISE

\startANSWER
在原有最小生成樹中按 \ALGO{DFS} 搜索 \m{u} 到 \m{v} 的路徑，
然後找到此路徑中權值最大的邊，如果其權值大於修改後的 \m{(u,v)} 的權值，
則用 \m{(u,v)} 取代此邊，形成新的最小生成樹，否則，最小生成樹不變。
\stopANSWER

\stopsection

\startsection[
  title={The algorithms of Kruskal and Prim},
]

%e23.2-1
\startEXERCISE
對於同一個輸入圖， Kruskal 算法返回的最小生成樹可以不同。
這種不同來源於對邊進行排序時，對權重相同的邊進行的不同處理。
證明：對於圖 \m{G} 的每棵最小生成樹 \m{T}，
都存在一種辦法來對 \m{G} 的邊進行排序，
使得 Kruskal 算法所返回的最小生成樹就是 \m{T}。
\stopEXERCISE

\startANSWER
排序時，對於同樣權重的邊，讓出現在 \m{T} 中的排在前面。
\stopANSWER

%e23.2-2
\startEXERCISE
假定我們用鄰接矩陣來表示圖 \m{G=(V,E)}。
請給出 Prim 算法的一種簡單實現，
使其運行時間爲 \m{O(V^2)}。
\stopEXERCISE

\startANSWER
\CLRSH{MST-PRIME2(G, r)}
\startCLRS
for each u in V[G]
	key[u] = infinite
	pi[u] = NIL
key[r] = 0
Q = V[G]
while Q is not empty
	u = EXTRACT-MIN(Q)
	for each v in V[G]
		if A[u,v] != 0 and v in Q and A[u,v] < key[v]
			pi[v] = u
			key[v] = A[u,v]
\stopCLRS

兩層循環次數均爲 \m{|V|}，因此算法的時間複雜度爲 \m{O(V^2)}。
\stopANSWER

%e23.2-3
\startEXERCISE
對於稀疏圖 \m{G=(V,E)}，這裏 \m{|E|=\Theta(V)}，
使用 Fibonacci 堆實現的 Prim 算法是否比使用二叉堆實現的算法更快？
對於稠密圖又如何呢？
 \m{|E|} 和 \m{|V|} 必須具備何種關係才能使 Fibonacci 堆的實現在漸進級別上比二叉堆的實現更快？
\stopEXERCISE

\startANSWER
令 \ALGO{EXTRACT-MIN} 時間爲 \m{T_1}， \ALGO{DECREASE-KEY} 時間爲 \m{T_2}。
時間複雜度爲 \m{\Theta(VT_1 + ET_2)}。
 Fibonacci 堆 \m{T_1=\lg V}， \m{T_2=1}；
二叉堆 \m{T_1=\lg V}， \m{T_2=\lg V}。

若 \m{E=\Theta(V)}，則兩種複雜度均爲 \m{\Theta(V\lg V)}。
若 \m{E=\Theta(V^2)}， Fibonacci 堆爲 \m{\Theta(V^2)}，二叉堆爲 \m{\Theta(V^2\lg V)}。

當 \m{E=\omega(V)} 時， Fibonacci 堆漸進更快。
\stopANSWER

%e23.2-4
\startEXERCISE
假定圖中的邊權重全部爲整數，且在範圍 \m{1}～\m{|V|} 內。
 Kruskal 算法最快能多快？
如果邊的權重取值範圍在 1 到某個常數 \m{W} 之間呢？
\stopEXERCISE

\startANSWER
無論在什麼範圍內，排序用的時間都是 \m{O(E)}。
總時間爲 \m{O(E)+O((E+V)\alpha(V))=O(E\alpha(V))}。
\stopANSWER

%e23.2-5
\startEXERCISE
假定圖中的邊權重全部爲整數，且在範圍 \m{1}～\m{|V|} 內。
 Prim 算法最快能多快？
如果邊的權重取值範圍在 1 到某個常數 \m{W} 之間呢？
\stopEXERCISE

\startANSWER
用數組加雙向鏈表的形式實現， \m{T_1=1}， \m{T_2=1}，總時間複雜度爲 \m{\Theta(E)}。
\stopANSWER

%e23.2-6
\startEXERCISE\DIFFICULT
假定一個圖中所有的邊權重均勻分佈在半開區間 \m{[0,1)} 內。
 Prim 算法和 Kruskal 算法哪一個可以運行得更快？
\stopEXERCISE

\startANSWER
Kruskal 算法可以運行得更快，可以使用桶排序，期望運行時間爲 \m{O(E)}。
總時間爲 \m{O(E)+O((E+V)\alpha(V))=O(E\alpha(V))}。
\stopANSWER

%e23.2-7
\startEXERCISE\DIFFICULT
假定圖 \m{G} 的一棵最小生成樹已經被計算出來。
如果在圖中加入一個新節點及其相關的新邊，
我們需要多少時間來對最小生成樹進行更新？
\stopEXERCISE

\startANSWER
如果只新增一條邊，則將這條邊加入原最小生成樹即可。
如果新增了 \m{k(k>1)} 條邊，那麼要刪除 \m{k-1} 條邊。

假設新節點是 \m{v}，那麼必然存在包含 \m{v} 的環路。
遍歷 \m{k-1} 次，每次都能找到一個環路，從該環路中刪除一條權值最大的邊。
\stopANSWER

%e23.2-8
\startEXERCISE
Borden 教授提出了一個新的分治算法來計算最小生成樹。
該算法的原理如下：
給定圖 \m{G=(V,E)}，將 \m{V} 劃分成兩個集合 \m{V_1} 和 \m{V_2}，
使得 \m{|V_1|} 和 \m{|V_2|} 的差最多爲 1。
設 \m{E_1} 爲端點全部在 \m{V_1} 中的邊的集合，
 \m{E_2} 爲端點全部在 \m{V_2} 中的邊的集合。
我們遞歸地解決兩個子圖 \m{G_1=(V_1,E_1)} 和 \m{G_2=(V_2,E_2)} 的最小生成樹問題。
最後，在邊集合 \m{E} 中選擇橫跨切割 \m{V_1} 和 \m{V_2} 的最小權重的邊來
將求出的兩棵最小生成樹連接起來，
從而形成一棵最後的最小生成樹。
請證明該算法能正確計算除一棵最小生成樹，
或者舉出反例來說明該算法不正確。
\stopEXERCISE

\startANSWER
不正確，無法保證第一條邊屬於某個最小生成樹。如下圖：

\externalfigure[output/e23_2_8-1]
\stopANSWER

\stopsection

\startsubject[
  title={Problems},
]

%p23-1
\startPROBLEM
（Second-best minimum spanning tree）
設 \m{G=(V,E)} 爲一連通無向圖，
其權重函數爲 \m{\omega:E\rightarrow R}，
假定 \m{|E|\ge |V|} 並且所有的權重都互不相同。
我們定義一棵次優最小生成樹如下：
設 \m{\tau} 爲 \m{G} 的所有生成樹的集合，
 \m{T'} 爲 \m{G} 的一棵最小生成樹。
那麼{\EMP 次優最小生成樹}是生成樹 \m{T}，
其滿足 \m{\omega(T)=\min_{T''\in \tau-\{T'\}}\{\omega(T'')\}}。
\startigBase[a]\startitem
證明：最小生成樹唯一，並不能保證次優最小生成樹唯一。
\stopitem\stopigBase

\startANSWER
\startcolumns[n=3]
\startalignment[middle]
\externalfigure[output/p23_1-1]

最小生成樹
\stopalignment
\column
\startalignment[middle]
\externalfigure[output/p23_1-2]

次優生成樹 1
\stopalignment
\column
\startalignment[middle]
\externalfigure[output/p23_1-3]

次優生成樹 2
\stopalignment
\stopcolumns
\stopANSWER

\startigBase[continue]\startitem
設 \m{T} 爲 \m{G} 的一棵最小生成樹。證明：
圖 \m{G} 中可以找到兩條邊 \m{(u,v)\in T} 和 \m{(x,y)\notin T}，
使得 \m{T-\{(u,v)\}\cup\{(x,y)\}} 是 \m{G} 的一棵次優最小生成樹。
\stopitem\stopigBase

\startANSWER
由於任一生成樹均包含 \m{|V|-1} 條邊，
因此次優 MST 至少含有一條邊不在 MST 中。

如果次優 MST 中只有一條邊不在 MST 中，如 \m{(x,y)}，
則次優 MST 與 MST 中邊的差異，只有 \m{(x,y)} 和另一條邊 \m{(u,v)}。
即次優 MST 中用 \m{(x,y)} 代替了 MST 中的 \m{(u,v)}，其他邊都一樣。
這種情況下， \m{T-\{(u,v)\}\cup\{(x,y)\}} 是 \m{G} 的一棵次優 MST。

因此我們要證明替換 MST 中的兩條或多條邊，無法得到次優 MST。

令 \m{T} 爲 \m{G} 的 MST，
假設存在次優 MST \m{T'}， \m{T-T'} 中至少有兩條邊，
令 \m{T-T'} 中權重最小的邊爲 \m{(u,v)}。
如果將 \m{(u,v)} 加入 \m{T'}，會形成環路 \m{c}。
這個環路包含 \m{T'-T} 中的某條邊 \m{(x,y)} （否則， \m{T} 會形成環路）。

我們要證明 \m{\omega(x,y)>\omega(u,v)}。
用反證法，先假設 \m{\omega(x,y)<\omega(u,v)}。
假設所有邊的權重都不同，因此不用考慮 \m{\omega(x,y)=\omega(u,v)} 的情況。
如果將 \m{(x,y)} 加入 \m{T}，會形成環路 \m{c'}，
此環路中必定包含 \m{T-T'} 中的某條邊 \m{(u',v')} （否則， \m{T'} 會形成環路）。
因此， \m{T''=T-\{(u',v')\}\cup\{(x,y)\}} 會形成生成樹，
同時必須滿足 \m{\omega(u',v')<\omega(x,y)}，
否則 \m{T''} 的權重會小於 \m{T} 的權重， \m{T} 就不是 MST 了。
因此 \m{\omega(u',v')<\omega(x,y)<\omega(u,v)}，
但這與假設不符： \m{(u,v)} 是 \m{T-T'} 中權重最小的邊。

由於 \m{(u,v)} 和 \m{(x,y)} 在同一個環路 \m{c} 上，
如果我們將 \m{(u,v)} 加入 \m{T'}，
 \m{T'-\{(x,y)\}\cup\{(u,v)\}} 是一棵生成樹，且其權重小於 \m{\omega(T')}。
進一步， \m{T'} 與 \m{T} 不同（僅差一條邊）。
因此，我們找到了一棵生成樹，且其權重小於 \m{\omega(T')}，但這棵樹不是 \m{T}。
因此， \m{T'} 不是次優 MST。
\stopANSWER

\startigBase[continue]\startitem
設 \m{T} 爲 \m{G} 的一棵 MST，
對於任意兩個節點 \m{u,v\in V}，
設 \m{\max[u,v]} 表示樹 \m{T} 中從節點 \m{u} 到節點 \m{v} 的簡單路徑上權重最大的邊，
請給出一個 \m{O(V^2)} 時間複雜度的算法來計算 \m{\max[u,v]}。
\stopitem\stopigBase

\startANSWER
我們可以在 \m{O(V^2)} 時間內找到所有 \m{u,v\in V} 的 \m{\max[u,v]}。
用何種方法並不重要，廣度優先、深度優先，或者其他方式都行。

下面給出廣度優先和深度優先的僞碼。
但僞碼與第 22 章的僞碼有點區別，我們不需要計算 \m{d} 和 \m{f} 的值，
我們使用表 \m{\max} 本身來記錄是否訪問過一個節點。
當且僅當 \m{u=v} 或者還沒有訪問過節點 \m{v} 時，纔有 \m{\max[u,v]=NIL}。
注意，由於我們是訪問無向圖生成樹的邊，因此可以保證從 \m{u} 開始可以訪問到所有節點。
在節 22.3 中的 \ALGO{DFS} 中的“restart”就沒有必要了。
僞碼中假設每個節點的鄰接鏈表僅包含生成樹 \m{T} 中的邊。

\CLRSH{BFS-FILL-MAX(G, T, w)}
\startCLRS
let max be a new table with an entry max[u,v] for each u, v in G.V
for each vertex u in G.V
	for each vertex v in G.V
		max[u,v] = NIL
	Q = empty
	ENQUEUE(Q,u)
	while Q not empty
		x = DEQUEUE(Q)
		for each v in G.Adj[x]
			if max[u,v] == NIL and v != u
				if x == u or w(x,v) > max[u,x]
					max[u,v] = (x,v)
				else
					max[u,v] = max[u,x]
				ENQUEUE(Q,v)
return max
\stopCLRS

\CLRSH{DFS-FILL-MAX(G, T, w)}
\startCLRS
let max be a new table with an entry max[u,v] for each u, v in G.V
for each vertex u in G.V
	for each vertex v in G.V
		max[u,v] = NIL
	DFS-FILL-MAX-VISIT(G, u, u, max)
return max
\stopCLRS

\CLRSH{DFS-FILL-MAX-VISIT(G, u, x, max)}
\startCLRS
for each vertex v in G.Adj[x]
	if max[u,v] == NIL and v != u
		if x == u or w(x,v) > max[u,x]
			max[u,v] = w(x,v)
		else
			max[u,v] = max[u,x]
		DFS-FILL-MAX-VISIT(G, u, v, max)
\stopCLRS
\stopANSWER

\startigBase[continue]\startitem
給出一個有效算法來計算圖 \m{G} 的次優最小生成樹。
\stopitem\stopigBase

\startANSWER
在 b）中，我們已證明，只要替換最小生成樹中的一個邊就可以得到一棵次優 MST。
假如用邊 \m{(u,v)\notin T} 替換 \m{(x,y)\in T} 得到次優 MST \m{T'}，
則 \m{\omega(T')=\omega(T)-\omega(x,y)+\omega(u,v)}。
如果確定了 \m{(u,v)}，則要使 \m{\omega(T')} 最小，需要在 \m{T} 中找到
從 \m{u} 到 \m{v} 的唯一路徑上權值最大的邊。
如果我們已經計算除了 \m{T} 上的 \m{\max} 表（見 c）），
那麼我們就可以根據 \m{\max[u,v]} 直接找到這條邊了。
剩下唯一要做的就是找到邊 \m{(u,v)\notin T}，使得 \m{\omega(\max[u,v])-\omega(u,v)} 最小。
因此，尋找次優 MST 的算法如下：

\startigNum[n]
\item 計算最小生成樹 \m{T}，時間 \m{O(E+V\lg V)}，
使用 Prim 算法（用 Fibonacci 堆實現優先隊列）。
由於 \m{|E|<|V|^2}，因此運行時間爲 \m{O(V^2)}。

\item 用 MST 計算表 \m{\max}，參見 c）。時間爲 \m{O(V^2)}。

\item 找到邊 \m{(u,v)\notin T}，使得 \m{\omega(\max[u,v])-\omega(u,v)} 最小。
時間 \m{O(E)}，即 \m{O(V^2)}。

\item 根據上一步結果， \m{T'=T-\{\max[u,v]\}\cup\{(u,v)\}} 即爲所求次優 MST。
\stopigNum

總時間爲 \m{O(V^2)}。
\stopANSWER

\stopPROBLEM

\stopsubject%Problems

\stopchapter
\stopcomponent

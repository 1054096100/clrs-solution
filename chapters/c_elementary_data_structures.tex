\startcomponent c_elementary_data_structures

\startchapter[
  title={Elementary Data Structures},
]

\startsection[
  reference=section:stack_and_queue,
  title={Stacks and queues},
]

%e10.1-1
\startEXERCISE
仿照圖 10-1，畫圖表示依次執行操作 \ALGO{PUSH(S, 4)}、 \ALGO{PUSH(S, 1)}、 \ALGO{PUSH(S, 3)}、
 \ALGO{POP(S)}、  \ALGO{PUSH(S, 8)} 和 \ALGO{POP(S)} 每一步的結果，
棧 \m{S} 初始爲空，存儲於數列 \m{S[1..6]} 中。
\stopEXERCISE

\startANSWER
\externalfigure[output/e10_1_1-1]
\externalfigure[output/e10_1_1-2]
\externalfigure[output/e10_1_1-3]
\externalfigure[output/e10_1_1-4]
\externalfigure[output/e10_1_1-5]
\externalfigure[output/e10_1_1-6]
\externalfigure[output/e10_1_1-7]
\stopANSWER

%e10.1-2
\startEXERCISE
請說明如何讓兩個棧共用一個數列 \m{A[1..n]}，
僅當兩個棧的所有元素數目爲 \m{n} 時才會發生上溢。
 \ALGO{PUSH} 和 \ALGO{POP} 操作要在 \m{O(1)} 時間內完成。
\stopEXERCISE

\startANSWER
其中一個棧從 \m{A[1]} 向 \m{A[n]} 方向增長，
另一個從 \m{A[n]} 向 \m{A[1]} 方向增長。
當兩個棧的棧頂相鄰時才會發生上溢。
\stopANSWER

\startEXERCISE
仿照圖 10-2，畫圖表示在初始爲空的隊列 \m{Q} 上依次執行 \ALGO{ENQUEUE(Q, 4)}、
 \ALGO{ENQUEUE(Q, 1)}、 \ALGO{ENQUEUE(Q, 3)}、 \ALGO{DEQUEUE(Q)}、
 \ALGO{ENQUEUE(Q, 8)} 和 \ALGO{DEQUEUE(Q)} 每步的結果，隊列存儲在數列 \m{Q[1..6]} 中。
\stopEXERCISE

\startANSWER
\externalfigure[output/e10_1_3-1]
\externalfigure[output/e10_1_3-2]
\externalfigure[output/e10_1_3-3]
\externalfigure[output/e10_1_3-4]
\externalfigure[output/e10_1_3-5]
\externalfigure[output/e10_1_3-6]
\externalfigure[output/e10_1_3-7]
\stopANSWER

%e10.1-4
\startEXERCISE
重寫 \ALGO{ENQUEUE} 和 \ALGO{DEQUEUE} 以處理上溢和下溢的情況。
\stopEXERCISE

\startANSWER
輔助過程：

\CLRSH{NEXT(Q, i)}
\startCLRS
if i == Q.length
	return 1
else
	return i + 1
\stopCLRS

\CLRSH{EMPTY(Q)}
\startCLRS
if Q.head == Q.tail
	return true
else
	return false
\stopCLRS

\CLRSH{FULL(Q)}
\startCLRS
if NEXT(Q, Q.tail) == Q.head
	return true
else
	return false
\stopCLRS

實現：

\CLRSH{ENQUEUE(Q, x)}
\startCLRS
if FULL(Q)
	error "Queue overflow"
Q[Q.tail] = x
Q.tail = NEXT(Q, Q.tail)
\stopCLRS

\CLRSH{DEQUEUE(Q)}
\startCLRS
if EMPTY(Q)
	error "Queue underflow"
x = Q[Q.head]
Q.head = NEXT(Q, Q.head)
return x
\stopCLRS
\stopANSWER

%e10.1-5
\startEXERCISE
棧只能在同一端插入、刪除元素，隊列則可在一端插入、另一端刪除，
而{\EMP 雙端隊列（deque）}兩端均可插入、刪除元素。
以數列實現雙端隊列，寫出四個過程在雙端隊列的兩端插入、刪除元素，時間均爲 \m{O(1)}。
\stopEXERCISE

\startANSWER
輔助過程：

\CLRSH{PREV(Q, i)}
\startCLRS
if i == 1
	return Q.length
else
	return i - 1
\stopCLRS

實現：

\CLRSH{ENQUEUE_TAIL(Q, x)}
\startCLRS
if FULL(Q)
	error "Queue overflow"
Q[Q.tail] = x
Q.tail = NEXT(Q, Q.tail)
\stopCLRS

\CLRSH{ENQUEUE_HEAD(Q, x)}
\startCLRS
if FULL(Q)
	error "Queue overflow"
Q[Q.head] = x
Q.head = PREV(Q, Q.head)
\stopCLRS

\CLRSH{DEQUEUE_HEAD(Q)}
\startCLRS
if EMPTY(Q)
	error "Queue underflow"
x = Q[Q.head]
Q.head = NEXT(Q, Q.head)
return x
\stopCLRS

\CLRSH{DEQUEUE_TAIL(Q)}
\startCLRS
if EMPTY(Q)
	error "Queue underflow"
x = Q[Q.tail]
Q.tail = PREV(Q, Q.tail)
return x
\stopCLRS
\stopANSWER

%e10.1-6
\startEXERCISE[exercise:two_stack_to_queue]
如何用兩個棧實現隊列？分析隊列操作的運行時間？
\stopEXERCISE

\startANSWER
令兩個棧爲 \m{A} 和 \m{B}， \m{B} 用來入隊， \m{A} 用來出隊。
當 \m{A} 爲空時，將 \m{B} 中所有元素轉移到 \m{A} 中。
入隊時間爲 \m{O(1)}；當 \m{A} 不空時，出隊時間爲 \m{O(1)}，
否則爲 \m{\Theta(n)}，其中 \m{n} 爲 \m{B} 中元素的數目。
\stopANSWER

%e10.1-7
\startEXERCISE
如何用兩個隊列實現棧？分析棧操作的運行時間。
\stopEXERCISE

\startANSWER
兩個隊列，角色不同，一爲 ACTIVE，一爲 INVACTIVE， \ALGO{PUSH} 到 ACTIVE 隊列中，
時間爲 \m{\Theta(1)}。
而 \ALGO{POP} 則需將 ACTIVE 隊列中元素 \ALGO{DEQUEUE} 並 \m{QUEUE} 到 INACTIVE 隊列中，
 ACTIVE 隊列中只留一個元素，最後這個元素 \ALGO{DEQUEUE} 後返回；然後交換兩個隊列的角色。
 \ALGO{POP} 時間爲 \m{\Theta(n)}，其中 \m{n} 爲 隊列中元素數目。
\stopANSWER

\stopsection

\startsection[
  title={Linked lists},
]

%e10.2-1
\startEXERCISE
如何在單向鏈表上實現動態集合操作 \ALGO{INSERT}？要求時間爲 \m{O(1)}。 \ALGO{DELETE} 呢？
\stopEXERCISE

\startANSWER
在單項鏈表頭部進行插入操作。
而刪除操作則無法在常數時間內完成，除非傳遞的參數是要刪除節點的前驅，或者可以修改節點的 \m{key} 和衛星數據。
\stopANSWER

%e10.2-2
\startEXERCISE
用單向鏈表 \m{L} 實現棧。要求 \ALGO{PUSH} 和 \ALGO{POP} 的時間仍爲 \m{O(1)}。
\stopEXERCISE

\startANSWER
插入和刪除全部在頭部進行即可。
\stopANSWER

%e10.2-3
\startEXERCISE
用單向鏈表 \m{L} 實現隊列。要求 \ALGO{ENQUEUE} 和 \ALGO{DEQUEUE} 的時間仍爲 \m{O(1)}。
\stopEXERCISE

\startANSWER
入隊在頭部進行，出隊在尾部進行，只是需要哨兵跟蹤鏈表中最後一個元素。
\stopANSWER

%e10.2-4
\startEXERCISE
過程 \ALGO{LIST-SEARCH'} 中的每次循環中都要做兩個測試：
一個是 \m{x \ne L.nil}，另一個是 \m{x.key \ne k}。
如何消除對前者的測試？
\stopEXERCISE

\startANSWER
\CLRSH{LIST-SEARCH'(L, k)}
\startCLRS
x = L.nil.next
L.nil.key = k
while x.key ≠ k
	x = x.next
return x
\stopCLRS
\stopANSWER

%e10.2-5
\startEXERCISE
用單向循環鏈表實現字典操作 \ALGO{INSERT}、 \ALGO{DELETE} 和 \ALGO{SEARCH}。
運行時間如何？
\stopEXERCISE

\startANSWER
字典操作參數均爲 \m{key}。
利用哨兵，插入操作時間爲 \m{O(1)}；刪除和查找操作時間均爲 \m{O(n)}；
\stopANSWER

%e10.2-6
\startEXERCISE
動態集合操作 \m{UNION} 以兩個不相交的集合 \m{S_1} 和 \m{S_2} 作爲輸入，
返回的集合 \m{S=S_1\cup S_2} 含有 \m{S_1} 和 \m{S_2} 中的所有元素。
通常這個操作會銷毀 \m{S_1} 和 \m{S_2}。
如何用鏈表數據結構來實現 \ALGO{UNION}？要求時間爲 \m{O(1)}。
\stopEXERCISE

\startANSWER
用雙向鏈表，只需將 \m{S_2} 的第一個元素作爲 \m{S_1} 的最後一個元素的後繼節點即可。
如果用了哨兵，則需要銷毀 \m{S_2}。
\stopANSWER

%e10.2-7
\startEXERCISE
如何以 \m{\Theta(n)} 時間將含有 \m{n} 個元素的單向鏈表反序，要求不能使用遞迴。
要求除鏈表本身外，只能使用固定大小的存儲空間。
\stopEXERCISE

\startANSWER
\CLRSH{REVERSE(list)}
\startCLRS
prev = list.NIL
cur = list.NIL.next

while cur != list.NIL
	next = cur.next
	cur.next = prev
	prev = cur
	cur = next
\stopCLRS
\stopANSWER

%e10.2-8
\startEXERCISE\DIFFICULT
實現雙向鏈表，要求每個元素只用一個指針 \m{x.np}，而不是兩個（\m{next} 和 \m{prev}）。
假設所有指針都可視爲 \m{k} 位整數，
同時令 \m{x.np = x.next XOR x.prev}，即 \m{x.prev} 和 \m{x.next} 的 \m{k} 位“異或”。
（NIL 的值爲 0。）
要訪問鏈表頭需要哪些信息？
如何實現 \ALGO{SEARCH}、 \ALGO{INSERT} 和 \ALGO{DELETE}？
如何在 \m{O(1)} 時間內反序？
\stopEXERCISE

\startANSWER
如果是通過前驅節點訪問的當前節點，則已經直到了 \m{prev} 的值，這時通過 \m{prev XOR np} 即可得 \m{next} 的值。

如果是通過後繼節點訪問的當前節點，則已經直到了 \m{next} 的值，這時通過 \m{next XOR np} 即可得 \m{prev} 的值。

\ALGO{SEARCH}、 \ALGO{INSERT} 和 \ALGO{DELETE} 的實現與普通雙向鏈表沒什麼區別，
只是增加了計算 \m{prev}、 \m{next} 和 \m{np} 的步驟。

要訪問鏈表只需直到第一個元素或者最後一個元素的指針即可。

反序只需要調換以下 \m{head} 和 \m{tail} 的值即可。
\stopANSWER


\stopsection

\startsection[
  title={Implementing pointers and objects},
]
\stopsection

%e10.3-1
\startEXERCISE
畫出序列 \m{\langle 13,4,8,19,5,11 \rangle} 在多維數列表示的雙向鏈表中的存儲方式。
同時畫出在單數列表示的雙向鏈表中的存儲方式。
\stopEXERCISE

\startANSWER
\externalfigure[output/e10_3_1-1]

\externalfigure[output/e10_3_1-2]
\stopANSWER

%e10.3-2
\startEXERCISE
爲同構對象的單數列表示法寫出過程 \ALGO{ALLOCATE-OBJECT} 和 \ALGO{FREE-OBJECT}。
\stopEXERCISE

\startANSWER
\CLRSH{ALLOCATE-OBJECT}
\startCLRS
if free = NIL
	error "out of space"
else
	x = free
	free = A[free + 1]
	return x
\stopCLRS

\CLRSH{FREE-OBJECT}
\startCLRS
A[x+1] = free
free = x
\stopCLRS
\stopANSWER

%e10.3-3
\startEXERCISE
爲什麼在 \ALGO{ALLOCATE-OBJECT} 和 \ALGO{FREE-OBJECT} 的實現中，
我們不需要設置或重置對象的 \m{prev}？
\stopEXERCISE

\startANSWER
因爲我們不使用 \m{prev}。
對空閒鏈表而言，單鏈就足夠了。
甚至連 \m{key} 都不需要。
\stopANSWER

%e10.3-4
\startEXERCISE[exercise:compact_list]
我們往往希望雙向鏈表的所有元素在存儲器中保持緊湊，
例如，在多數列表示法中佔用前 \m{m} 個下標位置。
（在頁式虛擬內存的計算環境下就是這樣的。）
說明如何實現 \ALGO{ALLOCATE-OBJECT} 和 \ALGO{FREE-OBJECT} 才能達到這種效果。
假設在鏈表外部沒有指針指向鏈表內元素。
（\hint 用棧的數列實現方式）
\stopEXERCISE

\startANSWER
我們可以在數列的起始位置開始分配元素。
當釋放元素時，除非是棧的最後一個，我們都需要將其後面的所有元素左移，
並更新所有指向他們的的下標。
需要線性時間。
\stopANSWER

%e10.3-5
\startEXERCISE
令 \m{L} 爲雙向鏈表，長度爲 \m{n}，存儲在長度爲 \m{m} 的 \m{key}、 \m{prev} 和 \m{next} 三個數列中。
這些數列由 \ALGO{ALLOCATE-OBJECT} 和 \ALGO{FREE-OBJECT} 通過空閒雙向鏈表 \m{F} 進行管理，
假設 \m{L} 中有 \m{n} 個元素， \m{F} 中有 \m{m-n} 個元素。
寫出過程 \m{COMPACTIFY-LIST(L, F)}，
參數爲鏈表 \m{L} 和空閒鏈表 \m{F}，
移動 \m{L} 中的元素，使其佔用數列中前 \m{n} 個位置，
並調整空閒鏈表 \m{F}，使其佔用數列中後 \m{m-n} 個位置。
此過程的運行時間應爲 \m{\Theta(n)}，
且使用固定數量的額外存儲空間。
並證明其正確性。
\stopEXERCISE

\startEXERCISE
利用 \m{prev} 來存儲一個特定值來標記此元素屬於空閒鏈表。
\startigBase[n]
\item 從左至右掃描數列的前 \m{n} 個元素，找到第一個空閒元素；
\item 從頭至尾掃描 \m{L} 找到第一個不在數列中前 \m{n} 個位置中的元素；
\item 將這兩個元素互換；
\item 重複以上步驟，直至掃描完畢。
\stopigBase
\stopEXERCISE

\startsection[
  title={Representing rooted trees},
]

\startEXERCISE
畫出下列屬性表所示的二叉樹，其根節點下標為 6。

\input{tbl/tbl10.4-1.tex}
\stopEXERCISE

\startANSWER
如下圖，其中第 2 個和第 8 個元素沒有在樹上。

\externalfigure[output/e10_4_1-1]
\stopANSWER

%e10.4-2
\startEXERCISE
給定一個含有 n 個節點的二叉樹，寫出一個運行時間爲 \m{O(n)} 的遞迴過程，
將該樹所有節點的 key 打印出來。
\stopEXERCISE

\CLRSH{PRINT-BINARY-TREE(T)}
\startCLRS
if T
	PRINT T.key
	PRINT-BINARY-TREE(T.left)
	PRINT-BINARY-TREE(T.right)
\stopCLRS

%e10.4-3
\startEXERCISE
給定一個含有 n 個節點的二叉樹，寫出一個運行時間爲 \m{O(n)} 的非遞迴過程，
將該樹所有節點的 key 打印出來。
可以使用一個棧作爲輔助數據結構。
\stopEXERCISE

\CLRSH{PRINT-BINARY-TREE(T)}
\startCLRS
if T
	PUSH(S, T)
while S.length > 0
	T = POP(S)
	PRINT(T.key)
	if T.left
		PUSH(S, T.left)
	if T.right
		PUSH(S, T.right)
\stopCLRS

%e10.4-4
\startEXERCISE
對於一個含有 n 個節點的任意有根樹，
寫出一個 \m{O(n)} 時間的過程，輸出其所有關鍵字。
該樹以左孩子右兄弟表示法存儲。
\stopEXERCISE

\startANSWER
\CLRSH{PRINT-LCRS-TREE(T)}
\startCLRS
PRINT(T.key)
if T.child
	PRINT-LCRS-TREE(T.child)
if T.sibling
	PRINT-LCRS-TREE(T.sibling)
\stopCLRS
\stopANSWER

%e10.4-5
\startEXERCISE\DIFFICULT
給定一個含有 n 個節點的二叉樹，寫出一個運行時間爲 \m{O(n)} 的非遞迴過程，
將該樹所有節點的 key 打印出來。
要求除樹本身外，只能使用固定量的額外存儲空間，
且過程中不得修改樹，即使是暫時的修改也不允許。
\stopEXERCISE

\startANSWER
\CLRSH{PRINT-BINARY-TREE(T)}
\startCLRS
prev = NIL
curr = T
while curr
	if prev = curr.parent
		if curr.left
			prev = curr
			curr = curr.left
		else
			PRINT(curr.key)
			if curr.right
				prev = curr
				curr = curr.right
			else
				prev = curr
				curr = curr.parent
	if prev = curr.left
		PRINT(curr.key)
		if curr.right
			prev = curr
			curr = curr.right
		else
			prev = curr
			curr = curr.parent
	else if prev = curr.right
		prev = curr
		curr = curr.parent
	else
		error "logic error"
\stopCLRS
\stopANSWER

%e10.4-6
\startEXERCISE\DIFFICULT
任意有根樹的左孩子右兄弟表示法中每個節點用到三個指針： \m{left-child}、 \m{right-sibling} 和 \m{parent}。
對於任何節點，都可以在常數時間到達其父節點；
並在與其孩子數呈線性關系的時間內到達所有還節點。
說明如何在每個節點中只使用兩個指針和一個布爾值的情況下，
使其父節點或其所有孩子節點都可以在與其孩子數呈線性關系的時間內到達。
\stopEXERCISE

\startANSWER
只需要兩個指針 \m{left-child} 和 \m{next}，
其中 \m{next} 即 \m{right-sibling}，只有最後一個兄弟節點例外，
最後一個兄弟節點的 \m{right-sibling} 指向其父節點。
而布爾量則表示自己是不是最右一個兄弟節點。
\stopANSWER

\stopsection

\startsubject[
  title={Problems},
]

%p10-1
\startPROBLEM
（Comparisons among lists）
對於下表中的 4 種鏈表，所列的每種動態集合操作在最壞情況下的漸進運行時間是多少？
\stopPROBLEM

\startANSWER
\input{tbl/tbl10-1.tex}

對於已排序的單向鏈表，如果跟蹤鏈表爲節點，則 \ALGO{MAXIMUM} 的運行時間爲常數。
\stopANSWER

%p10-2
\startPROBLEM
（Mergeable heaps using linked lists）
{\EMP 可合並堆}（{\EMP mergeable heap}）支持以下操作： \ALGO{MAKE-HEAP}（創建一個空的可合並堆）、
 \ALGO{INSERT}、 \ALGO{MINIMUM}、 \ALGO{EXTRACT-MIN} 和 \ALGO{UNION}\footnote{%
由於我們定義的是 \ALGO{MINIMUM} 和 \ALGO{EXTRACT-MIN}，因此我們也可以將其稱爲{\EMP 可合並最小堆}；
如果我們定義的是 \ALGO{MAXIMUM} 和 \ALGO{EXTRACT-MAX}，則可以將其稱爲{\EMP 可合並最大堆}。
}。
試說明下列各種情況下如何用鏈表實現可合並堆。
試者使各種操作盡可能高效。
根據動態集合的規模分析每種操作的運行時間。
\startigBase[a]
\item 鏈表已排序；
\item 鏈表未排序；
\item 鏈表未排序，且待合並的動態集合是不相交的。
\stopigBase
\stopPROBLEM

\startANSWER
\input{tbl/tbl10-2.tex}

其中，如果可以跟蹤鏈表的尾節點，對於未排序的鏈表的 \ALGO{UNION} 操作可以是常數時間。
\stopANSWER

%p10-3
\startPROBLEM
（Searching a sorted compact list）
\refexercise{compact_list} 提出了如何使鏈表保持緊湊的問題。
我們假設所有 key 各不相同，且緊湊鏈表已排序，即，
 \m{key[i] < key[next[i]]}，其中 \m{i=1,2,\ldots,n}，且 \m{next[i] \ne NIL}。
同時假設有一個變量 \m{L} 保存鏈表種第一個元素的下標值。
在這些假設下，我們可以用下列隨機化算法以期望時間 \m{O(\sqrt{n})} 搜索鏈表。

\CLRSH{COMPACT-LIST-SEARCH(L, n, k)}
\startCLRS
i = L
while i ≠ NIL and key[i] < k
	j = RANDOM(1, n)
	if key[i] < key[j] and key[j] ≤ k
		i = j
		if key[i] == k
			return i
	i = next[i]
if i == NIL or key[i] > k
	return NIL
else
	return i
\stopCLRS

如果忽略 3～7 行，那麼他就退化成一個普通的搜索已排序鏈表的算法，
其中下標 \m{i} 依次指向鏈表的各個位置。
一旦下標 \m{i} 落到鏈表以外，或者 \m{key[i]\ge k}，算法終止。
在 \m{key[i]\ge k} 這種情況下，如果 \m{key[i] = k}，顯然我們找到了值爲 \m{k} 的 key；
而如果 \m{key[i] > k}，那麼我們就無法找到值爲 \m{k} 的 key 了；
因此算法終止。

3～7 行試圖跳到前面隨機選擇一個位置 \m{j}。
如果 \m{key[j]} 大於 \m{key[i]}，且不大於 \m{k}，那麼這樣處理是有好處的；
這種情況下， \m{j} 所指位置是普通搜索時 \m{i} 的必經之地。
由於鏈表是緊湊的，我們知道 1 到 n 之間的任意值所指位置都是鏈表中的元素，而不會是空閒的。

我們不直接分析 \ALGO{COMPACT-LIST-SEARCH} 的性能，而是先分析一個相關的算法， \ALGO{COMPACT-LIST-SEARCH'}，
他會執行兩個獨立的循環。
這個算法會接受一個額外的參數 \m{t}，此參數決定了第一個循環迭代次數的上界。

\CLRSH{COMPACT-LIST-SEARCH‘(L, n, k, t)}
\startCLRS
i = L
for q = 1 to t
	j = RANDOM(1, n)
	if key[i] < key[j] and key[j] ≤ k
		i = j
		if key[i] == k
			return i
while i ≠ NIL and key[i] < k
	i = next[i]
if i == NIL or key[i] > k
	return NIL
else
	return i
\stopCLRS

爲了比較這兩個算法，我們假設兩個算法中調用 \ALGO{RANDOM(1, n)} 所返回的值是相同的。
\startigBase[a]
\startitem
假設 \ALGO{COMPACT-LIST-SEARCH(L, n, k)} 中 2～8 行的 while 循環進行了 t 次迭代。
證明 \ALGO{COMPACT-LIST-SEARCH'(L, n, k, t)} 會返回同樣的結果，
且 for 和 while 循環迭代的次數之和至少爲 t。
\stopitem

\startANSWER
\TODO{}
\stopANSWER
\stopigBase

在調用 \ALGO{COMPACT-LIST-SEARCH'(L, n, k, t)} 的時候，
令隨機變數 \m{X_t} 代表 2～7 行的 for 迴圈經 t 次迭代後鏈表中
（即通過 \m{next} 指針鏈）從位置 i 到目標關鍵字 k 之間的距離。
\startigBase[a,continue]
\startitem
論證 \ALGO{COMPACT-LIST-SEARCH'(L, n, k, t)} 的期望運行時間為 \m{O(t+E[X_t])}。
\stopitem

\startANSWER
要不就是在 t 次迭代後找到了 k，否則 while 迴圈還要進行 \m{X_t} 次迭代。
\stopANSWER

\startitem
證明： \m{E[X_t]\le \sum_{r=1}^{n}(1-r/n)^t}。（\hint 用等式 C.25）
\stopitem

\startANSWER
當 \m{t=1} 時，距離大於等於 r 的概率为 \m{(n-r)/n}。
\startformula
\Pr\{X_t\ge r\} = (\frac{n-r}{n})^t = (1-\frac{r}{n})^t
\stopformula

即，有一次調用 \ALGO{RANDOM} 會得到期望的距離，而其他的則會不斷接近期望距離。

利用 C.25：
\startformula
E[X_t] = \sum_{r=1}^{\infty} \Pr\{X_t \ge r\}
        = \sum_{r=1}^n \Pr\{X_t \ge r\}
        = \sum_{r=1}^n \left(1 - \frac{r}{n}\right)^t
\stopformula
\stopANSWER

\startitem
證明： \m{E[X_t]\le n/(t+1)}。
\stopitem

\startANSWER
由 A.11 可知：
\startformula
\sum_{r=0}^{n-1} r^t \le \int_0^n x^t dx = \frac{n^{t+1}}{t+1}
\stopformula
因此：
\startformula\startmathalignment
\NC E[X_t]
    \NC= \sum_{r=1}^n \bigg(1 - \frac{r}{n}\bigg)^t \NR
\NC \NC= \sum_{r=0}^{n-1} \bigg(\frac{r}{n}\bigg)^t \NR
\NC \NC= \frac{1}{n^t} \sum_{r=0}^{n-1} r^t \NR
\NC \NC\le \frac{1}{n^t} \cdot \frac{n^{t+1}}{t + 1} \NR
\NC \NC= \frac{n}{t+1} \NR
\stopmathalignment\stopformula
\stopANSWER

\startitem
證明： \ALGO{COMPACT-LIST-SEARCH'(L, n, k, t)} 的期望運行時間爲 \m{O(t+n/t)}。
\stopitem

\startANSWER
\startformula
O(t + E[X_t]) = O(t + n/(t+1)) = O(t + n/t)
\stopformula
\stopANSWER

\startitem
論證 \ALGO{COMPACT-LIST-SEARCH'(L, n, k, t)} 的期望運行時間爲 \m{O(\sqrt{n})}。
\stopitem

\startANSWER
我們只需找到 \m{t+n/t} 的最小值。針對 \m{t} 求導爲 \m{1-n/t^2}， \m{t=\sqrt{n}} 時導數爲零。
因此期望運行時間爲 \m{O(\sqrt{n}}。
\stopANSWER

\startitem
爲什麼我們假設 \ALGO{COMPACT-LIST-SEARCH} 中的所有關鍵字互不相同？
論證如果包含相同關鍵字，則隨機跳躍不一定能改進漸進時間。
\stopitem

\startANSWER
如果有相同關鍵字，則無法得到 \m{E[X_t]\le n/(t+1)}。
只有當 \ALGO{RANDOM} 找到的值大於當前值時才會發生躍變。
例如，如果鏈表中全都是 0，而我們要找 1，算法仍然需要一直迭代，直到鏈表尾部。
\stopANSWER

\stopigBase
\stopPROBLEM

\stopsubject%Problems

\stopchapter
\stopcomponent

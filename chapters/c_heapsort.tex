\startcomponent c_heapsort

\chapter{Heapsort}

\startsection[
  reference=section:heaps,
  title={Heaps},
]

\startEXERCISE
在高度爲 \m{h} 的堆，最多有多少個元素，最少又有多少個元素？
\stopEXERCISE

\startANSWER
令高度爲 \m{h} 的堆中元素個數爲 \m{i}，則\m{2^h \le i \le (2^{h+1} - 1)}。
\stopANSWER

\startEXERCISE[exercise:heap_height]
證明：含 \m{n} 個元素的堆的高度爲 \m{\lfloor \lg{n} \rfloor}。
\stopEXERCISE

\startANSWER
由上個練習可知 \m{n \in (2^h, 2^{h+1} - 1)}，所以高度爲 \m{\lfloor \lg{n} \rfloor}。
\stopANSWER

\startEXERCISE
證明：在最大堆的任一子樹中，該子樹所包含的最大元素在該子樹的根節點上。
\stopEXERCISE

\startANSWER
這就是最大堆的性質。

即設子樹的根節點是第 \m{i} 個元素，則他的子節點均小於或等於他。
由於其子節點均滿足此性質，且此性質是可傳遞的，所有節點均小於或等於根節點，
因此根節點是最大的。
\stopANSWER

\startEXERCISE
假設一個最大堆的所有元素都不相同，那麼該堆的最小元素應該位於哪裏？
\stopEXERCISE

\startANSWER
可能在任何一個葉子節點上，即索引爲 \m{\lfloor n/2 \rfloor + 1} 的元素
（參見\refexercise{heap_leave}），即堆數列的右半部分中。
\stopANSWER

\startEXERCISE
一個已排好序的數列是最小堆嗎？
\stopEXERCISE

\startANSWER
是。對任一索引 \m{i}， \ALGO{LEFT(i)} 和 \ALGO{RIGHT(i)} 均要大於 \m{i}，
相應的元素均大於或等於 \m{A[i]}（數列是排好序的）。
\stopANSWER

\startEXERCISE
數列 \m{\langle 23, 17, 14, 6, 13, 10, 1, 5, 7, 12 \rangle} 是最大堆嗎？
\stopEXERCISE

\startANSWER
不是。 \m{7} 比 \m{6} 大。

\externalfigure[output/e6_1_6-1]

\stopANSWER

\startEXERCISE[exercise:heap_leave]
證明：用數列表示有 \m{n} 個元素的堆時，
葉子節點的索引爲 \m{\lfloor n/2 \rfloor + 1,\lfloor n/2 \rfloor + 2, \ldots, n}。
\stopEXERCISE

\startANSWER
若索引爲 \m{i} 的節點是葉子節點，則沒有子節點，等價於：
\startformula\startmathalignment[n=1]
\NC \mfunction{LEFT}(i) = 2 i > n \NR
\NC i > n/2 \NR
\NC i \ge (\lfloor n/2 \rfloor + 1) \NR
\stopmathalignment\stopformula
\stopANSWER

\stopsection%Heaps

\section{Maintaining the heap property}

\startEXERCISE
參照圖 6-2 的方法，說明 \ALGO{MAX-HEAPIFY(A, 3)} 在
數列 \m{A = \langle 27, 17, 3, 16, 13, 10, 1, 5, 7, 12, 4, 8, 9, 0\rangle} 上的操作過程。
\stopEXERCISE

\startANSWER
\startcombination[2*2]
{\externalfigure[output/e6_2_1-1]}{}
{\externalfigure[output/e6_2_1-2]}{}
{\externalfigure[output/e6_2_1-3]}{}
{}{}
\stopcombination
\stopANSWER

\startEXERCISE
參考 \ALGO{MAX-HEAPIFY}，寫出能維護相應最小堆的 \ALGO{MIN-HEAPIFY(A, i)} 的僞碼，
並比較 \ALGO{MIN-HEAPIFY} 和 \ALGO{MAX-HEAPIFY} 的運行時間。
\stopEXERCISE

\startANSWER
\CLRSH{MIN-HEAPIFY(A, i)}
\startCLRS
l = LEFT(i)
r = RIGHT(i)
if l ≤ A.heap-size and A[l] < A[i]
	smallest = l
else
	smallest = i
if r ≤ A.heap-size and A[r] < A[i]
	smallest = r
if smallest ≠ i
	exchange A[i] with A[smallest]
	MIN-HEAPIFY(A, smallest)
\stopCLRS

\ALGO{MIN-HEAPIFY} 和 \ALGO{MAX-HEAPIFY} 的運行時間的運行時間相同。
\stopANSWER

\startEXERCISE
當元素 \m{A[i]} 比其兩個子節點的值都大時，調用 \ALGO{MAX-HEAPIFY(A, i)} 會有什麼結果？
\stopEXERCISE

\startANSWER
沒有變化。執行比較後，發現 \m{A[i]} 本身就是最大的，直接返回了。
\stopANSWER

\startEXERCISE
當 \m{i > A.heap-size / 2} 時，調用 \ALGO{MAX-HEAPIFY(A, i)} 會有什麼結果？
\stopEXERCISE

\startANSWER
沒有變化。因爲 \m{A[i]} 是葉子節點。 \ALGO{LEFT} 和 \ALGO{RIGHT} 所返回的值都大於 \m{A} 的元素個數；
 \m{i} 即 \m{largest}，然後就返回了。
\stopANSWER

\startEXERCISE
就常量因子而言， \ALGO{MAX-HEAPIFY} 的執行效率很不錯，
但第 \m{10} 行可能時隔例外，有的編譯器可能會產生低效的代碼。
請用循環控制結構取代遞迴，重寫 \ALGO{MAX-HEAPIFY}。
\stopEXERCISE

\startANSWER
\CLRSH{MAX-HEAPIFY-LOOP(A, i)}
\startCLRS
while true
	l = LEFT(i)
	r = RIGHT(i)
	if l ≤ A.heap-size and A[l] < A[i]
		largest = l
	else
		largest = i
	if r ≤ A.heap-size and A[r] < A[i]
		largest = r
	if largest == i
		return
	exchange A[i] with A[largest]
	i = largest
\stopCLRS
\stopANSWER

\blank

\startEXERCISE
證明：對於一個大小爲 \m{n} 的堆， \ALGO{MAX-HEAPIFY} 的最壞情況運行時間爲 \m{\Omega(\lg{n})}。
（\hint 於 \m{n} 個節點的堆，可以通過對每個節點設定恰當的值，
使得從根節點到葉節點路徑上的每個節點都會遞迴調用 \ALGO{MAX-HEAPIFY}。）
\stopEXERCISE

\startANSWER
結論是顯然的。以最左邊的路徑爲例，如果堆中最大元素在此路徑上，而根節點是最小元素，
則爲將最小元素放到葉子節點上，此路徑上的每一個節點都會調用一次 \ALGO{MAX-HEAPIFY}。
由於堆的高度爲 \m{\lfloor \lg{n} \rfloor} \refexercise{heap_height}，最壞情況運行時間爲 \m{\Omega(\lg{n})}。
\stopANSWER

\section{Building heap}

\startEXERCISE
參照圖 6-3 的方法，
說明 \ALGO{BUILD-MAX-HEAP} 在數列 \m{A = \langle 5, 3, 17, 10, 84, 19, 6, 22, 9 \rangle} 上的操作過程。
\stopEXERCISE

\startANSWER
\startcombination[3*2]
{\externalfigure[output/e6_3_1-1]}{}
{\externalfigure[output/e6_3_1-2]}{}
{\externalfigure[output/e6_3_1-3]}{}
{\externalfigure[output/e6_3_1-4]}{}
{\externalfigure[output/e6_3_1-5]}{}
{}{}
\stopcombination
\stopANSWER

\startEXERCISE
對於 \ALGO{BUILD-MAX-HEAP} 中第 2 行的循環控制變量 \m{i} 而言，
爲什麼要求他從 \m{\lfloor A.length/2 \rfloor} 到 \m{1} 遞減，
而不是從 \m{1} 到 \m{\lfloor A.length/2 \rfloor} 遞增？
附：

\CLRSH{BUILD-MAX-HEAP(A)}
\startCLRS
A.heap-size = A.length
for i =  ⌊A.length/2⌋ downto 1
	MAX-HEAPIFY(A, i)
\stopCLRS
\stopEXERCISE

\startANSWER
如果是遞增的話，就不能調用 \ALGO{MAX-HEAPIFY} 了，因爲無法保證子樹是最大堆。
即如果從 \m{1} 開始，無法保證 \m{A[2]} 和 \m{A[3]} 是最大堆的根節點。
\stopANSWER

\startEXERCISE
證明：對於任一含有 \m{n} 個元素的堆，最多有 \m{\lceil n/2^{h+1} \rceil} 個高度爲 \m{h} 的節點。
\stopEXERCISE

\startANSWER
首先，堆中葉子節點的個數爲 \m{\lceil n/2 \rceil} \refexercise{heap_leave}。
下面歸納證明 \m{h}：

{\EMP 初始化：} \m{h = 0} 時，葉子節點數目 \m{\lceil n/2 \rceil = \lceil n/2^{0+1} \rceil}；

{\EMP 保持：}假設對於 \m{h - 1} 結論成立，移除所有葉子節點得到的新堆含有 \m{n-\lceil n/2 \rceil = \lfloor n/2 \rfloor} 個元素，
原堆中高度爲 \m{h} 的節點在新樹中高度爲 \m{h-1}；
令新樹中高度爲 \m{h-1} 的節點個數爲 \m{T}，則由假設可知：
\startformula
T = \lceil \lfloor n/2 \rfloor / 2^{h-1+1} \rceil
     < \lceil (n/2)/2^h \rceil
     = \lceil \frac{n}{2^{h+1}} \rceil
\stopformula
即對於 \m{h} 結論依舊成立。
\stopANSWER

\section{The heapsort algorithm}

\startEXERCISE
參照圖 6-4 的方法，
說明 \ALGO{HEAPSOR} 在數列 \m{A = \langle 5, 13, 2, 25, 7, 17, 20, 8, 4 \rangle} 上的操作過程。
\stopEXERCISE

\startANSWER
\startcombination[4*3]
{\externalfigure[output/e6_4_1-1]}{}
{\externalfigure[output/e6_4_1-2]}{}
{\externalfigure[output/e6_4_1-3]}{}
{\externalfigure[output/e6_4_1-4]}{}
{\externalfigure[output/e6_4_1-5]}{}
{\externalfigure[output/e6_4_1-6]}{}
{\externalfigure[output/e6_4_1-7]}{}
{\externalfigure[output/e6_4_1-8]}{}
{\externalfigure[output/e6_4_1-9]}{}
\stopcombination
\stopANSWER

\startEXERCISE
試分析在使用下列循環不變式時， \ALGO{HEAPSORT} 的正確性：

在算法的第 2～5 行 {\EMP for} 循環每次迭代開始時，
子數列 \m{A[1..i]} 是一個包含了數列 \m{A[1..n]} 中第 \m{i} 小元素的最大堆，
而子數列 \m{A[i+1..n]} 則包含了數列 \m{A[1..n]} 中已排好序的 \m{n-i} 個最大元素。
\stopEXERCISE

\startANSWER
{\EMP 初始化：}子數列 \m{A[i+1..n]} 爲空，不變式成立；

{\EMP 保持：} \m{A[1]} 是 \m{A[1..i]} 中最大的，但是小於 \m{A[i+1..n]} 中所有元素。
將 \m{A[1]} 和 \m{A[i]} 調換後，則 \m{A[i..n]} 中的元素是最大的，且是排好序的。
堆的大小減一，並調用 \ALGO{MAX-HEAPIFY} 會將 \m{A[1..i-1]} 構造成最大堆。
將 \m{i} 減一，繼續下一次迭代；

{\EMP 終止：}待 \m{i=1} 時， \m{A[2..n]} 是排好序的，而 \m{A[1]} 是最小的，
因此整個數列爲排好序的。
\stopANSWER

\startEXERCISE[exercise:heapsort_time]
如果數列 \m{A} 含有 \m{n} 個元素，且已經是升序排列， \ALGO{HEAPSORT} 的時間復雜度是多少？
如果已經按降序排列呢？
\stopEXERCISE

\startANSWER
兩者均爲 \m{\Theta(n\lg{n})}。

如果已經按升序排列，將其轉換成堆需要 \m{O(n)}，然後需要調用 \ALGO{MAX-HEAPIFY} 共 \m{n-1} 次，
每次調用需要 \m{\lg{k}} 次運算。因此：
\startformula
\sum_{i=1}^{n-1}\lg{k} = \lg((n-1)!) = \Theta(n\lg{n})
\stopformula

如果已經按降序排列，則 \ALGO{BUILD-MAX-HEAP} 會快一些（常量因子），
但時間主要花在 \ALGO{HEAPSORT} 中的循環上，時間爲 \m{\Theta(n\lg{n})}。
\stopANSWER

\startEXERCISE
證明：最壞情況下， \ALGO{HEAPSORT} 的時間復雜度是 \m{\Omega(n\lg{n})}。
\stopEXERCISE

\startANSWER
與\refexercise{heapsort_time}的第一部分相同。
如果數列已經排好序，我們需要線性時間將其轉換成最大堆，然後需要 \m{n\lg{n}} 的時間排序。
\stopANSWER

\startEXERCISE\DIFFICULT
證明： 在所有元素都不同的情況下， \ALGO{HEAPSORT} 的時間復雜度爲 \m{\Omega(n\lg{n})}。
\stopEXERCISE

\startANSWER
假設堆是完全二叉樹，元素個數爲 \m{n=2^k - 1}。有 \m{2^{k-1}} 個葉子節點以及 \m{2^{k-1} - 1} 個內部節點。

先來看爲堆中前 \m{2^{k-1}} 個元素排序。
給葉子節點着紅色，內部節點着藍色。
已着色的節點是堆的子樹。
由於有 \m{2^{k-1}} 個節點已着色，紅色的最多有 \m{2^{k-2}} 個，藍色的最少 \m{2^{k-2}-1} 個。

紅色節點可以直接跳到根節點位置上，而藍色節點則需要先上移。
讓我們統計以下要將藍色節點移到根節點位置上，需要交換多少次。
交換次數最少的情況必須滿足兩點，
有 \m{2^{k-2} -1} 個藍色節點，
且他們在樹中的相對位置已經滿足最大堆的要求。
如果有 \m{d} 個這樣的藍色節點，則有 \m{i=\lg{d}} 層，
第 \m{i} 層含有 \m{2^i} 個節點。
因此交換次數爲：
\startformula
\sum_{i=0}^{\lg{d}}i2^i = 2 + (\lg{d} - 2)2^{\lg{d}} = \Omega(d\lg{d})
\stopformula

遞迴式：
\startformula
T(n) = T(n/2) + \Omega(n\lg{n})
\stopformula

由主定理可得 \m{T(n)=\Omega(n\lg{n})}。
\stopANSWER

\section{Priority queues}

\startEXERCISE
試說明 \ALGO{HEAP-EXTRACT-MAX} 在堆 \m{A = \langle
15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1 \rangle} 上的操作過程。
\stopEXERCISE

\startANSWER
\startcombination[2*2]
{\externalfigure[output/e6_5_1-1]}{}
{\externalfigure[output/e6_5_1-2]}{}
{\externalfigure[output/e6_5_1-3]}{}
\stopcombination
\stopANSWER

\startEXERCISE
試說明 \ALGO{MAX-HEAP-INSERT(A, 10)} 在堆 \m{A = \langle
15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1 \rangle} 上的操作過程。
\stopEXERCISE

\startANSWER
\startcombination[2*2]
{\externalfigure[output/e6_5_2-1]}{}
{\externalfigure[output/e6_5_2-2]}{}
{\externalfigure[output/e6_5_2-3]}{}
\stopcombination
\stopANSWER

\startEXERCISE
要求用最小堆實現最小優先隊列，請寫出 \ALGO{HEAP-MINIMUM}、 \ALGO{HEAP-EXTRACT-MIN}、
 \ALGO{HEAP-DECREASE-KEY} 和 \ALGO{MIN-HEAP-INSERT} 的僞碼。
\stopEXERCISE

\startANSWER
\CLRSH{HEAP-MINIMUM(A)}
\startCLRS
return A[1]
\stopCLRS

\CLRSH{HEAP-EXTRAC-MIN(A)}
\startCLRS
if A.heap-size < 1
	error "heap underflow"
min = A[1]
A[1] = A[A.heap-size]
A.heap-size = A.heap-size - 1
MIN-HEAPIFY(A, 1)
\stopCLRS

\CLRSH{HEAP-DECREASE-KEY(A, i, key)}
\startCLRS
if key > A[i]
	error "new key is bigger than current key"
A[i] = key
while i > 1 and A[PARENT(i)] > A[i]
	exchange A[i] with A[PARENT(i)]
	i = PARENT(i)
\stopCLRS

\CLRSH{MIN-HEAP-INSERT(A, key)}
\startCLRS
A.heap-size = A.heap-size + 1
A[A.heap-size] = +∞
HEAP-DECREASE-KEY(A, A.heap-size, key)
\stopCLRS
\stopANSWER

\startEXERCISE
在 \ALGO{MAX-HEAP-INSERT} 的第 2 行，爲什麼要先把關鍵字設爲 \m{-\infty}，
然後又將其增加到所需的值？
\stopEXERCISE

\startANSWER
是爲了能通過 \ALGO{HEAP-INCREASE-KEY} 中的校驗 \m{key < A[i]}。
\stopANSWER

\startEXERCISE
試分析在使用下列循環不變式時， \ALGO{HEAP-INCREASE-KEY} 的正確性：

在算法的第 4～6 行 {\EMP while} 循環每次迭代開始時，
子數列 \m{A[1..A.heap-size]} 要滿足最大堆的性質。
如果由違背，只有一個可能： \m{A[i]} 大於 \m{A[PARENT(i)]}。

這裏，可以假定調用 \ALGO{HEAP-INCREASE-KEY} 時， \m{A[1..A.heap-size]} 是滿足最大堆性質的。
\stopEXERCISE

\startANSWER
{\EMP 初始化：} \m{A} 是最大堆，除非 \m{A[i]} 比他的父節點大，因此只有 \m{A[i]} 被修改過。
 \m{A[i]} 比其子節點大，否則無法通過參數校驗，即不會進入循環（新值大於舊值，
 且舊值大於其父節點）；

{\EMP 保持：} 調換 \m{A[i]} 和其父節點時，仍然滿足最大堆的性質，
只有 \m{A[PARENT(i)]} 可能比其父節點大。 \m{i} 變爲 \m{PARENT(i)} 後此不變式仍然成立；

{\EMP 終止：}當到達根節點，或者 \m{A[i]} 和其父節點關系滿足最大堆的性質時，循環終止。
循環終止後， \m{A} 就是一個最大堆了。
\stopANSWER

\startEXERCISE
在 \ALGO{HEAP-INCREASE-KEY} 的第 5 行，一般要通過三次賦值才能完成交換操作。
想一想如何利用 \ALGO{INSERTION-SORT} 內循環部分的思想，
只用一次賦值就完成這一交換操作？
\stopEXERCISE

\startANSWER
\CLRSH{HEAP-INCREASE-KEY(A, i, key)}
\startCLRS
if key < A[i]
	error "new key is smaller than current key"
while i > 1 and A[PARENT(i)] < key
	A[i] = A[PARENT(i)]
	i = PARENT(i)
A[i] = key
\stopCLRS
\stopANSWER

\startEXERCISE
試說明如何使用優先隊列來實現一個先進先出隊列，以及如何使用優先隊列實現棧
（隊列和棧的定義見\refsection{stack_and_queue}）。
\stopEXERCISE

\startANSWER
對於棧，新元素具有最高優先級，而對於隊列，新元素具有最小優先級。
對於棧，新元素優先級爲 \m{HEAP-MAXIMUM(A) + 1}。
而對於隊列，則需要跟蹤新元素，每次增加新元素時，都用更小的優先級。
但是兩者性能均不高。
而且如果優先級會上溢或下溢，我們需要重新指定優先級。
\stopANSWER

\startEXERCISE
\ALGO{HEAP-DELETE(A, i)} 能將節點 \m{i} 從堆 \m{A} 中刪除。
對於一個包含 \m{n} 個元素的堆，
請設計一個能在 \m{O(\lg{n})} 時間內完成的 \ALGO{HEAP-DELETE} 算法。
\stopEXERCISE

\startANSWER
\CLRSH{HEAP-DELETE(A, i)}
\startCLRS
A[i] = A[A.heap-size]
A.heap-size = A.heap-size - 1
MAX-HEAPIFY(A, i)
\stopCLRS
\stopANSWER

\startEXERCISE[exercise:k_merge]
請設計一個時間復雜度爲 \m{O(n\lg{k})} 的算法，
可以將 \m{k} 個有序鏈表合並爲一個有序鏈表，
這裏 \m{n} 是所有輸入鏈表包含的元素總數。
（\hint 用最小堆來完成 \m{k} 路歸並）
\stopEXERCISE

\startANSWER
從各鏈表中取一個元素，放入最小堆中。
對於每個元素，我們需要跟蹤是從哪個鏈表中取出來的。
歸並時，每從堆中取出最小的元素，則從此元素所屬鏈表中取一個元素放入堆中（除非這個鏈表爲空）。
一直重復此操作直到堆爲空。

一共需 \m{n} 步，每一步都包含一個堆的插入操作（時間爲 \m{\lg{k}}）。
\stopANSWER

\startPROBLEM
（用插入的方式建堆 Building a heap using insertion）
我們可以通過反復調用 \ALGO{MAX-HEAP-INSERT} 不斷向堆中插入元素來構建一個堆。
考慮 \ALGO{BUILD-MAX-HEAP} 如下實現方式：

\CLRSH{BUILD-MAX-HEAP'(A)}
\startCLRS
A.heap-size = 1
for i = 2 to A.length
	MAX-HEAP-INSERT(A, A[i])
\stopCLRS

\startigBase[a]
\startitem
當輸入數據相同時， \ALGO{BUILD-MAX-HEAP} 和 \ALGO{BUILD-MAX-HEAP'} 所生成的堆是否相同？
如果是，請證明；否則請舉出反例。

\startANSWER
不同。例如，輸入數據爲 \m{\langle 1, 2, 3, 4, 5, 6 \rangle} 時，兩個堆分別如下：

\startcombination[2*1]
{\externalfigure[output/p6_1_a-1]}{}
{\externalfigure[output/p6_1_a-2]}{}
\stopcombination

\stopANSWER
\stopitem
\startitem
證明：最壞情況下，調用 \ALGO{BUILD-MAX-HEAP'} 建立包含 \m{n} 個元素的堆，
其時間復雜度爲 \m{\Theta(n\lg{n})}。

\startANSWER
最壞情況下， \ALGO{MAX-HEAP-INSERT} 的運行時間爲 \m{\Theta(\lg{n})}，會被調用 \m{n-1} 次。
最壞情況下， \ALGO{MAX-HEAP-INSERT} 會將所有元素都移到堆的根節點上， 即需要 \m{\lg{k}} 次交換，
無論 \m{k} 的值是多少。
如果輸入數列已經是排好序的，則就是最壞情況。時間復雜度爲（參見\refexercise{lg_n_fac}）：
\startformula
\sum_{i=2}^{n}\lg{i} = \lg(n!) = \Theta(n\lg{n})
\stopformula
\stopANSWER
\stopitem
\stopigBase
\stopPROBLEM

\startPROBLEM
（堆 d 叉堆的分析 Analysis of d -ary heaps）
d 叉堆與二叉堆類似，只是每個非葉子節點有 \m{d} 個子節點，而不是 2 個子節點。
\startigBase[a]
\startitem
如何在一個數列中表示 \m{d} 叉堆？

\startANSWER
需要修改 \ALGO{LEFT}、 \ALGO{RIGHT} 和 \ALGO{PARENT} 的定義。
第 \m{i} 個元素的第 \m{k} 個子節點的索引爲 \m{di + k - 1}，
而父節點的索引爲 \m{\lfloor i/d \rfloor}。（索引從 1 開始）
\stopANSWER
\stopitem

\startitem
包含 \m{n} 個元素的 \m{d} 叉堆的高度是多少？用 \m{n} 和 \m{d} 表示。

\startANSWER
\m{\log_d{n}}。
\stopANSWER
\stopitem

\startitem
請給出 \ALGO{EXTRACT-MAX} 在 \m{d} 叉最大堆上的一個有效實現，
並用 \m{d} 和 \m{n} 表示其時間復雜度。

\startANSWER
\ALGO{EXTRACT-MAX} 的時間復雜度爲 \m{O(d\log_d{n})}。
\stopANSWER
\stopitem

\startitem
請給出 \ALGO{INSERT} 在 \m{d} 叉最大堆上的一個有效實現，
並用 \m{d} 和 \m{n} 表示其時間復雜度。

\startANSWER
\ALGO{INSERT} 的時間復雜度爲 \m{O(\log_d{n})}。
\stopANSWER
\stopitem

\startitem
請給出 \ALGO{INCREASE-KEY(A, i, k)} 在 \m{d} 叉最大堆上的一個有效實現。
當 \m{k<A[i]} 時，他會觸發一個錯誤，否則執行 \m{A[i]=k}，並更新相應的堆。
並用 \m{d} 和 \m{n} 表示其時間復雜度。

\startANSWER
\ALGO{INCREASE-KEY(A, i, k)} 的時間復雜度爲 \m{O(\log_d{n})}。
\stopANSWER
\stopitem
\stopigBase
\stopPROBLEM

\startPROBLEM
（Young 氏矩陣 Young tableaus）
在一個 \m{m\times n} 的{\EMP Young 氏矩陣}中，
每一行的數據都是從左到右有序的，每一列數據都是從上到下有序的。
其中也會有一些值爲 \m{\infty} 的數據項，用來表示不存在的元素。
因此， Young 氏矩陣可以用來存儲 \m{r\le mn} 個有限的數。

\startigBase[a]
\startitem
畫出一個包含元素爲 \m{\{9, 16, 3, 2, 4, 8, 5, 14, 12\}} 的 \m{4\times 4} Young 氏矩陣。

\startANSWER
\startformula\startpmatrix%[location=low]
\NC      2 \NC      3 \NC     12 \NC     14 \NR
\NC      4 \NC      8 \NC     16 \NC \infty \NR
\NC      5 \NC      9 \NC \infty \NC \infty \NR
\NC \infty \NC \infty \NC \infty \NC \infty \NR
\stoppmatrix\stopformula
\stopANSWER
\stopitem

\startitem
對於一個 \m{m\times n} 的 Young 氏矩陣 \m{Y} 而言，請證明：
如果 \m{Y[1,1]=\infty}，則 \m{Y} 爲空；
如果 \m{Y[m,n]<\infty}，則 \m{Y} 爲滿（即包含 \m{mn} 個元素）。

\startANSWER
如果 \m{Y[1,1]=\infty}，則第一行元素都要大於等於左上角元素，即第一行元素均爲 \m{\infty}，
而對於任一列而言，所有元素都要大於此列中第一行的元素，即整個矩陣所有元素均爲 \m{\infty}。
類似，如果 \m{Y[m,n]<\infty}，則其他元素均小於等於由下角元素，即所有元素都不是 \m{\infty}，即矩陣爲滿。
\stopANSWER
\stopitem

\startitem
請給出一個在 \m{m\times n} Young 氏矩陣上時間復雜度爲 \m{O(m+n)} 的 \ALGO{EXTRACT-MIN} 的算法實現。
可以考慮使用一個遞迴過程，將規模爲 \m{m\times n} 的問題分解爲規模爲 \m{(m-1)\times n} 或
者 \m{m\times(n-1)} 的子問題（\hint 考 \ALGO{MAX-HEAPIFY}）。
這裏，定義 \m{T(p)} 用來表示 \m{EXTRACT-MIN} 在任一 \m{m\times n} 的 Young 氏矩陣上的時間復雜度，
其中 \m{p=m+n}。給出並求解 \m{T(p)} 的遞迴表達式，其結果爲 \m{O(m+n)}。

\startANSWER
\m{A[1,1]} 是最小的，就是返回值，將其替換爲 \m{\infty}，這會破壞 Young 氏矩陣的性質，
用類似 \ALGO{MAX-HEAPIFY} 的過程來維持其性質。
將 \m{A[i,j]} 與其鄰居比較，並將鄰居中最小的與其交換位置。
這樣會使得 \m{A[i,j]} 遵循 Young 氏矩陣的性質，然後將變成 \m{A[i,j+1]} 或 \m{A[i+1,j]} 的問題。
當 \m{A[i,j]} 比所有鄰居都小時，就終止程序。則：
\startformula
T(p) = T(p - 1) + O(1) = T(p-2) + O(1) + O(1) = \ldots = O(p)
\stopformula
\stopANSWER
\stopitem

\startitem
試說明如何在 \m{O(m+n)} 的時間內，將一個新元素插入到一個未滿的 \m{m\times n} 的 Young 氏矩陣中。

\startANSWER
與上一題類似，只是改爲從右下角開始，向左向上移動。時間不變。
\stopANSWER
\stopitem

\startitem
在不用其他配序算法的情況下，試說明如何利用一個 \m{n\times n} 的 Young 氏矩陣在 \m{O(n^3)} 時間內
將 \m{n^2} 個數進行排序。

\startANSWER
矩陣開始爲空，最終爲滿，插入元素 \m{n^2} 個。
每次插入操作都需時間 \m{O(n+n)=O(n)}。復雜度爲 \m{n^2O(n)=O(n^3)}。
然後在矩陣中一個一個的取元素，放入原數列中，時間復雜度一樣。
總共時間爲 \m{O(n^3)}。

如果允許矩陣中只有左上角一部分元素具有 Young 氏矩陣的性質，則可以原地排序。
\stopANSWER
\stopitem

\startitem
設計一個時間復雜度爲 \m{O(m+n)} 的算法，
用來判斷一個給定的數是否存儲在 \m{m\times n} 的 Young 氏矩陣中。

\startANSWER
從左下角開始，比較 \m{current} 和 \m{key}，
如果 \m{current > key}，則上移，如果 \m{current < key}，則右移。
如果 \m{current = key}，則返回成功，否則直到終止。
\stopANSWER
\stopitem

\stopigBase
\stopPROBLEM

\stopcomponent
